\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{bussproofs}
\usepackage{listings}
\usepackage{parskip}

\lstnewenvironment{Code}{
  \lstset{
    basewidth=0.5em,
    basicstyle=\ttfamily,
    gobble=2,
    mathescape,
    xleftmargin=1em,
  }
}{}
\theoremstyle{definition}

\newcommand{\Cd}[1]{\mbox{\lstinline[basewidth=0.5em,basicstyle=\ttfamily,mathescape]{#1}}}
% Use |x| as a short verb also available in math mode.
\catcode`|=\active
\def|#1|{\Cd{#1}}

\newcommand{\card}[1]{\vert#1\vert}
\newcommand{\code}[1]{\mbox{\lstinline[basewidth=0.5em,basicstyle=\ttfamily]{#1}}}
\newcommand{\lmd}[1]{\lambda \texttt{#1.}}
\newcommand{\Lmd}[2]{\lambda \texttt{#1}#2\texttt{.}}
\newcommand{\phantomrel}[1]{\phantom{{}#1{}}}
\newcommand{\proofbreak}{\\ \vspace{1em}}
\newcommand{\proofsep}{\quad}
\newcommand{\dshift}{\uparrow}
\newcommand{\subst}[1]{[#1]\,}
\newcommand{\where}{~ \text{where} ~}

\newcommand{\Ab}[1]{\lambda #1 \texttt{.}}
\newcommand{\AbTy}[2]{\lambda #1 \texttt{:} #2 \texttt{.}}
\newcommand{\Bigstep}{\Downarrow}
\newcommand{\Case}{\textit{Case} }
\newcommand{\CParen}[1]{\texttt(#1\texttt)}
\newcommand{\Ctx}[2]{#1 \Ts #2}
\newcommand{\CtxTyRel}[3]{\Ctx{#1}{\TyRel{#2}{#3}}}
\newcommand{\CtxSto}[3]{\Ctx{\Store{#1}{#2}}{#3}}
\newcommand{\Ctxx}[3]{#2 \vdash^{#1} #3}
\newcommand{\CtxxTyRel}[4]{\Ctxx{#1}{#2}{\TyRel{#3}{#4}}}
\newcommand{\EqComment}[1]{[\text{\small #1}]}
\newcommand{\EqDef}{\stackrel{\text{def}}{=}}
\newcommand{\Ex}[1]{\subsection*{Exercise #1}}
\newcommand{\IfThenElse}[3]{|if|~#1~|then|~#2~|else|~#3}
\newcommand{\Indices}[1]{{}^{#1}}
\newcommand{\Iszero}{|iszero|~}
\newcommand{\LambdaNB}{$\lambda$\textbf{NB}}
\newcommand{\Lemma}[1]{\textsc{Lemma #1.}}
\newcommand{\Let}[2]{\texttt{let} ~ #1 = #2 ~ \texttt{in} ~}
\newcommand{\Lm}{\lambda}
\newcommand{\N}{\mathbb N}
\newcommand{\Pred}{|pred|~}
\newcommand{\Proof}{\textsc{Proof}}
\newcommand{\Rec}[1]{\Cd\{#1\Cd\}}
\newcommand{\Rule}[1]{\textsc{#1}}
\newcommand{\RuleLabel}[1]{\RightLabel{\Rule{\scriptsize #1}}}
\newcommand{\Store}[2]{#1 \mid #2}
\newcommand{\Sb}{\mathop{\texttt<\hspace{-0.3ex}\raise0.15ex\hbox{\texttt:}}}
\newcommand{\Sub}[2]{#1 \Sb #2}
\newcommand{\Succ}{\texttt{succ}~}
\newcommand{\Theorem}{\textsc{Theorem}}
\newcommand{\To}{\Rightarrow}
\newcommand{\Ts}{\vdash}
\newcommand{\TyRel}[2]{#1 ~\texttt:~ #2}

\title{Excercise Solutions for \break Types and Programming Languages}
\author{Seiya Tokui}

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 1.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

nothing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 2.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mathematical Preliminaries}

\Ex{2.2.4}

$R'$ is reflexive by definition, so let us show that any reflexive relation $R''$
  that contains $R$ also contains $R'$.
Let $(s, t) \in R'$.
If $s = t$, then it holds that $(s, t) = (s, s) \in R''$ as $R''$ is reflexive.
Otherwise, $(s, t) \in R \subseteq R''$. \qed

\Ex{2.2.7}

Let $s, t, u$ satisfy $(s, t), (t, u) \in R^+ = \bigcup_i R_i$.
Since $(R_i)_i$ is a non-decreasing sequence of relations,
  there exists $k$ that satisfies $(s, t), (t, u) \in R_k$.
It then holds that $(s, u) \in R_{k + 1} \subseteq R^+$.
Therefore, the relation $R^+$ is transitive.

Let $R'$ be a transitive relation that contains $R$.
We show $R_i \subseteq R'$ by induction on $i$.
By definition, $R_0 = R \subseteq R'$.
Assume $R_i \subseteq R'$ for some $i$.
Let $(s, u) \in R_{i + 1}$.
If $(s, u) \in R_i$, then $(s, u) \in R'$.
Otherwise, there exists $t$ such that $(s, t), (t, u) \in R_i$.
Then, $(s, t), (t, u) \in R'$, which implies $(s, u) \in R'$ by transitivity of $R'$.
Therefore, $R_{i + 1} \subseteq R'$.
By taking the union, it holds that $R^+ = \bigcup_i R_i \subseteq R'$. \qed

\Ex{2.2.8}

W.l.o.g., we can assume $R$ is reflexive by replacing it with its reflexive closure.
Suppose that $R^*$ is constructed from $R$ as $R^+$ in Exercise 2.2.7.
We show by induction on $i$ that $P$ is preserved by $R_i$.
First, $P$ is preserved by $R_0 = R$.
Assume that $P$ is preserved by $R_i$ for some $i$.
If $s \in P$ and $(s, u) \in R_{i + 1}$,
  it holds that $(s, u) \in R_i$
  or there exists $t$ such that $(s, t), (t, u) \in R_i$.
By induction hypothesis,
  in the former case, $u \in P$,
  and in the latter case, $t \in P$ and thus $u \in P$.
Therefore, $P$ is preserved by $R_{i + 1}$, concluding the induction.
It then holds that $P$ is preserved by $R^* = \bigcup_i R_i$. \qed

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 3.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Untyped Arithmetic Expressions}

\Ex{3.2.4}

We have $\card{S_0} = 0$ and $\card{S_{i + 1}} = 3 + 3\card{S_i} + \card{S_i}^3$,
  we thus get $\card{S_3} = 59439$.

\Ex{3.2.5}

We show it by induction on $i$.
We have $S_0 = \emptyset \subseteq S_1$.
Suppose $S_{i - 1} \subseteq S_i$ for given $i \in \{1, 2, \dots\}$.
Then, by definition of $S_{i + 1}$, we have
\begin{alignat*}{2}
  S_{i + 1} &=~
  && \{ |true|, |false|, |0| \} \\
  & && \cup \{
    \Succ |t|_1, ~\Pred |t|_1, ~\Iszero |t|_1
    \mid |t|_1 \in S_i
  \} \\
  & && \cup \{
    \IfThenElse{|t|_1}{|t|_2}{|t|_3}
    \mid |t|_1, |t|_2, |t|_3 \in S_i
  \} \\
  &\supseteq~
  && \{ |true|, |false|, |0| \} \\
  & && \cup \{
    \Succ |t|_1, ~\Pred |t|_1, ~\Iszero |t|_1
    \mid |t|_1 \in S_{i - 1}
  \} \\
  & && \cup \{
    \IfThenElse{|t|_1}{|t|_2}{|t|_3}
    \mid |t|_1, |t|_2, |t|_3 \in S_{i - 1}
  \} \\
  &=&& S_i.
\end{alignat*}
\qed

\Ex{3.3.4}

\paragraph{Induction on depth or size}
Let $Q(n) = \{ |s| \in S \mid depth(|s|) \le n \}$.
We have $S = \bigcup_{n\in\N} Q(n)$.
Induction on depth implies that,
  given $P(|s|)$ holds for all $|s| \in Q(n)$,
  $P(|s|)$ holds for all $|s| \in Q(n + 1)$.
By induction on $n$, $P(|s|)$ holds for all $|s| \in S$.
Induction on size can be derived by replacing $depth$ with $size$.

\paragraph{Structural induction}
Given $P(|s|)$ holds for all $|s| \in S_i$,
  we have $P(|t|)$ for
\begin{alignat*}{2}
  |t| &
  \in && ~\{
    \Succ |s|, ~\Pred |s|, ~\Iszero |s|
    \mid |s| \in S_i
  \} \\
  & &&\cup \{
    \IfThenElse{|s|_1}{|s|_2}{|s|_3}
    \mid |s|_1, |s|_2, |s|_3 \in S_i
  \}
\end{alignat*}
by induction hypothesis.
Together with constant terms, which all satisfy $P$ as they contain no subterms,
  we have $P(|t|)$ for all $|t| \in S_{i + 1}$.
We conclude that $P(|s|)$ holds for all $|s| \in S$ by induction on $i$.
\qed

\Ex{3.5.5}

If, for each derivation $D$, \\
\quad given $P(D')$ holds for all immediate subderivations $D'$ of $D$ \\
\quad we have $P(D)$, \\
then $P(D)$ holds for all $D$.

\Ex{3.5.10}

\begin{center}
  \AxiomC{$|t| \to^* |t|$}
  \DisplayProof
  \proofsep
  \AxiomC{$|t| \to |t|'$}
  \UnaryInfC{$|t| \to^* |t|'$}
  \DisplayProof
  \proofsep
  \AxiomC{$|t| \to^* |t|'$}
  \AxiomC{$|t|' \to^* |t|''$}
  \BinaryInfC{$|t| \to^* |t|''$}
  \DisplayProof
\end{center}

\Ex{3.5.13}

\begin{enumerate}
  \item Theorems 3.5.7, 3.5.8, and 3.5.12 hold.
  \item Theorems 3.5.7, 3.5.8, 3.5.11, and 3.5.12 hold.
        The proof of Theorem 3.5.11 should be changed to not rely on Theorem 3.5.4
          (which does not hold anymore).
\end{enumerate}

\Ex{3.5.14}

We use induction on derivation as is done in Theorem 3.5.4.
Suppose we have $|t| \to |t|'$ and $|t| \to |t|''$.
If |t| is a conditional expression,
  then we repeat the discussion in the proof of Theorem 3.5.4
  to get $|t|' = |t|''$ using the induction hypothesis.
Otherwise, |t| is either a successor, predecessor, or zero test.

If $|t| = \Succ |s|$ for some term |s|,
  the last rule used to derive both $|t| \to |t|'$
  and $|t| \to |t|''$ is \Rule{E-Succ}.
We then have $|t|' = \Succ |s|'$ for some term $|s|'$,
  and the statement $\Succ |s| \to \Succ |s|'$ is derived from
  $|s| \to |s|'$.
Similarly, we have $|t|'' = \Succ |s|''$ for some term $|s|''$,
  and the statement $\Succ |s| \to \Succ |s|''$ is derived from
  $|s| \to |s|''$.
We now have $|s| \to |s|'$ and $|s| \to |s|''$,
  and then we get $|s|' = |s|''$ by induction hypothesis.
It implies $|t|' = \Succ |s|' = \Succ |s|'' = |t|''$.

If $|t| = \Pred |s|$ for some term |s|,
  the last rules used to derive
  $|t| \to |t|'$ and $|t| \to |t|''$ are
  either \Rule{E-PredZero}, \Rule{E-PredSucc}, or \Rule{E-Pred}.
These rules do not \emph{overlap},
  i.e., if $|t| \to |t|'$ is derived from one of the rules,
  then $|t| \to |t|''$ is also derived from the same rule.
To see this,
  we need to check if the left hand side $\Pred |t|_1$ of the statement
  derived by \Rule{E-Pred} does not conflict with the left hand side
  $\Pred \Succ |nv|_1$ of \Rule{E-PredSucc}.
Assume they conflict.
We then, for some $|t|'_1$,
  have $\Pred \Succ |nv|_1 \to \Pred |t|'_1$
  derived by \Rule{E-Pred}.
The premise of this one-step derivation is $\Succ |nv|_1 \to |t|'_1$.
The rule \Rule{E-Succ} is the only rule that may derive this statement,
  with which we have $|nv|_1 \to |t|'_2$ for some $|t|'_2$.
It contradicts with the fact that $|nv|_1$ is a normal form.
Therefore, we have shown that these three rules do not conflict with eath other.
Within these cases,
  \Rule{E-PredZero} and \Rule{E-PredSucc} both have a numeric value
  on the right hand side of the derived statement,
  and thus we have $|t|' = |t|''$.
For \Rule{E-Pred},
  we repeat the same discussion as \Rule{E-Succ} to get
  $|t|' = |t|''$ by induction hypothesis.

If $|t| = \Iszero |s|$ for some term |s|,
  a similar discussion is applied as the previous case of $|t| = \Pred |s|$,
  where the three rules are replaced with
  \Rule{E-IsZeroZero}, \Rule{E-IsZeroSucc}, and \Rule{E-IsZero},
  and we handle boolean values instead of numeric ones in some places. \qed

\Ex{3.5.16}

\begin{itemize}
  \item[(1)]
    \textsc{Proposition}:
    Let |t| be any arithmetic expression.
    If |t| is evaluated to a value,
      then it is evaluated to the same value in the augmented language.
    The term |t| is evaluated to a stuck state
      iff it is evaluated to |wrong| in the augmented language.
  \item[(2)] 
    \Proof:
    Note first that the augmented evaluation rules are deterministic,
      since the added rules do not conflict with existing ones and with each other.
    Since the augmented language accomodates all the evaluation rules that
      the original language have,
      any expression evaluated to a value in the original language
      is evaluated by the same derivation to the same value in the augmented one.
    Assume |t| is evaluated to a stuck state in the original language.
    Then, the term |t| is in an either form of the left hand side of
      the added rules.
    Therefore, it is evaluated to |wrong| in the augmented language.
    Conversely, assume |t| is evaluated to |wrong| in the augmented language.
    Since |t| is an arithmetic expression,
      it is not |wrong| itself,
      and thus is the result of an evaluation by one of the added rules.
    The left hand side of each added rule is a normal form in the original language,
      and thus is a stuck state. \qed
\end{itemize}

\Ex{3.5.17}

First, we show $|t| \Bigstep |v|$ given $|t| \to^* |v|$
  by induction on the number of small steps consisting $|t| \to^* |v|$.
If there are zero steps, i.e., $|t| = |v|$,
  then it holds that $|t| \Bigstep |v|$ by \Rule{B-Value}.
Consider the general case.
By induction hypothesis,
  there exists a term $|t|'$ that satisfies
  $|t| \to |t|'$,
  $|t|' \to^* |v|$,
  and $|t|' \Bigstep |v|$.
Then $|t| \Bigstep |v|$ is shown by examining all the cases for
  the direct derivation of $|t| \to |t|'$.
For example, if it is derived by \Rule{E-IfTrue},
  |t| is written as $|t| = \IfThenElse{|true|}{|t|'}{|t|''}$.
We have $|true| \Bigstep |true|$ by \Rule{B-Value}
  and $|t|' \Bigstep |v|$ by the hypothesis.
By applying \Rule{B-IfTrue} to them,
  we obtain $\IfThenElse{|true|}{|t|'}{|t|''} \Bigstep |v|$.
Another example: if it is derived by \Rule{E-If},
  |t| and $|t|'$ are written as
  $|t| = \IfThenElse{|t|_1}{|t|_2}{|t|_3}$ and
  $|t|' = \IfThenElse{|t|'_1}{|t|'_2}{|t|'_3}$, respectively.
We also have $|t|_1 \to |t|'_1$.
Since $|t|' \to^* |v|$,
  it holds that $|t|'_1 \to^* |v|_1$ with $|v|_1 \in \{|true|, |false|\}$.
We thus obtain $|t|_1 \to^* |v|_1$.
Suppose $|v|_1 = |true|$.
Then, in the same way, we obtain $|t|_2 \to^* |v|$.
By induction hypothesis,
  we have $|t|_1 \Bigstep |true|$ and $|t|_2 \Bigstep |v|$.
By applying \Rule{B-IfTrue},
  we get $\IfThenElse{|t|_1}{|t|_2}{|t|_3} \Bigstep |v|$.
Almost same discussions apply for the case of $|v|_1 = |false|$.
The other cases also follow in a similar manner.

Next, we show $|t| \to^* |v|$ given $|t| \Bigstep |v|$
  by induction on derivation of $|t| \Bigstep |v|$.
When $|t| = |v|$, it obviously holds that $|v| \to^* |v|$.
Induction step is made by examining all the evaluation rules except for \Rule{B-Value}.
For example, if the last step is \Rule{B-IfTrue},
  we have $|t| = \IfThenElse{|t|_1}{|t|_2}{|t|_3}$
  with $|t|_1 \Bigstep |true|$ and $|t|_2 \Bigstep |v|$.
By induction hypothesis,
  we have $|t|_1 \to^* |true|$ and $|t|_2 \to^* |v|$.
By applying \Rule{E-If} multiple times with premises given by
  individual small steps consisting $|t|_1 \to^* |true|$,
  we obtain
  $
    \IfThenElse{|t|_1}{|t|_2}{|t|_3} \to^*
    \IfThenElse{|true|}{|t|_2}{|t|_3}
  $.
Next, we apply \Rule{E-IfTrue} to the right hand side to obtain
  $\IfThenElse{|t|_1}{|t|_2}{|t|_3} \to^* |t|_2$.
Combining it with $|t|_2 \to^* |v|$,
  we get $\IfThenElse{|t|_1}{|t|_2}{|t|_3} \to^* |v|$.
Similar discussions are applied to the other cases. \qed

\Ex{3.5.18}

The evaluation rules involving $\code{if}$ expression is modified as follows.
\begin{center}
  \AxiomC{$\IfThenElse{|true|}{|v|_1}{|v|_2} \to |v|_1$} \DisplayProof
  \proofsep
  \AxiomC{$\IfThenElse{|false|}{|v|_1}{|v|_2} \to |v|_2$} \DisplayProof
  \proofbreak
  \AxiomC{$|t|_2 \to |t|'_2$}
  \UnaryInfC{$\IfThenElse{|t|_1}{|t|_2}{|t|_3} \to
              \IfThenElse{|t|_1}{|t|'_2}{|t|_3}$} \DisplayProof
  \proofbreak
  \AxiomC{$|t|_2 \to |t|'_2$}
  \UnaryInfC{$\IfThenElse{|t|_1}{|v|}{|t|_2} \to
              \IfThenElse{|t|_1}{|v|}{|t|'_2}$} \DisplayProof
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 4.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An ML Implementation of Arithmetic Expressions}

Rust implementation is put at \code{src/bin/arith.rs}.

\Ex{4.2.1}
Omitted since I cannot talk about a good programming style in ML.

\Ex{4.2.2}
Omitted.
It can be implemented by fully evaluating arguments of each expression recursively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 5.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Untyped Lambda-Calculus}

\Ex{5.2.1}
\begin{Code}
  or  = $\lmd b \lmd c$ b tru c;
  not = $\lmd b$ b fls tru;
\end{Code}

\Ex{5.2.2}
\begin{Code}
  scc = $\lmd n \lmd s \lmd z$ n s (s z);
\end{Code}

\Ex{5.2.3}
\begin{Code}
  times$'$ = $\lmd m \lmd n \lmd s$ m (n s);
\end{Code}
For example, $3 \times 2$ is evaluated as follows.
\begin{Code}
     times$'$ c$_3$ c$_2$ s z
  $=$   ($\lmd m \lmd n \Lmd s' \Lmd z'$ m (n s$'$) z$'$) c$_3$ c$_2$ s z
  $\to$ ($\lmd n \Lmd s' \Lmd z'$ c$_3$ (n s$'$) z$'$) c$_2$ s z
  $\to$ ($\Lmd s' \Lmd z'$ c$_3$ (c$_2$ s$'$) z$'$) s z
  $\to$ ($\Lmd z'$ c$_3$ (c$_2$ s) z$'$) z
  $\to$ c$_3$ (c$_2$ s) z
  $=$   c$_3$ (($\Lmd s' \Lmd z'$ s$'$ (s$'$ z$'$)) s) z
  $\to$ c$_3$ ($\Lmd z'$ s (s z$'$)) z
  $=$   ($\Lmd s' \Lmd z'$ s$'$ (s$'$ (s$'$ z$'$))) ($\Lmd z'$ s (s z$'$)) z
  $\to$ ($\Lmd z'$ ($\Lmd z{''}$ s (s z$''$)) (($\Lmd z{''}$ s (s z$''$)) (($\Lmd z{''}$ s (s z$''$)) z$'$))) z
  $\to$ ($\Lmd z'$ s (s z$'$)) (($\Lmd z'$ s (s z$'$)) (($\Lmd z'$ s (s z$'$)) z))
  $\to$ ($\Lmd z'$ s (s z$'$)) (($\Lmd z'$ s (s z$'$)) (s (s z)))
  $\to$ ($\Lmd z'$ s (s z$'$)) (s (s (s (s z))))
  $\to$ s (s (s (s (s (s z)))))$.$
\end{Code}

\Ex{5.2.4}

There are at least two ways to define a power function.
\begin{Code}
  pow = $\lmd m \lmd n$ m (times n) c$_1$;
  pow$'$ = $\lmd m \lmd n$ m n;
\end{Code}
The first one is analogous to the definition of \code{times}.
The second one is simpler but trickier.
Here, an application of $\code{pow}'$ is evaluated as
\begin{align*}
  |pow|'~|c|_m~|c|_n~|s|~|z|
  \to |c|_m~|c|_n~|s|~|z|
  \to \underbrace{|c|_n~(|c|_n~(\cdots~(|c|_n}_{m}~|s|)\cdots))~|z|.
\end{align*}
Then, applying $|c|_n$ once multiplies the number of occurences of |s| by $n$.
Since it happens $m$ times, it results in $n^m$ occurences of |s| in total.

For example, $2^3$ is evaluated as follows.
\begin{Code}
     pow$'$ c$_3$ c$_2$ s z
  $=$   ($\lmd m \lmd n$ m n) c$_3$ c$_2$ s z
  $\to$ ($\lmd n$ c$_3$ n) c$_2$ s z
  $\to$ c$_3$ c$_2$ s z
  $=$   ($\Lmd s' \Lmd z'$ s$'$ (s$'$ (s$'$ z$'$))) c$_2$ s z
  $\to$ ($\Lmd z'$ c$_2$ (c$_2$ (c$_2$ z$'$))) s z
  $\to$ c$_2$ (c$_2$ (c$_2$ s)) z
  $=$   c$_2$ (c$_2$ (($\Lmd s' \Lmd z'$ s$'$ (s$'$ z$'$)) s)) z
  $\to$ c$_2$ (c$_2$ ($\Lmd z'$ s (s z$'$))) z
  $=$   c$_2$ (($\Lmd s' \Lmd z'$ s$'$ (s$'$ z$'$)) ($\Lmd z'$ s (s z$'$))) z
  $\to$ c$_2$ ($\Lmd z'$ ($\Lmd z{''}$ s (s z$''$)) (($\Lmd z{''}$ s (s z$''$)) z$'$)) z
  $=$   ($\Lmd s' \Lmd z'$ s$'$ (s$'$ z$'$)) ($\Lmd z'$ ($\Lmd z{''}$ s (s z$''$)) (($\Lmd z{''}$ s (s z$''$)) z$'$)) z
  $\to$ ($\Lmd z'$ ($\Lmd z{''}$ ($\Lmd z{'''}$ s (s z$'''$)) (($\Lmd z{'''}$ s (s z$'''$)) z$''$))
           (($\Lmd z{''}$ ($\Lmd z{'''}$ s (s z$'''$)) (($\Lmd z{'''}$ s (s z$'''$)) z$''$)) z$'$)
     ) z
  $\to$ ($\Lmd z'$ ($\Lmd z{''}$ s (s z$''$)) (($\Lmd z{''}$ s (s z$''$)) z$'$))
        (($\Lmd z'$ ($\Lmd z{''}$ s (s z$''$)) (($\Lmd z{''}$ s (s z$''$)) z$'$)) z)
  $\to$ ($\Lmd z'$ ($\Lmd z{''}$ s (s z$''$)) (($\Lmd z{''}$ s (s z$''$)) z$'$))
        (($\Lmd z'$ s (s z$'$)) (($\Lmd z'$ s (s z$'$)) z))
  $\to$ ($\Lmd z'$ ($\Lmd z{''}$ s (s z$''$)) (($\Lmd z{''}$ s (s z$''$)) z$'$))
        (($\Lmd z'$ s (s z$'$)) (s (s z)))
  $\to$ ($\Lmd z'$ ($\Lmd z{''}$ s (s z$''$)) (($\Lmd z{''}$ s (s z$''$)) z$'$)) (s (s (s (s z))))
  $\to$ ($\Lmd z'$ s (s z$'$)) (($\Lmd z'$ s (s z$'$)) (s (s (s (s z)))))
  $\to$ ($\Lmd z'$ s (s z$'$)) (s (s (s (s (s (s z))))))
  $\to$ (s (s (s (s (s (s (s (s z))))))))
\end{Code}

\Ex{5.2.5}
\begin{Code}
  subtract = $\lmd m \lmd n$ n prd m;
\end{Code}
It reads "apply |prd| for |n| times to |m|".

\Ex{5.2.6}
Full evaluation of |prd| |c|$_n$ involves applications of |ss|
  $n$ times starting from |pair c|$_0$~| c|$_0$ and selecting |fst|.
The evaluation thus completes in $O(n)$ steps.

\Ex{5.2.7}
\begin{Code}
  equal = $\lmd m \lmd n$ and (iszro (m prd n)) (iszro (n prd m));
\end{Code}

\Ex{5.2.8}
\begin{Code}
  nil   = $\lmd c \lmd n$ n;
  cons  = $\lmd h \lmd t \lmd c \lmd n$ c h (t c n);
  isnil = $\lmd t$ t ($\lmd x \lmd y$ fls) tru;
  head  = $\lmd t$ t ($\lmd x \lmd y$ x) nil;
\end{Code}
Here, we use |nil| for the default value of |head| when the argument is
  |nil|.

A |tail| function can be defined by copying a list into another list,
  simultaneously bookkeeping the list in the previous step using a pair.
\begin{Code}
  dcons = $\lmd h \lmd p$ pair (snd p) (cons h (snd p));
  tail  = $\lmd t$ fst (t dcons (pair nil nil));
\end{Code}

\Ex{5.2.9}
In the main text,
  |if| is used instead of |test| to avoid evaluating unused branches,
  which otherwise makes the evaluation diverge.
To use |test|,
  we need to prevent the unused branches from being evaluated
  by hiding the branches behind lambda abstractions and evaluating it later.
A dummy value |c|$_0$ is used to evaluate the lazy function.
\begin{Code}
  g$'$ = $\lmd{fct} \lmd n$
      test (iszro n) ($\lmd x$ c$_1$) ($\lmd x$ times n (fct (prd n) c$_0$)) c$_0$;
  factorial$'$ = fix g$'$;
\end{Code}

\Ex{5.2.10}
\begin{Code}
  churchnat = fix ($\lmd f \lmd n$
      if iszero n then c$_0$ else scc (f (pred n)))
\end{Code}

\Ex{5.2.11}
\begin{Code}
  sum = fix ($\lmd f \lmd l$ test (isnil l)
                          ($\lmd x$ c$_0$)
                          ($\lmd x$ plus (head l) (f (tail l) c$_0$)))
\end{Code}

\Ex{5.3.3}
We prove it by induction on term size.
Iff |t| is a varaible, it holds that $size(|t|) = 1 = \card{FV(|t|)}$.
Suppose |t| is a non-variable term.
There are two cases.
\begin{enumerate}
  \item If $|t| = \lmd x |t|_1$, it holds that
        $\card{FV(|t|)} \le \card{FV(|t|_1)}$ and
        $size(|t|) = size(|t|_1) + 2$.
        By induction hypothesis, we have $\card{FV(|t|_1)} \le size(|t|_1)$.
        Combining them gives
        $\card{FV(|t|)} \le \card{FV(|t|_1)} \le size(|t|_1) \le size(|t|)$.
  \item Otherwise, |t| is written as $|t| = |t|_1 ~ |t|_2$.
        It holds that $\card{FV(|t|)} \le \card{FV(|t|_1)} + \card{FV(|t|_2)}$
        and $size(|t|) = size(|t|_1) + size(|t|_2) + 1$.
        By induction hypothesis, we have
        $\card{FV(|t|_1)} \le size(|t|_1)$ and $\card{FV(|t|_2)} \le size(|t|_2)$.
        Combining them gives
        $\card{FV(|t|)} \le size(|t|_1) + size(|t|_2) < size(|t|)$.
\end{enumerate}
\qed

\Ex{5.3.6}

\paragraph{Full beta-reduction}
Syntax is not changed (indeed, the category of values is not used).
Evaluation rules are as follows.
\begin{center}
  \AxiomC{$|t|_1 \to |t|'_1$}
  \UnaryInfC{$|t|_1 ~ |t|_2 \to |t|'_1 ~ |t|_2$}
  \DisplayProof \proofsep
  \AxiomC{$|t|_2 \to |t|'_2$}
  \UnaryInfC{$|t|_1 ~ |t|_2 \to |t|_1 ~ |t|'_2$}
  \DisplayProof \proofsep
  \AxiomC{$|t| \to |t|'$}
  \UnaryInfC{$\lmd x ~|t| \to \lmd x ~|t|'$}
  \DisplayProof \proofbreak
  \AxiomC{$\CParen{\lmd x ~|t|_1} ~|t|_2 \to \subst{|x| \mapsto |t|_2} |t|_1$}
  \DisplayProof
\end{center}

\paragraph{Normal order}
Syntax is changed as follows.
\begin{Code}
  $\dots$
  nf $::=$
        $\lmd x$ nf
        nanf
  nanf $::=$
        x
        nanf nf
  na $::=$
        x
        t t
\end{Code}
Evaluation rules are as follows.
\begin{center}
  \AxiomC{$|na|_1 \to |na|'_1$}
  \UnaryInfC{$|na|_1 ~|t|_2 \to |na|'_1 ~|t|_2$}
  \DisplayProof \proofsep
  \AxiomC{$|t|_2 \to |t|'_2$}
  \UnaryInfC{$|nanf|_1 ~|t|_2 \to |nanf|_1 ~|t|'_2$}
  \DisplayProof \proofsep
  \AxiomC{$|t| \to |t|'$}
  \UnaryInfC{$\lmd x ~|t| \to \lmd x ~|t|'$}
  \DisplayProof \proofbreak
  \AxiomC{$|(| \lmd x ~|t|_1 |)| ~|t|_2 \to \subst{|x| \mapsto |t|_2} |t|_1$}
  \DisplayProof
\end{center}

\paragraph{Lazy evaluation}
Syntax is not changed. Evaluation rules are as follows.
\begin{center}
  \AxiomC{$|t|_1 \to |t|'_1$}
  \UnaryInfC{$|t|_1 ~ |t|_2 \to |t|'_1 ~ |t|_2$}
  \DisplayProof \proofbreak
  \AxiomC{$|(| \lmd x ~|t|_1 |)| ~|t|_2 \to \subst{|x| \mapsto |t|_2} |t|_1$}
  \DisplayProof
\end{center}

\Ex{5.3.7}
Add the following syntactic categories to \LambdaNB.
\begin{Code}
  badnat $::=$
        wrong
        true
        false
        $\lmd x$ t

  badbool $::=$
        wrong
        nv
        $\lmd x$ t

  badabs $::=$
        wrong
        true
        false
        nv
\end{Code}
Augment the evaluation relation with the following rules.
\begin{center}
  \AxiomC{$|if badbool then| ~|t|_1 ~|else| ~|t|_2 \to |wrong|$}
  \DisplayProof \proofbreak
  \AxiomC{$|succ badnat| \to |wrong|$}
  \DisplayProof \proofbreak
  \AxiomC{$|pred badnat| \to |wrong|$}
  \DisplayProof \proofbreak
  \AxiomC{$|iszero badnat| \to |wrong|$}
  \DisplayProof \proofbreak
  \AxiomC{$|badabs| ~|t| \to |wrong|$}
  \DisplayProof
\end{center}

\Ex{5.3.8}
\begin{center}
  \AxiomC{$\lmd x ~|t| \to \lmd x ~|t|$}
  \DisplayProof \proofbreak
  \AxiomC{$|t|_1 \Bigstep \lmd x ~|t|'_1$}
  \AxiomC{$|t|_2 \Bigstep |v|_2$}
  \AxiomC{$\subst{|x| \mapsto |v|_2} |t|'_1 \Bigstep |v|_3$}
  \TrinaryInfC{$|t|_1 ~|t|_2 \Bigstep |v|_3$}
  \DisplayProof
\end{center}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 6.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Nameless Representation of Terms}

\Ex{6.1.1}
\begin{Code}
  c$_0$    = $\lmd{} \lmd{}$ 0;
  c$_2$    = $\lmd{} \lmd{}$ 1 (1 0);
  plus = $\lmd{} \lmd{} \lmd{} \lmd{}$ 3 1 (2 0 1);
  fix  = $\lmd{}$ ($\lmd{}$ 1 ($\lmd{}$ (1 1) 0)) ($\lmd{}$ 1 ($\lmd{}$ (1 1) 0));
  foo  = ($\lmd{}$ ($\lmd{}$ 0)) ($\lmd{}$ 0);
\end{Code}

\Ex{6.1.4}
Define a family of sets $S_{ni}, ~n, i \in \N$ inductively as follows.
\begin{align*}
  S_{n,0} &= \{ 0, \dots, n - 1 \}, ~n \in \N, \\
  S_{ni} &= S_{n, i - 1}
         \cup \{ \lmd{} |t| \mid |t| \in S_{n + 1, i - 1} \}
         \cup \{ |(| |t|_1 ~|t|_2 |)| \mid |t|_1, |t|_2 \in S_{n, i - 1} \}, \\
         & \hspace{20em} n \in \N, i \in \N \setminus \{ 0 \}
\end{align*}
Then, define a family of sets
  $\mathcal S = \{\mathcal S_0, \mathcal S_1, \mathcal S_2, \dots \}$ by
  $\mathcal S_n = \bigcup_i S_{ni}, ~n \in \N$.
Each set $\mathcal S_n$ in this family coincides with $\mathcal T_n$.

\Proof:
We first prove $S_{ni} \subseteq \mathcal T_n$ for all $n$ by induction on $i$.
By definition, it holds $S_{n, 0} \subseteq \mathcal T_n$.
For $i>0$, suppose $|t| \in S_{ni}$.
There are three cases to consider.
\begin{itemize}
  \item If $|t| \in S_{n, i - 1}$, by induction hypothesis,
      we have $|t| \in \mathcal T_n$.
  \item If $|t| = \lmd{} |s|$ for some $|s| \in S_{n + 1, i - 1}$,
      by induction hypothesis, we have $|s| \in \mathcal T_{n + 1}$.
    Following \textsc{Definition 6.1.2.2},
      we obtain $|t| = \in \mathcal T_{n}$.
  \item Otherwise, we can write $|t| = |(| |s|_1 ~ |s|_2 |)|$
      for some $|s|_1, |s|_2 \in S_{n, i - 1}$.
    By induction hypothesis, we have $|s|_1, |s|_2 \in \mathcal T_n$.
    Following \textsc{Definition 6.1.2.3},
      we obtain $|t| \in \mathcal T_n$.
\end{itemize}
Therefore, $S_{ni} \subseteq \mathcal T_n$ holds for all $n, i$.
We thus obtain $\mathcal S_n = \bigcup_i S_{ni} \subseteq \mathcal T_n$.

Next, we prove $\mathcal T_n \subseteq \mathcal S_n$ for all $n$.
To prove it, we show that
  the three conditions of \textsc{Definition 6.1.2} hold
  when replacing $\mathcal T_n$ with $\mathcal S_n$.
Then, by the minimality of $\mathcal T_n$, we get $\mathcal T_n \subseteq \mathcal S_n$.
\begin{enumerate}
  \item By definition, it holds that $|k| \in S_{n,0} \subseteq \mathcal S_n$
      whenever $0 \le |k| < n$.
  \item If $|t| \in \mathcal S_n$, there exists $i$ such that $|t| \in S_{ni}$.
    By definition, it holds $\lmd{} |t| \in S_{n - 1, i + 1} \subseteq \mathcal S_{n - 1}$.
  \item If $|t|_1, |t|_2 \in \mathcal S_n$,
      there exist $i_1, i_2$ such that $|t|_1 \in S_{ni_1}$ and $|t|_2 \in S_{ni_2}$.
    Let $i = \max\{ i_1, i_2 \}$,
      then we have $|t|_1, |t|_2 \in S_{ni}$.
    By definition, we have $|(| |t|_1 ~ |t|_2 |)| \in S_{n, i + 1} \subseteq \mathcal S_n$.
\end{enumerate}
\qed

\Ex{6.1.5}
\begin{enumerate}
  \item
    \begin{alignat*}{2}
      &removenames_\Gamma(|x|) &&= (\text{index of the rightmost |x| in } \Gamma), \\
      &removenames_\Gamma(\lmd x |s|) &&= \lmd{} removenames_{\Gamma, |x|}(|s|), \\
      &removenames_\Gamma(|t|_1 ~ |t|_2)
        &&= removenames_\Gamma(|t|_1) ~ removenames_\Gamma(|t|_2).
    \end{alignat*}
  \item Let $newname(\Gamma)$ be
      the first variable name in $\mathcal V \setminus dom(\Gamma)$.
    \begin{alignat*}{3}
      &restorenames_\Gamma(|k|)
        &&= |x|_{|k|}
        && \where \Gamma = |x|_n, \dots, |x|_0, \\
      &restorenames_\Gamma(\lmd{} |s|)
        &&= \lmd x restorenames_{\Gamma, |x|}(|s|)
        && \where |x| = newname(\Gamma), \\
      &restorenames_\Gamma(|t|_1 ~ |t|_2)
        &&= restorenames_\Gamma(|t|_1) ~ restorenames_\Gamma(|t|_2). &&
    \end{alignat*}
\end{enumerate}

\Ex{6.2.2}
\begin{enumerate}
  \item $\dshift^2(\lmd{} \lmd{} ~|1 (0 2)|) = \lmd{} \lmd{} ~|1 (0 4)|$.
  \item
    $\dshift^2(\lmd{} ~|0 1 (| \lmd{} ~|0 1 2)|)
     = \lmd{} ~|0 3 (| \lmd{} ~|0 1 4)|$.
\end{enumerate}

\Ex{6.2.3}
We show it by structural induction.

If |t| is a variable, then $\dshift_c^d(|t|)$ is a $(n + d)$-term by definition.

If |t| is written as $|t| = \lmd{} |t|_1$, 
  $|t|_1$ is an $(n + 1)$-term.
By induction hypothesis, $\dshift_{c+1}^d(|t|_1)$ is an $(n + d + 1)$-term.
Therefore,
  $\dshift_c^d(\lmd{} |t|_1) = \lmd{} \dshift_{c+1}^d(|t|_1)$ is an $(n + d)$-term.

If |t| is written as $|t| = |t|_1 ~ |t|_2$,
  $|t|_1$ and $|t|_2$ are both $n$-terms.
By induction hypothesis,
  $\dshift_c^d(|t|_1)$ and $\dshift_c^d(|t|_2)$ re $(n + d)$-terms.
Therefore,
  $\dshift_c^d(|t|_1 ~ |t|_2) = \dshift_c^d(|t|_1) ~ \dshift_c^d(|t|_2)$ is an
  $(n + d)$-term. \qed

\Ex{6.2.5}
\begin{enumerate}
  \item \begin{align*}
      \subst{|0| \mapsto |1|} |(0 (| \lmd{} \lmd{} |2))|
      &= |1 (| \subst{|0| \mapsto |1|} \lmd{} \lmd{} |2)| \\
      &= |1 (| \lmd{} \lmd{} \subst{|2| \mapsto |3|} |2)| \\
      &= |1 (| \lmd{} \lmd{} |3)|.
  \end{align*}
  \item \begin{align*}
      \subst{|0| \mapsto |1 (| \lmd{} |2)|} |(0 (| \lmd{} |1))|
      &= |1 (| \lmd{} |2) (| \subst{|0| \mapsto |1 (| \lmd{} |2)|} \lmd{} |1)| \\
      &= |1 (| \lmd{} |2) (| \lmd{} \subst{|1| \mapsto |2 (| \lmd{} |3)|} |1)| \\
      &= |1 (| \lmd{} |2) (| \lmd{} |2 (| \lmd{} |3))|.
  \end{align*}
  \item \begin{align*}
      \subst{|0| \mapsto |1|} |(| \lmd{} |0 2)|
      &= \lmd{} \subst{|1| \mapsto |2|} |0 2| \\
      &= \lmd{} |0 2|.
  \end{align*}
  \item \begin{align*}
      \subst{|0| \mapsto |1|} |(| \lmd{} |1 0)|
      &= \lmd{} \subst{|1| \mapsto |2|} |1 0| \\
      &= \lmd{} |2 0|.
  \end{align*}
\end{enumerate}

\Ex{6.2.6}
We show it by structural induction on |t|.

If |t| is a variable,
  $\subst{|j| \mapsto |s|} |t|$ is |s| if $|j| = |t|$
  or |t| otherwise.
In either case, it is an $n$-term.

If $|t| = \lmd{} |t|_1$,
  we have $\subst{|j| \mapsto |s|} |t|
           = \lmd{} \subst{|j| + 1 \mapsto \dshift^1(|s|)} |t|_1$.
Since both $|t|_1$ and $\dshift^1(|s|)$ are $(n + 1)$-terms and $|j| + 1 \le n + 1$,
  by induction hypothesis,
  $\subst{|j| + 1 \mapsto \dshift^1(|s|)} |t|_1$ is an $(n + 1)$-term.
Therefore, $\lmd{} \subst{|j| + 1 \mapsto \dshift^1(|s|)} |t|_1$ is an $n$-term.

Otherwise, we can write $|t| = |t|_1 ~ |t|_2$.
In this case, both $|t|_1$ and $|t|_2$ are $n$-terms,
  and $\subst{|j| \mapsto |s|} |t|
       = |(| \subst{|j| \mapsto |s|} |t|_1 |) (| \subst{|j| \mapsto |s|} |t|_2 |)|$.
By induction hypothesis,
  both terms in the right hand side are $n$-terms,
  and thus the right hand side as a whole is also an $n$-term.
\qed

\Ex{6.2.7}
Omitted.

\Ex{6.2.8}
\Theorem:
Let $\Gamma$ be any naming context.
We overload the notation $removenames_\Gamma(|x|)$ for a variable |x| to
  denote the index of |x| in $\Gamma$ counting from the right.
Then, $removenames_\Gamma$ commutes with substitution;
  i.e., for any ordinary terms |t|, |s|, and variable |x|,
  \begin{align}
    &\phantomrel=
      removenames_\Gamma(\subst{|x| \mapsto |s|} |t|) \notag \\
    &= \subst{removenames_\Gamma(|x|) \mapsto removenames_\Gamma(|s|)}
      (removenames_\Gamma(|t|)).
      \label{eq:6.2.8}
  \end{align}

\Proof:
Abbreviate $removenames_\Gamma$ by $rem_\Gamma$.
We prove it by structural induction on |t|.

If $|t| = |x|$, the both sides of Eq. \ref{eq:6.2.8} are $rem_\Gamma(|s|)$.

If $|t| = |y| \neq |x|$,
  we also have $rem_\Gamma(|x|) \neq rem_\Gamma(|y|)$,
  so the both sides of Eq. \ref{eq:6.2.8} are $rem_\Gamma(|y|)$.

If $|t| = \lmd y |t|_1$ where $|y| \neq |x|$ and $|y| \notin FV(|s|)$,
  we have
\[
  rem_\Gamma(\subst{|x| \mapsto |s|} |(| \lmd y |t|_1 |)|)
   = rem_\Gamma(\lmd y \subst{|x| \mapsto |s|} |t|_1) \\
   = \lmd{} rem_{\Gamma, |y|}(\subst{|x| \mapsto |s|} |t|_1).
\]
By induction hypothesis,
  the rightmost side is
\[
  \lmd{} \subst{rem_{\Gamma, |y|}(|x|)
                \mapsto rem_{\Gamma, |y|}(|s|)}
         rem_{\Gamma, |y|}(|t|_1).
\]
Since $|y| \notin FV(|s|) \cup \{|x|\}$,
  $rem_{\Gamma, |y|}(|x|) = rem_\Gamma(|x|) + 1$ and
  $rem_{\Gamma, |y|}(|s|) = \dshift^1 rem_\Gamma(|s|)$.
Therefore, the above term is
\[
  \subst{rem_\Gamma(|x|) \mapsto rem_\Gamma(|s|)}
    \lmd{} rem_{\Gamma, |y|}(|t|_1)
  = \subst{rem_\Gamma(|x|) \mapsto rem_\Gamma(|s|)}
     rem_\Gamma(\lmd y |t|_1).
\]
This is equal to the right hand side of Eq. \ref{eq:6.2.8}.

Otherwise, $|t| = |t|_1 ~ |t|_2$. We have
\begin{align*}
  rem_\Gamma(\subst{|x| \mapsto |s|} |(| |t|_1 ~ |t|_2 |)|)
  &= rem_\Gamma(|(| \subst{|x| \mapsto |s|} |t|_1 |)| ~
                        |(| \subst{|x| \mapsto |s|} |t|_2 |)|) \\
  &= rem_\Gamma(\subst{|x| \mapsto |s|} |t|_1) ~
     rem_\Gamma(\subst{|x| \mapsto |s|} |t|_2).
\end{align*}
By induction hypothesis, we have
\begin{align*}
  &\phantomrel=
    rem_\Gamma(\subst{|x| \mapsto |s|} |t|_1) ~
    rem_\Gamma(\subst{|x| \mapsto |s|} |t|_2) \\
  &= |(|
       \subst{rem_\Gamma(|x|) \mapsto rem_\Gamma(|s|)}
       rem_\Gamma(|t|_1)
     |)| ~
     |(|
       \subst{rem_\Gamma(|x|) \mapsto rem_\Gamma(|s|)}
       rem_\Gamma(|t|_2)
     |)| \\
  &= \subst{rem_\Gamma(|x|) \mapsto rem_\Gamma(|s|)}
     |(| rem_\Gamma(|t|_1) ~ rem_\Gamma(|t|_2) |)| \\
  &= \subst{rem_\Gamma(|x|) \mapsto rem_\Gamma(|s|)}
      rem_\Gamma(|t|_1 ~ |t|_2).
\end{align*}
\qed

\Ex{6.3.1}
In the argument of $\dshift^{-1}$ in \Rule{E-AppAbs},
  the variable |0| is substituted away with $\dshift^1(|v|_2)$,
  which does not refer |0| due to the shift operator.
Therefore, the negative shift does not cause any ill-formed terms.

\Ex{6.3.2}
\textsc{Todo}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 7.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An ML Implementation of the Lambda Calculus}
Rust implementation of |untyped| is put at |src/bin/untyped.rs|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 8.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Typed Arithmetic Expressions}

\Ex{8.2.3}
It immediately follows from 3, 5, 6, and 7 of \textsc{Lemma 8.2.2}.

\Ex{8.3.4}
We proceed by case analysis on the final rule in the evaluation derivation.

\Case\textsc{E-IfTrue}:
We have $|t| = |if true then t|_1~|else t|_2 \to |t|_1$.
By the inversion lemma, we have $|t|_1~|: T|$.
\textsc{E-IfFalse} case is similar.

\Case\textsc{E-If}:
We have $|t| = |if t|_1~|then t|_2~|else t|_3$
  and $|t|' = |if t|'_1~|then t|_2~|else t|_3$
  where $|t|_1 \to |t|'_1$.
Since |t : T|,
  we have $|t|_1~|: Bool|$, $|t|_2~|: T|$, and $|t|_3~|: T|$ by the inversion lemma.
By induction hypothesis, it holds that $|t|'_1~|: Bool|$.
We thus conclude $|t|'~|: T|$.

\Case\textsc{E-Succ}:
We have $|t| = |succ t|_1$ and $|t|' = |succ t|'_1$
  where $|t|_1 \to |t|'_1$.
It holds that $|T| = |Nat|$ and, by the inversion lemma, $|t|_1~|: Nat|$.
We can derive $|t|'_1~|: Nat|$ by induction hypothesis.
Therefore, we conclude $|t|'~|: Nat|$.
We can apply similar discussions to \Rule{E-Pred} and \Rule{E-IsZero}.

\Case\textsc{E-PredZero}:
It is obvious that |pred 0 : Nat| and |0 : Nat|.
The other remaining cases immediately follow from the definition in the same way.
\qed

\Ex{8.3.5}
Simply removing \Rule{E-PredZero} breaks the progress property
  because, by |0 : Nat| and \Rule{T-Pred}, we have |pred 0 : Nat|,
  which could not be evaluated anymore.

\Ex{8.3.6}
This property does not hold.
For example, let $|t| = |if true then 0 else true|$,
  then $|t| \to |0|$ and |0 : Nat|,
  while |t| is ill-typed.

\Ex{8.3.7}
\begin{itemize}
  \item If |t| is a well typed term, then |t| is evaluated to a value |v|, i.e.,
        $|t| \Bigstep |v|$.
  \item If |t : T| and $|t| \Bigstep |v|$, then |v : T|.
\end{itemize}

\Ex{8.3.8}
Every term, either typed or untyped, is evaluated to some value,
  so the progress property trivially holds.
The preservation property also holds because |wrong| has no type
  and any typed term is not evaluated to a stuck state with the original rules,
  which indicates that such a term is not evaluated to |wrong| with the augmented
  ones.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 9.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simply Typed Lambda-Calculus}

\Ex{9.2.1}
The only type constructor of the pure simply typed lambda-calculus with no base types
  is $\to$,
  which requires two types as the arguments.
Therefore, there is no finite sequence of symbols that conform to the language of
  types,
  which means we cannot write any abstraction term with an argument type annotation.

\Ex{9.2.2}
1. Let $b = |f:Bool| \to |Bool|$ and $\Gamma = b$ be the typing context
     with only one binding $b$.
\begin{center} \scriptsize
  \AxiomC{$b \in \Gamma$}
  \RuleLabel{T-Var}
  \UnaryInfC{$\Ctx{\Gamma}{b}$}
  \AxiomC{} \RuleLabel{T-False} \UnaryInfC{$\CtxTyRel{\Gamma}{|false|}{|Bool|}$}
  \AxiomC{} \RuleLabel{T-True} \UnaryInfC{$\CtxTyRel{\Gamma}{|true|}{|Bool|}$}
  \AxiomC{} \RuleLabel{T-False} \UnaryInfC{$\CtxTyRel{\Gamma}{|false|}{|Bool|}$}
  \RuleLabel{T-If}
  \TrinaryInfC{$\CtxTyRel{\Gamma}{|if false then true else false|}{|Bool|}$}
  \RuleLabel{T-App}
  \BinaryInfC{$\CtxTyRel{\Gamma}{|f (if false then true else false)|}{|Bool|}$}
  \DisplayProof
\end{center}

2. Let $b = |f:Bool| \to |Bool|$ and $\Gamma = (b, |x:Bool|)$.
\begin{center} \small
  \AxiomC{$b \in \Gamma$}
  \RuleLabel{T-Var}
  \UnaryInfC{$\Ctx{\Gamma}{b}$}
  \AxiomC{$|x:Bool| \in \Gamma$}
    \RuleLabel{T-Var} \UnaryInfC{$\CtxTyRel{\Gamma}{|x|}{|Bool|}$}
  \AxiomC{} \RuleLabel{T-False} \UnaryInfC{$\CtxTyRel{\Gamma}{|false|}{|Bool|}$}
  \AxiomC{$|x:Bool| \in \Gamma$}
    \RuleLabel{T-Var} \UnaryInfC{$\CtxTyRel{\Gamma}{|x|}{|Bool|}$}
  \RuleLabel{T-If}
  \TrinaryInfC{
    $\CtxTyRel{\Gamma}{|if x then false else x|}{|Bool|}$
  }
  \RuleLabel{T-App}
  \BinaryInfC{
    $\CtxTyRel{\Gamma}{|f (if x then false else x)|}{|Bool| \to |Bool|}$
  }
  \RuleLabel{T-Abs}
  \UnaryInfC{
    $\CtxTyRel{b}{\lmd{x:Bool} |f (if x then false else x)|}{|Bool| \to |Bool|}$
  }
  \DisplayProof
\end{center}

\Ex{9.2.3}
An example is $|f:Bool| \to |Bool| \to |Bool|, |x:Bool|, |y:Bool|$.
Any such context is written as $|f:T|_1 \to |T|_2 \to |Bool|, |x:T|_1, |y:T|_2$
  where $|T|_1$ and $|T|_2$ are arbitrary types.

\Ex{9.3.2}
\textbf{No}.
\Proof:
Assume, for contradiction, that there exists a context $\Gamma$ and a type |T|
  such that $\CtxTyRel{\Gamma}{|x x|}{|T|}$.
By the inversion lemma,
  there is a type |S| that satisfies
  $\CtxTyRel{\Gamma}{|x|}{|S| \to |T|}$ and $\CtxTyRel{\Gamma}{|x|}{|S|}$.
By the inversion lemma again,
  it holds that $|x:S| \to |T| \in \Gamma$ and $|x:S| \in \Gamma$.
Since any environment can hold only one type binding for one variable,
  we can derive $|S| \to |T| = |S|$.
However, the sizes of the both hand sides do not match.
This contradicts to the equality.
\qed

\Ex{9.3.9}
We show it by induction on derivations of $\CtxTyRel{\Gamma}{|t|}{|T|}$.
We prove each induction step by case analysis of the derivation rule
  used at the last derivation step.

\Case\Rule{T-True}, \Rule{T-False}, and \Rule{T-Abs}:
In these cases, |t| is a value,
  so there is no evaluation rule that derives $|t| \to |t|'$ for any $|t|'$,
  and the statement vacuously holds.

\Case\Rule{T-If}:
In this case, we can write $|t| = \IfThenElse{|t|_1}{|t|_2}{|t|_3}$
  with subderivations of
  $\CtxTyRel{\Gamma}{|t|_1}{|Bool|}$,
  $\CtxTyRel{\Gamma}{|t|_2}{|T|}$, and
  $\CtxTyRel{\Gamma}{|t|_3}{|T|}$.
We show this case by case analysis of the evaluation rule applied to $|t|$.
\begin{itemize}
  \item \Case\Rule{E-IfTrue}:
    In this case, we have $|t|_1 = |true|$ and $|t| \to |t|_2$.
    By the uniqueness of evaluation, it holds $|t|' = |t|_2$.
    We then immediately obtain $\CtxTyRel{\Gamma}{|t|'}{|T|}$.
  \item \Case\Rule{E-IfFalse}: Similar as \Rule{E-IfTrue} case.
  \item \Case\Rule{E-If}:
    In this case, we have $|t|_1 \to |t|'_1$
      and $|t| \to \IfThenElse{|t|'_1}{|t|_2}{|t|_3} = |t|'$.
    By induction hypothesis, it holds $\CtxTyRel{\Gamma}{|t|'_1}{|Bool|}$.
    Therefore, we get $\CtxTyRel{\Gamma}{|t|'}{|T|}$.
\end{itemize}

\Case\Rule{T-Var}:
In this case,
  $|t| = |x|$ is a variable
  and therefore there is no evaluation rule that evaluates $|t|$.

\Case\Rule{T-App}:
In this case,
  we can write $|t| = |t|_1 ~ |t|_2$
  with subderivations of
  $\CtxTyRel{\Gamma}{|t|_1}{|S| \to |T|}$ and
  $\CtxTyRel{\Gamma}{|t|_2}{|S|}$ for some type |S|.
There are three cases of the evaluation rule that derives $|t| \to |t|'$.
\begin{itemize}
  \item \Case\Rule{E-App1}
    In this case, we have $|t|_1 \to |t|'_1$ and $|t| \to |t|'_1 ~ |t|_2$.
    By induction hypothesis,
      it holds $\CtxTyRel{\Gamma}{|t|'_1}{|S| \to |T|}$.
    By applying the typing rule \Rule{T-App} to
      this typing relation and $\CtxTyRel{\Gamma}{|t|_2}{|S|}$,
      we get $\CtxTyRel{\Gamma}{|t|'}{|T|}$.
  \item \Case\Rule{E-App2}
    We can prove for this case similarly as \Rule{E-App1} case.
  \item \Case\Rule{E-AppAbs}:
    In this case,
      we can write $|t| = \CParen{\AbTy{|x|}{|S|} |t|_{12}} |v|_2$ and
      $|t|' = \subst{|x| \mapsto |v|_2} |t|_{12}$
    By the inversion lemma of typing relations,
      we have
      $\CtxTyRel{\Gamma}{\CParen{\AbTy{|x|}{|S|} |t|_{12}}}{|S| \to |T|}$
      and
      $\CtxTyRel{\Gamma}{|v|_2}{|S|}$.
    The former relation is derived by \Rule{T-Abs},
      with which we have $\CtxTyRel{\Gamma, |x:S|}{|t|_{12}}{|T|}$.
    By the substitution lemma,
      we get $\CtxTyRel{\Gamma}{\subst{|x| \mapsto |v|_2} |t|_{12}}{|T|}$,
      which is what we wanted to prove.
\end{itemize}
\qed

\Ex{9.3.10}
\textbf{No}.
For example,
  let $\Gamma = \TyRel{|y|}{|Bool| \to |Bool|}$
  and $|t| = \CParen{\AbTy{|x|}{|Bool|} |x|} ~|y|$.
Applying \Rule{E-AppAbs} yields
  $|t| \to |t|' = \subst{|x| \mapsto |y|} |x| = |y|$.
Using \Rule{T-Var}, we can derive $\CtxTyRel{\Gamma}{|t|'}{|Bool| \to |Bool|}$.
However, it is obvious that |t| is not typed under $\Gamma$,
  so $\CtxTyRel{\Gamma}{|t|}{|Bool| \to |Bool|}$ does not hold.

\Ex{9.4.1}
|Bool|: \Rule{T-True} and \Rule{T-False} are the introduction rules,
  and \Rule{T-If} is the elimination rule.

|Nat|: \Rule{T-Zero} and \Rule{T-Succ} are the introduction rules,
  and \Rule{T-Pred} and \Rule{T-IsZero} are the elimination rules.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 10.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An ML Implementation of Simple Types}
Rust implementation is put at |src/bin/simplebool.rs|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 11.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simple Extensions}

\Ex{11.2.1}
Define $|t|_1 = |unit|$ and
\[
  |t|_{n + 1} = \CParen{
    \AbTy{|f|}{|Unit| \to |Unit|} ~|f (f unit)|
  } ~ \CParen{
    \AbTy{|x|}{|Unit|} |t|_n
  }
\]
  for $n = 1, 2, \dots$.
It is obvious that the size of $|t|_n$ grows linearly with $n$.
Evaluation of $|t|_{n + 1}$ proceeds as follows.
\begin{align*}
  &&&\phantomrel\to |t|_{n + 1} \\
  &\EqComment{\Rule{E-AppAbs}} &&\to
    \CParen{\AbTy{|x|}{|Unit|} |t|_n} ~
    \CParen{ \CParen{\AbTy{|x|}{|Unit|} |t|_n} ~|unit|} \\
  &\EqComment{\Rule{E-AppAbs}} &&\to
    \CParen{\AbTy{|x|}{|Unit|} |t|_n} ~
    |t|_n \\
  &\EqComment{evaluate $|t|_n$} &&\to^*
    \CParen{\AbTy{|x|}{|Unit|} |t|_n} ~ |unit| \\
  &\EqComment{\Rule{E-AppAbs}} &&\to |t|_n \\
  &\EqComment{evaluate $|t|_n$} &&\to^* |unit|.
\end{align*}
During the evaluation,
  $|t|_n$ is evaluated twice,
  so we can show by induction that the number of steps to evaluate $|t|_n$ is $O(2^n)$.
\qed

\Ex{11.3.2}
Let $e : \lambda^E \to \lambda^I$ be the elaboration function.
We show for typing and evaluation both by induction on structure of |t|.

Typing rule:
\begin{center}
  \AxiomC{$\CtxTyRel{\Gamma}{|t|_2}{|T|_2}$}
  \UnaryInfC{$\CtxTyRel{\Gamma}{\AbTy{|_|}{|T|_1} |t|_2}{|T|_1 \to |T|_2}$}
  \DisplayProof
\end{center}
If $\CtxxTyRel E{\Gamma}{\AbTy{|_|}{|T|_1} |t|_2}{|T|_1 \to |T|_2}$,
  it is derived from $\CtxxTyRel E{\Gamma}{|t|_2}{|T|_2}$.
By induction hypothesis,
  it holds $\CtxxTyRel I{\Gamma}{e(|t|_2)}{|T|_2}$.
Choose a variable name |x| from the outside of $\Gamma$.
Then, weakining yields $\CtxxTyRel I{\Gamma, |x:T|_1}{e(|t|_2)}{|T|_2}$,
  from which we can derive
  $\CtxxTyRel I{\Gamma}{\AbTy{|x|}{|T|_1} e(|t|_2)}{|T|_1 \to |T|_2}$.

If $\CtxxTyRel I{\Gamma}{\AbTy{|x|}{|T|_1} e(|t|_2)}{|T|_1 \to |T|_2}$
  where $|x| \notin \Gamma$ and $|x| \notin FV(|t|_2)$,
  it is derived from $\CtxxTyRel I{\Gamma, |x:T|_1}{e(|t|_2)}{|T|_2}$.
By induction hypothesis,
  it holds $\CtxxTyRel E{\Gamma, |x:T|_1}{|t|_2}{|T|_2}$.
Since $|x|$ does not appear in $|t|_2$ as a free variable,
  we can omit it from the context as $\CtxxTyRel E{\Gamma}{|t|_2}{|T|_2}$,
  from which we can derive
  $\CtxxTyRel E{\Gamma}{\AbTy{|_|}{|T|_1} |t|_2}{|T|_1 \to |T|_2}$.

Evaluation rule:
\begin{center}
  \AxiomC{$\CParen{\AbTy{|_|}{|T|_{11}} |t|_{12}} ~ |v|_2 \to |t|_{12}$}
  \DisplayProof
\end{center}
If $|t| \to_E |t|'$,
  we should only care about the case when |t| is written as
  $|t| = \CParen{\AbTy{|_|}{|T|_{11}} |t|_{12}} ~ |v|_2$,
  or otherwise $e(|t|) \to_I e(|t|')$ follows immediately from
  the induction hypothesis.
However, even this case is obvious as we have $|t|' = |t|_{12}$
  and, by choosing $|x| \notin FV(|t|_{12})$,
  we can derive
  $
    e(|t|) = \CParen{\AbTy{|x|}{|T|_{11}} e(|t|_{12})} ~ |v|_2
           \to_I e(|t|_{12})
           = e(|t|')
  $.

If $e(|t|) \to_I e(|t|')$,
  we again should only care about the case when $|t|$ is written as
  $|t| = \CParen{\AbTy{|_|}{|T|_{11}} |t|_{12}} ~ |v|_2$.
In this case,
  we have $e(|t|) = \CParen{\AbTy{|x|}{|T|_{11}} e(|t|_{12})} ~ |v|_2$
  where the name |x| is chosen arbitrarily from the outside of $FV(|t|_{12})$.
It is then derived that $e(|t|') = e(|t|_{12})$, while we have $|t| \to |t|_{12}$.
Note that this is what we can show; see the errata of the text.

\Ex{11.4.1}
\begin{itemize}
  \item[(1)]
    We can define a derived form as
      $|t as T| \EqDef \CParen{\AbTy{|x|}{|T|} |x|} ~ |t|$.
    The evaluation and typing rules are derived directly from those of the
      inner language.
  \item[(2)]
    To delay the evalution of |t|, we define a derived form as follows.
    \[
      |t as T| \EqDef
        \CParen{\AbTy{|x|}{|Unit| \to |T|} ~|x unit|} ~
        \CParen{\AbTy{|_|}{|Unit|} |t|}.
    \]
    The right hand side is evaluated as follows.
    \begin{align*}
      &&&\phantomrel\to
        \CParen{\AbTy{|x|}{|Unit| \to |T|} ~|x unit|} ~
          \CParen{\AbTy{|_|}{|Unit|} |t|} \\
      &\EqComment{\Rule{E-AppAbs}} &&\to \CParen{\AbTy{|_|}{|Unit|} |t|} ~ |unit| \\
      &\EqComment{\Rule{E-AppAbs}} &&\to |t|.
    \end{align*}
    Note that it requires two steps to evaluate the desugared form.
    Equivalence of typing is straightforward.
\end{itemize}

\Ex{11.5.1}
See |src/bin/lexexercise.rs| for
  a Rust implementation of simply typed \break lambda-calculus with |unit| and |let|.
It includes an implementation of small-step evaluation and typing of
  let expressions.

\Ex{11.5.2}
I do not think this approach is a good idea because it breaks the evaluation order.
For example, it may cause the size of the desugared code to bloat up.
Consider the following code.
\begin{Code}
  let x = (
    let y = (
      let z = false
        in if true then z else z
    ) in if true then y else y
  ) in if true then x else x;
\end{Code}
Using the original derived form, this term is desugared into the following code:
\begin{Code}
  ($\Lm$x:Bool$\to$Bool. if true then x else x) (
    ($\Lm$y:Bool$\to$Bool. if true then y else y) (
      ($\Lm$z:Bool$\to$Bool. if true then z else z) false
    )
  )
\end{Code}
Evaluation proceeds by interleaved usages of \Rule{E-AbsApp} and \Rule{E-IfTrue},
  and any intermediate results are smaller than the original code.

If we use the derived form using substitution, it would be as follows:
\begin{Code}
  if true then (
    if true then (
      if true then false else false
    ) else (
      if true then false else false
    )
  ) else (
    if true then (
      if true then false else false
    ) else (
      if true then false else false
    )
  )
\end{Code}
It is obvious that the size of the code bloat up exponentially with the depth
  of the nested |let| expressions.
If we repeat this structure more times (say, of depth $n$),
  the size of the desugared code would grow exponentially, i.e., $O(2^n)$.

\Ex{11.8.1}
\[
  \Rec{
    |l|_i |=| |v|_i \Indices{i \in 1 .. j - 1} |,| ~
    |l|_j |=| |v|_j |,| ~
    |l|_k |=| |v|_k \Indices{k \in j + 1 .. n}
  } |.l|_j
  \to |v|_j
\]

\Ex{11.8.2}
1. We introduce \emph{pattern typing relations}
  with the following syntactic rule.
\begin{Code}
  pt $::=$ p : T $\To$ $\Gamma$
\end{Code}
Pattern typing relations are derived by the following derivation rules.
\begin{center}
  \AxiomC{}
  \RuleLabel{PT-Var}
  \UnaryInfC{$|x:T| \To |x:T|$}
  \DisplayProof \proofsep
  \AxiomC{for each $i$ ~ $|p|_i |:| |T|_i \to \Gamma_i$}
  \RuleLabel{PT-Rcd}
  \UnaryInfC{$
    \Rec{|l|_i |=| |p|_i \Indices{i \in 1..n}}
    |:|
    \Rec{|l|_i |:| |T|_i \Indices{i \in 1..n}}
    \To
    \Gamma_1 |,| \dots |,| \Gamma_n
  $}
  \DisplayProof
\end{center}
Using pattern typing, we add the following typing rule.
\begin{center}
  \AxiomC{$\CtxTyRel{\Gamma_1}{|t|_1}{|T|_1}$}
  \AxiomC{$|p:T|_1 \To \Gamma_2$}
  \AxiomC{$\CtxTyRel{\Gamma_1, \Gamma_2}{|t|_2}{|T|_2}$}
  \RuleLabel{T-Let}
  \TrinaryInfC{$\CtxTyRel{\Gamma_1}{|let| ~ |p=t|_1 ~ |in| ~ |t|_2}{|T|_2}$}
  \DisplayProof
\end{center}

2. Type preservation for \Rule{E-Let} is straight-forward.
To show it for \Rule{E-LetV},
  we need the following lemma, which is a generalization of \textsc{Lemma 9.3.8}.

\Lemma{11.8.2.1}
If $\CtxTyRel{\Gamma}{|v|}{|S|}$,
  $|p:S| \To \Gamma'$,
  and $\CtxTyRel{\Gamma, \Gamma'}{|t|}{|T|}$,
  then \break $\CtxTyRel{\Gamma}{\subst{match(|p|, |v|)}|t|}{|T|}$. \qed

The lemma is shown by induciton on derivation of $|p:S| \To \Gamma'$.

Type progress is shown by induction on derivation of the type of the term.
Suppose we have a typing relation
  $\CtxTyRel{\Gamma}{|let p=t|_1 ~ |in t|_2}{|T|_2}$.
Since it should be derived by \Rule{T-Let},
  we have $\CtxTyRel{\Gamma}{|t|_1}{|T|_1}$ for some type $|T|_1$.
If $|t|_1$ is not a value,
  then $|t|_1$ is evaluated to another term $|t|'_1$ by the induction hypothesis.
Otherwise, the |let| expression is evaluated by \Rule{E-LetV}. \qed

\Ex{11.9.1}
The boolean syntaxes can be defined as derived forms as follows.
\begin{alignat*}{2}
  & |Bool| &&\EqDef |Unit| + |Unit| \\
  & |true| &&\EqDef |inl unit| \\
  & |false| &&\EqDef |inr unit| \\
  & |if t|_1 |\ then t|_2 |\ else t|_3
    &&\EqDef |case t|_1 |\ of inl x|_2 \To |t|_2 |\ \| inr x|_3 \To |t|_3
\end{alignat*}
  where, in the last line, $|x|_2$ and $|x|_3$ are fresh.

\Ex{11.11.1}
\begin{Code}
  equal = fix ($\Lm$eq:Nat$\to$Nat$\to$Bool. $\Lm$m:Nat. $\Lm$n:Nat.
                   if iszero m then iszero n
                   else if iszero n then false
                   else eq (pred m) (pred n));
  plus = fix ($\Lm$p:Nat$\to$Nat$\to$Nat. $\Lm$m:Nat. $\Lm$n:Nat.
                  if iszero n then m
                  else succ (p m (pred n));
  times = fix ($\Lm$t:Nat$\to$Nat$\to$Nat. $\Lm$m:Nat. $\Lm$n:Nat.
                   if iszero n then 0
                   else plus m (t m (pred n)));
  factorial = fix ($\Lm$f:Nat$\to$Nat. $\Lm$n:Nat.
                       if iszero n then 1
                       else times n (f (pred n)));
\end{Code}

\Ex{11.11.2}
\begin{Code}
  plus = letrec p : Nat$\to$Nat$\to$Nat =
           $\Lm$m:Nat. $\Lm$n:Nat.
             if iszero n then m else succ(p m (pred n))
         in p;
  times = letrec t : Nat$\to$Nat$\to$Nat =
            $\Lm$m:Nat. $\Lm$n:Nat.
              if iszero n then 0 else plus m (t m (pred n))
          in t;
  factorial = letrec f : Nat$\to$Nat =
                $\Lm$n:Nat.
                  if iszero n then 1 else times n (f (pred n))
              in f;
\end{Code}

\Ex{11.12.1}
\textsc{Preservation}:
We show it by induction on derivation of $|t| \to |t|'$.
We perform case analysis on the last rule used for the derivation.
We omit the cases not involving lists as they are proved in the same way as before.

\Case\Rule{E-Cons1}, \Rule{E-Isnil}, \Rule{E-Head}, \Rule{E-Tail}:
These rules only evaluate a subterm of |t|,
  whose type is preserved by the induction hypothesis.

\Case\Rule{E-IsnilNil}:
In this case,
  we can write $|t| = |isnil[S] (nil[T])|$.
Using \Rule{T-Nil} and \Rule{T-Isnil},
  we derive |t:Bool|,
  while $|t|' = |true|$, whose type is |Bool|.

\Case\Rule{E-IsnilCons}:
Let $|t| = |isnil[S|_1 |] (cons[S|_2 |] v|_1 |\ v|_2 |)|$
  and $\CtxTyRel{\Gamma}{|t|}{|T|}$.
By the inversion lemma for \Rule{T-Isnil}
  (we omit the precise statement and proof here;
   same for that for other typing rules),
  we obtain $|T| = |Bool|$, while we have $|t|' = |false|$, which has type |Bool|.

\Case\Rule{E-HeadCons}:
Let $|t| = |head[S|_1 |] (cons[S|_2 |] v|_1 |\ v|_2 |)|$
  and $\CtxTyRel{\Gamma}{|t|}{|T|}$.
Using the inversion lemma for \Rule{T-Head},
  we obtain $\CtxTyRel{\Gamma}{|cons[S|_2 |] v|_1 |\ v|_2}{|List S|_1}$
  and $|T| = |S|_1$.
By applying the inversion lemma for \Rule{T-Cons},
  we further obtain $\CtxTyRel{\Gamma}{|v|_1}{|S|_1}$.
Since $|t| \to |v|_1$, the type is preserved.

\Case\Rule{E-TailCons}:
Proof is almost identical to the case of \Rule{E-HeadCons},
  except that the use of \Rule{T-Head} is replaced with \Rule{T-Tail}. \qed

\textsc{Progress}:
The progress property does not hold.
For example,
  for any type |T|,
  non-value, well-typed terms |head[T] nil[T]| and |tail[T] nil[T]| are normal forms,
  i.e., stuck states.

\Ex{11.12.2}
The annotation in |nil[T]| is required to make the type unique
  in the same sense as the |as T| ascription for sum and variant types.
All the other annotations can be safely removed,
  as the types are obtained by premises of the type derivaiton rules.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 12.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Normalization}

\Ex{12.1.1}
For example, given a value |a| of type |A|,
  applying a function $\Lm|f:A|\to|A. f (f a)|$ to a very long abstraction term
  of type $|A|\to|A|$ duplicates the abstraction term,
  which leads to a term of size larger than the original.

\Ex{12.1.7}
We extend \textsc{Definition 12.1.2} by adding the following items.
\begin{itemize}
  \item $R_{|Bool|}(|t|)$ iff |t| halts.
  \item $R_{|T|_1 \times |T|_2}(|t|)$
          iff |t| halts, $R_{|T|_1}(|t.1|)$, and $R_{|T|_2}(|t.2|)$.
\end{itemize}
We then extend \textsc{Lemma 12.1.5} with booleans and products.
Abbreviate $\Gamma = |x|_1 |,| \dots |,| |x|_n$ and
  $\sigma = \subst{|x|_1 \mapsto |v|_1} \dots \subst{|x|_n \mapsto |v|_n}$
  throughout the proof.

\Case\Rule{T-True}, \Rule{T-False}: Immediate.

\Case\Rule{T-If}:
In this case, we have
  $|t| = |if t|_1 |\ then t|_2 |\ else t|_3$,
  $\CtxTyRel{\Gamma}{|t|_1}{|Bool|}$,
  $\CtxTyRel{\Gamma}{|t|_2}{|T|}$, and
  $\CtxTyRel{\Gamma}{|t|_3}{|T|}$.
By the induction hypothesis, $R_{|Bool|}(\sigma |t|_1)$.
By \textsc{Lemma 12.1.3}, we have $\sigma |t|_1 \to^* |v|'_1$ for some $|v|'_1$.
If $|v|'_1 = |true|$, $\sigma |t| \to^* \sigma |t|_2$.
By the induction hypothesis, $R_{|T|}(\sigma |t|_2)$, and thus $R_{|T|}(\sigma |t|)$.
The case of $|v|'_1 = |false|$ is similar.

\Case\Rule{T-Pair}:
In this case, we have
  $|t| = \Rec{|t|_1 |,t|_2}$,
  $\CtxTyRel{\Gamma}{|t|_1}{|T|_1}$, and
  $\CtxTyRel{\Gamma}{|t|_2}{|T|_2}$.
By the induction hypothesis,
  $R_{|T|_1}(\sigma |t|_1)$ and $R_{|T|_2}(\sigma |t|_2)$.
Therefore,
  we have $\sigma |t|_1 \to^* |v|'_1$ and $\sigma |t|_2 \to^* |v|'_2$
  for some $|v|'_1$ and $|v|'_2$.
With \Rule{E-Pair1} and \Rule{E-Pair2},
  it follows that $\sigma |t| \to^* \Rec{|v|'_1 |,v|'_2}$.
By combining it with $R_{|T|_1}(\sigma |t|_1)$ and $R_{|T|_2}(\sigma |t|_2)$,
  we obtain $R_{|T|_1 \times |T|_2}(\sigma |t|)$.

\Case\Rule{T-Proj1}:
In this case, we have
  $|t| = |t|_1 |.1|$ and $\CtxTyRel{\Gamma}{|t|_1}{|T|_{11} \times |T|_{12}}$.
By the induction hypothesis,
  $R_{|T|_{11} \times |T|_{12}}(\sigma |t|_1)$ holds,
  which implies $R_{|T|_{11}}(\sigma |t|_1 |.1|)$.

\Case\Rule{T-Proj2}: Similar to \Case\Rule{T-Proj1}. \qed

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 13.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{References}

We use the dereference operator |!| without parentheses for readability.
The precedence of |!| is higher than function applications,
  i.e., |!x y| is equivalent to |(!x) y|.

\Ex{13.1.1}
Omitted to avoid drawing...
|a| is a pair of references pointing to distinct |0|s,
  while |b| is a pair of references pointing to the same |0|.

\Ex{13.1.2}
No.
With this definition,
  looking up the updated |a| with a key not matching to |m| used in the udpate
  will examine the function referenced by the same |a| instead of the old one,
  resulting in divergence.

\Ex{13.1.3}
Define an operator |free r| that takes a reference and frees its storage,
  which will be reused in the use of |ref| operator in the next time.
Then, the following well-typed program
\begin{Code}
  let r = ref 0 in
  let s = r in
  free r;
  let t = ref false in
  succ !s
\end{Code}
  will be evaluated to a stuck state |succ false|.

\Ex{13.3.1}
Garbage collection requires to track the set of locations
  reachable from the outermost term.
To model it,
  we introduce a function $reachable(|t|, \mu)$ that
  maps a term and a store to the set of locations reachable from them,
  and a \emph{gc step} $\to_{\text{gc}}$ that models the action of garbage collection.

First, define $locations(|t|)$ recursively as follows.
\begin{alignat*}{2}
  & locations(|x|) &&= \emptyset, \\
  & locations(\AbTy{|x|}{|T|} |t|) &&= locations(|t|), \\
  & locations(|t|_1 ~ |t|_2) &&= locations(|t|_1) \cup locations(|t|_2), \\
  & locations(|unit|) &&= \emptyset, \\
  & locations(|ref t|) &&= \emptyset, \\
  & locations(|!t|) &&= locations(|t|), \\
  & locations(|t|_1 |:=| |t|_2) &&= locations(|t|_1) \cup locations(|t|_2), \\
  & locations(l) &&= \{ l \}.
\end{alignat*}
This function simply collects all the occurences of locations in a term.
Using this function,
  we define $reachable(|t|, \mu)$ as the smallest subset $L$ of
  the domain of $\mu$ that satisfies the following conditions.

\begin{itemize}
  \item $locations(|t|) \subseteq L$.
  \item If $l \in L$, then $locations(\mu(l)) \subseteq L$.
\end{itemize}

Using this function, we define a gc step as follows.
\[
  \Store{|t|}{\mu} \longrightarrow_{\text{gc}} \Store{|t|}{(l \mapsto \mu(l) \mid l \in reachable(|t|, \mu))}
\]
Then, we form an evaluation of a term by interleaving evaluation and gc steps.

To show the correctness of this refinement,
  we need to confirm that the gc steps do not affect the result of evaluations.

\Theorem:
If $\Store{|t|}{\mu} \to^* \Store{|t|'}{\mu'}$,
  the evaluation is reproduced with an additional gc step,
  i.e.,
  $\Store{|t|}{\mu} \to_{\text{gc}} \Store{|t|}{\tilde\mu} \to^* \Store{|t|'}{\tilde\mu'}$.
  \qed

Given this theorem,
  we can insert a gc step to an arbitrary position of a sequence of evaluation steps
  without affecting the evaluation result.

\Ex{13.4.1}
\begin{Code}
  let r1 = ref $\Lm$n:Nat. n in
  let r2 = ref $\Lm$n:Nat. !r1 n in
  r1 := $\Lm$n:Nat. !r2 n;
  !r1 0
\end{Code}

\Ex{13.5.2}
Let
  $\Gamma = \emptyset$,
  $\mu = l \mapsto \AbTy{|x|}{|Unit|} |(| |!|l |)| ~ |x|$,
  $\Sigma_1 = (l \mapsto |Unit| \to |Unit|)$, and
  $\Sigma_2 = (l \mapsto |Unit| \to |Unit| \to |Unit|)$.
Then,
  both $\CtxSto{\Gamma}{\Sigma_1}{\mu}$ and $\CtxSto{\Gamma}{\Sigma_2}{\mu}$
  hold.

\Ex{13.5.8}
Not normalizing on well-typed terms in general.
The code in Exercise 13.4.1 is an example of well-typed terms that do not normalize.

The following is a well-typed factorial function.
\begin{Code}
  factorial =
      let r = ref $\Lm$n:Nat. 0 in
      (
        r := $\Lm$n:Nat. if iszero n
                     then 1
                     else times n (!r (pred n));
        !r
      );
\end{Code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 14.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Exceptions}

\Ex{14.1.1}
This approach does not work since the type of |error| does not preserve
  through evaluation steps.
For example, in a term |error unit|,
  |error| is assigned a type $|Unit| \to |T|$ for some type |T|,
  while the term after one-step evaluation, |error|, is of type |T|.
Simply letting the programmer to annotate the type for |error| terms and use them
  thgouhout the evaluation steps breaks type preservation.
We may just erase the type annotation on evaluation
  as we have done for type ascription,
  in which case we anyway need \Rule{T-Error}
  to correctly type terms after any evaluation involving |error|,
  and the difficulty remains unsolved.

\Ex{14.3.1, 14.3.2, 14.3.3} \textsc{Todo}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 14.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subtyping}

\Ex{15.2.1}
\begin{center}
  \AxiomC{}
  \RuleLabel{S-RcdPerm}
  \UnaryInfC{$\phantomrel\Sb |\{x:Nat,y:Nat,z:Nat\}|$}
  \noLine\UnaryInfC{$\Sb |\{y:Nat,x:Nat,z:Nat\}|$}
  \AxiomC{}
  \RuleLabel{S-RcdWidth}
  \UnaryInfC{|\{y:Nat,x:Nat,z:Nat\}|}
  \noLine\UnaryInfC{$\Sb |\{y:Nat\}|$}
  \RuleLabel{S-Trans}
  \BinaryInfC{$\Sub{|\{x:Nat,y:Nat,z:Nat\}|}{|\{y:Nat\}|}$}
  \DisplayProof
\end{center}

\Ex{15.2.2}
There is another derivation that uses subtyping of |f| instead of |xy| as follows.
\begin{center}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\CtxTyRel{}{|f|}{|Rx| \to |Nat|}$}
  \AxiomC{}
  \RuleLabel{S-RcdWidth}
  \UnaryInfC{$\Sub{|Rxy|}{|Rx|}$}
  \AxiomC{}
  \RuleLabel{S-Refl}
  \UnaryInfC{$\Sub{|Nat|}{|Nat|}$}
  \RuleLabel{S-Arrow}
  \BinaryInfC{$\Sub{|Rx| \to |Nat|}{|Rxy| \to |Nat|}$}
  \RuleLabel{T-Sub}
  \BinaryInfC{$\CtxTyRel{}{|f|}{|Rxy| \to |Nat|}$}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\CtxTyRel{}{|xy|}{|Rxy|}$}
  \RuleLabel{T-App}
  \BinaryInfC{$\CtxTyRel{}{|f xy|}{|Nat|}$}
  \DisplayProof
\end{center}

\Ex{15.2.3}
\begin{itemize}
  \item[(1)] There are six supertypes:
      \Rec{|a:Top,b:Top|},
      \Rec{|b:Top,a:Top|},
      \Rec{|a:Top|},
      \Rec{|b:Top|},
      \Rec{}, and
      |Top|.
  \item[(2)]
    Let $|S|_0 = \Rec{}$ and $|S|_{i + 1} = \Rec{|x:S|_i}$ for $i\in\N$.
    We have $\Sub{|S|_1 = \Rec{|x:|\Rec{}}}{\Rec{} = |S|_0}$.
    For each $i > 0$, if $\Sub{|S|_i}{|S|_{i - 1}}$,
      then $\Sub{|S|_{i + 1} = \Rec{|x:S|_i}}{\Rec{|x:S|_{i - 1}} = |S|_i}$.
    Therefore, $(|S|_i)_i$ is an infinite sequence of descending types.
  \item[(3)]
    Using $|S|_i$ defined above, let $|T|_i = |S|_i \to |Top|$.
    Then, $(|T|_i)_i$ is an infinite sequence of ascending types.
\end{itemize}

\Ex{15.2.4}
There is no such type.
\Proof:
Any type is either a function type, a record type, or |Top|.
Any function type is not a subtype of record types, and vice versa.
And |Top| is not a subtype of any other types.

It implies that no arrow type is a supertype of every other arrow type.
If there were such a type,
  its domain type would have a type that is a subtype of
  the domain type of any other arrow types,
  which does not exist as shown above.

\Ex{15.2.5}
It is not a good idea since, e.g., it breaks the progress property as follows.
Let $|t| = \Rec{\AbTy{|x|}{\Rec{}} |x,\ |\Rec{}}$
We have $\CtxTyRel{}{|t|}{}$.
% We have $\CtxTyRel{}{|t|}{|(\{\}| \to |\{\})| \times |\{\}|}$.
With the rule \Rule{S-ProdWidth},
  we can derive $\CtxTyRel{}{|t|}{|\{\}| \to |\{\}|}$.
Therefore, a term |t \{\}| is well-typed, which is obviously a stuck state.

\Ex{15.3.1}
The progress property may break with an additional subtyping rule,
  as we saw in Excercise 15.2.5.
The preservation property may break as well;
  consider adding the following subtyping rule.
\[ \Sub{|T|_1 \to |T|_2}{|T|_1} \]
Let $|f| = \AbTy{|x|}{|Top| \to |Unit|} |0|$.
With the above rule, we can derive $\CtxTyRel{}{|f|}{|Top| \to |Unit|}$.
Therefore, we have
  $\CtxTyRel{}{|f (| \AbTy{|x|}{|Top|} |unit)|}{|Unit|}$.
However,
  this term is evaluated as $|f (| \AbTy{|x|}{|Top|} |unit)| \to |0|$,
  which cannot have type |Unit|.

Removing any subtyping rule does not break the progress nor preservation property.

\Ex{15.3.2}
\Proof: By induction on derivation of subtyping.
\begin{enumerate}
  \item We perform case analysis of the last rule used
    for deriving $\Sub{|S|}{|T|_1 \to |T|_2}$

    \Case\Rule{S-Refl}:
      We have $|S| = |T|_1 \to |T|_2$.
      By \Rule{S-Refl}, $\Sub{|T|_1}{|T|_1}$ and $\Sub{|T|_2}{|T|_2}$.
    
    \Case\Rule{S-Trans}:
      We have $\Sub{|S|}{|U|}$ and $\Sub{|U|}{|T|_1 \to |T|_2}$ for some type |U|.
      By the induction hypothesis,
        |U| has the form $|U|_1 \to |U|_2$ with
        $\Sub{|T|_1}{|U|_1}$ and $\Sub{|U|_2}{|T|_2}$.
      By the induction hypothesis again,
        |S| has the form $|S|_1 \to |S|_2$ with
        $\Sub{|U|_1}{|S|_1}$ and $\Sub{|S|_2}{|U|_2}$.
      Using \Rule{S-Trans},
        we derive $\Sub{|T|_1}{|S|_1}$ and $\Sub{|S|_2}{|T|_2}$.

    \Case\Rule{S-Arrow}: Immediate.

    \Case\Rule{S-Top},
         \Rule{S-RcdWidth},
         \Rule{S-RcdDepth},
         \Rule{S-RcdPerm}: Impossible.

  \item We can show similarly as 1. by case analysis of the last rule used
    for deriving the subtyping relation.

    \Case\Rule{S-RcdWidth}: Immediate by combining with \Rule{S-Refl}.

    \Case\Rule{S-RcdDepth}: Immediate.

    \Case\Rule{S-RcdPerm}:
      Let $\sigma$ be the permutation that satisfies $|l|_i = |k|_{\sigma(i)}$
        and $|T|_i = |S|_{\sigma(i)}$.
      It is obvious that
      $
        \{|l|_i \Indices{i\in1..n} \}
        = \{|k|_{\sigma(i)} \Indices{i\in1..n}\}
        = \{|k|_j \Indices{j\in1..n}\}
      $, and $\Sub{|S|_{\sigma(i)} = |T|_i}{|T|_i}$ for each $i$.

    \Case\Rule{S-Arrow}, \Rule{S-Top}: Impossible.

    \Case\Rule{S-Refl}, \Rule{S-Trans}: Similar to 1. \qed
\end{enumerate}

\Ex{15.3.6}
\begin{enumerate}
  \item
    A closed value |v| has the form of either
      $\AbTy{|x|}{|S|} |t|$ or $\Rec{|l|_i |=v|_i \Indices{i\in1..n}}$
      (we can exclude the possibilities of $|v| = |x|$ and $|v| = |x.l|$
       because |v| is a closed value).
    If $\CtxTyRel{}{|v|}{|T|_1 \to |T|_2}$,
      |v| can only take the former form by the inversion lemma.
  \item Similarly shown by the inversion lemma. \qed
\end{enumerate}

\end{document}
