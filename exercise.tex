\documentclass{article}

\usepackage{amsmath,amssymb,amsthm}
\usepackage{bussproofs}
\usepackage[a4paper, total={6in, 9in}]{geometry}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{newpxmath,newpxtext}
\usepackage{parskip}
\usepackage{tikz}
\usepackage{xstring}
\usetikzlibrary{arrows.meta}

\makeatletter

\theoremstyle{definition}

% Use |x| as a short verb also available in math mode.
\newcommand\Cd@Vert|
\catcode`|=\active
\def|#1|{\Cd{#1}}

\newcommand\Map[2]{\Map@#1#2\relax}
\newcommand\Map@[2]{#1#2\@ifnextchar\relax{}{\Map@#1}}

% Define \cA, ..., \cZ
\newcommand\@DefCal[1]{\expandafter\newcommand\csname c#1\endcsname{\mathcal#1}}
\Map{\@DefCal}{ABCDEFGHIJKLMNOPQRSTUVWXYZ}

\newcommand\Ab[1]{\Ab@Impl#1\relax}
\newcommand\Ab@Impl[1]{\Ab@One#1|.|\@ifnextchar\relax{}{\Ab@Impl}}
\newcommand\Ab@One[1]{\lambda|#1|}
\newcommand\Abn[1]{\Repeat{#1}{\lambda|.|}}
\newcommand\AbTy[2]{\lambda #1 |:| #2 |.|}
\newcommand\AlCtx[2]{#1 \Tsto #2}
\newcommand\AlTyRel[3]{\AlCtx{#1}{\TyRel{#2}{#3}}}
\newcommand\App{\CdSpc}
\newcommand\Bigstep{\Downarrow}
\newcommand\Cardi[1]{\vert#1\vert}
\newcommand\Case{\It{Case} }
\newcommand\CaseArm[2]{#1 \To #2 \@ifnextchar\CaseArm{\Cd{ | }}{}}
\newcommand\CaseOf[1]{|case |#1| of |}
\newcommand\Cbar[1]{\overline{|#1|}}
\newcommand\CBracket[1]{\Cd[#1\Cd]}
\newcommand\Cd[1]{{%
  \newcommand|\Cd@Vert%
  \texttt{%
    \fontdimen2\font=\CdSpcLen%
    \StrSubstitute[0]{#1}{ }{\ }%
  }%
}}
\newcommand\CdSpc{\ }
\newdimen\CdSpcLen \CdSpcLen=\fontdimen2\font
\lstnewenvironment{Code}{
  \lstset{
    basewidth=0.5em,
    basicstyle=\ttfamily,
    gobble=2,
    mathescape,
    xleftmargin=1em,
    belowskip=0pt,
  }
}{}
\newcommand\CParen[1]{\Cd(#1\Cd)}
\newcommand\Ctx[2]{#1 \Ts #2}
\newcommand\CtxTyRel[3]{\Ctx{#1}{\TyRel{#2}{#3}}}
\newcommand\CtxTRC[5]{\CtxTyRel{#1}{#2}{#3} \mid_{#4} #5}
\newcommand\CtxSto[3]{\Ctx{\Store{#1}{#2}}{#3}}
\newcommand\DShift{\Up{}}
\newcommand\Dom{\It{dom}}
\newcommand\Down{\mathop{\downarrow}}
\newcommand\EmptySeq{\bullet}
\newcommand\EqComment[1]{[\text{\small #1}]}
\newcommand\EqDef{\stackrel{\text{def}}{=}}
\newcommand\Ex[1]{\subsection*{Exercise #1}}
\newcommand\False{\It{false}}
\newcommand\FV{\It{FV}}
\newcommand\If[3]{|if |#1| then |#2| else |#3}
\newcommand\Implies{\ \text{implies}\ }
\newcommand\Indices[1]{{}^{#1}}
\newcommand\It[1]{\textit{#1}}
\newcommand\LambdaNB{$\lambda$\textbf{NB}}
\newcommand\Lemma[1]{\textsc{Lemma #1}}
\newcommand\Let[2]{|let | #1 = #2 | in |}
\newcommand\Lm{\rlap{$\lambda$}\phantom{\Cd{.}}}
\newcommand\Mu{\rlap{$\mu$}\phantom{\Cd{.}}}
\newcommand\N{\mathbb N}
\newcommand\Otherwise{\It{Otherwise}}
\newcommand\PhantomRel[1]{\phantom{{}#1{}}}
\newcommand\Pow{\mathcal P}
\newcommand\Proof{\textsc{Proof}}
%% TODO(beam2d): Fix spacing of the last line.
\newenvironment{Proofs}{%
  \def\BottomSpc{\vspace{0pt}\vspace{0.5em}}%
  \def\nexth{\DisplayProof\quad}
  \def\next{\DisplayProof\quad\BottomSpc}%
  \begin{center}%
}{%
  \DisplayProof%
  \end{center}%
}
\newcommand\Pto{\rightharpoonup}
\newcommand\Rcd[1]{\Cd\{#1\Cd\}}
\newcommand\RemoveNames{\It{removenames}}
\newcommand\Repeat[2]{%
  \newcount\Repeat@i \Repeat@i=#1%
  \advance \Repeat@i -1%
  \loop#2%
    \advance \Repeat@i -1%
  \ifnum \Repeat@i>0 \repeat%
}
\newcommand\RestoreNames{\It{restorenames}}
\newcommand\Rule[1]{\textsc{#1}}
\newcommand\RuleLabel[1]{\RightLabel{\Rule{\scriptsize #1}}}
\newcommand\Sb{\mathrel{\texttt<\hspace{-0.3ex}\texttt:}}
\newcommand\Set[1]{\{#1\}}
\newcommand\Store[2]{#1 \mid #2}
\newcommand\Sub[2]{#1 \Sb #2}
\newcommand\Subcase{\It{Subcase} }
\newcommand\Subst[1]{[#1]\,}
\newcommand\Support{\mathop{\It{support}}}
\newcommand\Swap[2]{#2#1}
\newcommand\Theorem{\textsc{Theorem}}
\newcommand\To{\Rightarrow}
\newcommand\Todo{\textsc{Todo}}
\newcommand\True{\It{true}}
\newcommand\Ts{\vdash}
\newcommand\Tsto{\mathrel{\vdash\mkern-9mu\hbox{\usefont{U}{lasy}{m}{n}\symbol{41}}}}
\newcommand\TyRel[2]{#1 | : | #2}
\newcommand\Up{\mathop\uparrow}
\newcommand\Where{~ \text{where} ~}

\makeatother

\title{Excercise Solutions for \break \emph{Types and Programming Languages}}
\author{Seiya Tokui}

\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 1.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

nothing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 2.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mathematical Preliminaries}

\Ex{2.2.4}

$R'$ is reflexive by definition, so let us show that any reflexive relation $R''$
  that contains $R$ also contains $R'$.
Let $(s, t) \in R'$.
If $s = t$, then it holds that $(s, t) = (s, s) \in R''$ as $R''$ is reflexive.
Otherwise, $(s, t) \in R \subseteq R''$. \qed

\Ex{2.2.7}

Let $s, t, u$ satisfy $(s, t), (t, u) \in R^+ = \bigcup_i R_i$.
Since $(R_i)_i$ is a non-decreasing sequence of relations,
  there exists $k$ that satisfies $(s, t), (t, u) \in R_k$.
It then holds that $(s, u) \in R_{k + 1} \subseteq R^+$.
Therefore, the relation $R^+$ is transitive.

Let $R'$ be a transitive relation that contains $R$.
We show $R_i \subseteq R'$ by induction on $i$.
By definition, $R_0 = R \subseteq R'$.
Assume $R_i \subseteq R'$ for some $i$.
Let $(s, u) \in R_{i + 1}$.
If $(s, u) \in R_i$, then $(s, u) \in R'$.
Otherwise, there exists $t$ such that $(s, t), (t, u) \in R_i$.
Then, $(s, t), (t, u) \in R'$, which implies $(s, u) \in R'$ by transitivity of $R'$.
Therefore, $R_{i + 1} \subseteq R'$.
By taking the union, it holds that $R^+ = \bigcup_i R_i \subseteq R'$. \qed

\Ex{2.2.8}

W.l.o.g., we can assume $R$ is reflexive by replacing it with its reflexive closure.
Suppose that $R^*$ is constructed from $R$ as $R^+$ in Exercise 2.2.7.
We show by induction on $i$ that $P$ is preserved by $R_i$.
First, $P$ is preserved by $R_0 = R$.
Assume that $P$ is preserved by $R_i$ for some $i$.
If $s \in P$ and $(s, u) \in R_{i + 1}$,
  it holds that $(s, u) \in R_i$
  or there exists $t$ such that $(s, t), (t, u) \in R_i$.
By the induction hypothesis,
  in the former case, $u \in P$,
  and in the latter case, $t \in P$ and thus $u \in P$.
Therefore, $P$ is preserved by $R_{i + 1}$, concluding the induction.
It then holds that $P$ is preserved by $R^* = \bigcup_i R_i$. \qed

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 3.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Untyped Arithmetic Expressions}

\Ex{3.2.4}

We have $\Cardi{S_0} = 0$ and $\Cardi{S_{i + 1}} = 3 + 3\Cardi{S_i} + \Cardi{S_i}^3$,
  we thus get $\Cardi{S_3} = 59439$.

\Ex{3.2.5}

We show it by induction on $i$.
We have $S_0 = \emptyset \subseteq S_1$.
Suppose $S_{i - 1} \subseteq S_i$ for given $i \in \Set{1, 2, \dots}$.
Then, by definition of $S_{i + 1}$, we have
\begin{alignat*}{2}
  S_{i + 1} &=~
  && \Set{|true|, |false|, |0|} \\
  & && \cup \Set{
    |succ t|_1, ~|pred t|_1, ~|iszero t|_1
    \mid |t|_1 \in S_i
  } \\
  & && \cup \Set{
    \If{|t|_1}{|t|_2}{|t|_3}
    \mid |t|_1, |t|_2, |t|_3 \in S_i
  } \\
  &\supseteq~
  && \Set{|true|, |false|, |0|} \\
  & && \cup \Set{
    |succ t|_1, ~|pred t|_1, ~|iszero t|_1
    \mid |t|_1 \in S_{i - 1}
  } \\
  & && \cup \Set{
    \If{|t|_1}{|t|_2}{|t|_3}
    \mid |t|_1, |t|_2, |t|_3 \in S_{i - 1}
  } \\
  &=&& S_i.
\end{alignat*}
\qed

\Ex{3.3.4}

\paragraph{Induction on depth or size}
Let $Q(n) = \Set{|s| \in S \mid \It{depth}(|s|) \le n}$.
We have $S = \bigcup_{n\in\N} Q(n)$.
Induction on depth implies that,
  given $P(|s|)$ holds for all $|s| \in Q(n)$,
  $P(|s|)$ holds for all $|s| \in Q(n + 1)$.
By induction on $n$, $P(|s|)$ holds for all $|s| \in S$.
Induction on size can be derived by replacing \It{depth} with \It{size}.

\paragraph{Structural induction}
Given $P(|s|)$ holds for all $|s| \in S_i$,
  we have $P(|t|)$ for
\begin{alignat*}{2}
  |t| &
  \in && ~\Set{|succ s|, ~|pred s|, ~|iszero s| \mid |s| \in S_i} \\
  & &&\cup \Set{\If{|s|_1}{|s|_2}{|s|_3} \mid |s|_1, |s|_2, |s|_3 \in S_i}
\end{alignat*}
by the induction hypothesis.
Together with constant terms, which all satisfy $P$ as they contain no subterms,
  we have $P(|t|)$ for all $|t| \in S_{i + 1}$.
We conclude that $P(|s|)$ holds for all $|s| \in S$ by induction on $i$.
\qed

\Ex{3.5.5}

If, for each derivation $D$, \\
\quad given $P(D')$ holds for all immediate subderivations $D'$ of $D$ \\
\quad we have $P(D)$, \\
then $P(D)$ holds for all $D$.

\Ex{3.5.10}

\begin{Proofs}
  \AxiomC{$|t| \to^* |t|$}
  \next
  \AxiomC{$|t| \to |t|'$}
  \UnaryInfC{$|t| \to^* |t|'$}
  \next
  \AxiomC{$|t| \to^* |t|'$}
  \AxiomC{$|t|' \to^* |t|''$}
  \BinaryInfC{$|t| \to^* |t|''$}
\end{Proofs}

\Ex{3.5.13}

\begin{enumerate}
  \item Theorems 3.5.7, 3.5.8, and 3.5.12 hold.
  \item Theorems 3.5.7, 3.5.8, 3.5.11, and 3.5.12 hold.
        The proof of Theorem 3.5.11 should be changed to not rely on Theorem 3.5.4
          (which does not hold anymore).
\end{enumerate}

\Ex{3.5.14}

We use induction on derivation as is done in Theorem 3.5.4.
Suppose we have $|t| \to |t|'$ and $|t| \to |t|''$.
If |t| is a conditional expression,
  then we repeat the discussion in the proof of Theorem 3.5.4
  to get $|t|' = |t|''$ using the induction hypothesis.
Otherwise, |t| is either a successor, predecessor, or zero test.

If $|t| = |succ s|$ for some term |s|,
  the last rule used to derive both $|t| \to |t|'$
  and $|t| \to |t|''$ is \Rule{E-Succ}.
We then have $|t|' = |succ s|'$ for some term $|s|'$,
  and the statement $|succ s| \to |succ s|'$ is derived from
  $|s| \to |s|'$.
Similarly, we have $|t|'' = |succ s|''$ for some term $|s|''$,
  and the statement $|succ s| \to |succ s|''$ is derived from
  $|s| \to |s|''$.
We now have $|s| \to |s|'$ and $|s| \to |s|''$,
  and then we get $|s|' = |s|''$ by the induction hypothesis.
It implies $|t|' = |succ s|' = |succ s|'' = |t|''$.

If $|t| = |pred s|$ for some term |s|,
  the last rules used to derive
  $|t| \to |t|'$ and $|t| \to |t|''$ are
  either \Rule{E-PredZero}, \Rule{E-PredSucc}, or \Rule{E-Pred}.
These rules do not \emph{overlap},
  i.e., if $|t| \to |t|'$ is derived from one of the rules,
  then $|t| \to |t|''$ is also derived from the same rule.
To see this,
  we need to check if the left hand side $|pred t|_1$ of the statement
  derived by \Rule{E-Pred} does not conflict with the left hand side
  $|pred succ nv|_1$ of \Rule{E-PredSucc}.
Assume they conflict.
We then, for some $|t|'_1$,
  have $|pred succ nv|_1 \to |pred t|'_1$
  derived by \Rule{E-Pred}.
The premise of this one-step derivation is $|succ nv|_1 \to |t|'_1$.
The rule \Rule{E-Succ} is the only rule that may derive this statement,
  with which we have $|nv|_1 \to |t|'_2$ for some $|t|'_2$.
It contradicts with the fact that $|nv|_1$ is a normal form.
Therefore, we have shown that these three rules do not conflict with eath other.
Within these cases,
  \Rule{E-PredZero} and \Rule{E-PredSucc} both have a numeric value
  on the right hand side of the derived statement,
  and thus we have $|t|' = |t|''$.
For \Rule{E-Pred},
  we repeat the same discussion as \Rule{E-Succ} to get
  $|t|' = |t|''$ by the induction hypothesis.

If $|t| = |iszero s|$ for some term |s|,
  a similar discussion is applied as the previous case of $|t| = |pred s|$,
  where the three rules are replaced with
  \Rule{E-IsZeroZero}, \Rule{E-IsZeroSucc}, and \Rule{E-IsZero},
  and we handle boolean values instead of numeric ones in some places. \qed

\Ex{3.5.16}

\begin{itemize}
  \item[(1)]
    \textsc{Proposition}:
    Let |t| be any arithmetic expression.
    If |t| is evaluated to a value,
      then it is evaluated to the same value in the augmented language.
    The term |t| is evaluated to a stuck state
      iff it is evaluated to |wrong| in the augmented language.
  \item[(2)] 
    \Proof:
    Note first that the augmented evaluation rules are deterministic,
      since the added rules do not conflict with existing ones and with each other.
    Since the augmented language accomodates all the evaluation rules that
      the original language have,
      any expression evaluated to a value in the original language
      is evaluated by the same derivation to the same value in the augmented one.
    Assume |t| is evaluated to a stuck state in the original language.
    Then, the term |t| is in an either form of the left hand side of
      the added rules.
    Therefore, it is evaluated to |wrong| in the augmented language.
    Conversely, assume |t| is evaluated to |wrong| in the augmented language.
    Since |t| is an arithmetic expression,
      it is not |wrong| itself,
      and thus is the result of an evaluation by one of the added rules.
    The left hand side of each added rule is a normal form in the original language,
      and thus is a stuck state. \qed
\end{itemize}

\Ex{3.5.17}

First, we show $|t| \Bigstep |v|$ given $|t| \to^* |v|$
  by induction on the number of small steps consisting $|t| \to^* |v|$.
If there are zero steps, i.e., $|t| = |v|$,
  then it holds that $|t| \Bigstep |v|$ by \Rule{B-Value}.
Consider the general case.
By the induction hypothesis,
  there exists a term $|t|'$ that satisfies
  $|t| \to |t|'$,
  $|t|' \to^* |v|$,
  and $|t|' \Bigstep |v|$.
Then $|t| \Bigstep |v|$ is shown by examining all the cases for
  the direct derivation of $|t| \to |t|'$.
For example, if it is derived by \Rule{E-IfTrue},
  |t| is written as $|t| = \If{|true|}{|t|'}{|t|''}$.
We have $|true| \Bigstep |true|$ by \Rule{B-Value}
  and $|t|' \Bigstep |v|$ by the hypothesis.
By applying \Rule{B-IfTrue} to them,
  we obtain $\If{|true|}{|t|'}{|t|''} \Bigstep |v|$.
Another example: if it is derived by \Rule{E-If},
  |t| and $|t|'$ are written as
  $|t| = \If{|t|_1}{|t|_2}{|t|_3}$ and
  $|t|' = \If{|t|'_1}{|t|'_2}{|t|'_3}$, respectively.
We also have $|t|_1 \to |t|'_1$.
Since $|t|' \to^* |v|$,
  it holds that $|t|'_1 \to^* |v|_1$ with $|v|_1 \in \{|true|, |false|\}$.
We thus obtain $|t|_1 \to^* |v|_1$.
Suppose $|v|_1 = |true|$.
Then, in the same way, we obtain $|t|_2 \to^* |v|$.
By the induction hypothesis,
  we have $|t|_1 \Bigstep |true|$ and $|t|_2 \Bigstep |v|$.
By applying \Rule{B-IfTrue},
  we get $\If{|t|_1}{|t|_2}{|t|_3} \Bigstep |v|$.
Almost same discussions apply for the case of $|v|_1 = |false|$.
The other cases also follow in a similar manner.

Next, we show $|t| \to^* |v|$ given $|t| \Bigstep |v|$
  by induction on derivation of $|t| \Bigstep |v|$.
When $|t| = |v|$, it obviously holds that $|v| \to^* |v|$.
Induction step is made by examining all the evaluation rules except for \Rule{B-Value}.
For example, if the last step is \Rule{B-IfTrue},
  we have $|t| = \If{|t|_1}{|t|_2}{|t|_3}$
  with $|t|_1 \Bigstep |true|$ and $|t|_2 \Bigstep |v|$.
By the induction hypothesis,
  we have $|t|_1 \to^* |true|$ and $|t|_2 \to^* |v|$.
By applying \Rule{E-If} multiple times with premises given by
  individual small steps consisting $|t|_1 \to^* |true|$,
  we obtain
  $\If{|t|_1}{|t|_2}{|t|_3} \to^* \If{|true|}{|t|_2}{|t|_3}$.
Next, we apply \Rule{E-IfTrue} to the right hand side to obtain
  $\If{|t|_1}{|t|_2}{|t|_3} \to^* |t|_2$.
Combining it with $|t|_2 \to^* |v|$,
  we get $\If{|t|_1}{|t|_2}{|t|_3} \to^* |v|$.
Similar discussions are applied to the other cases. \qed

\Ex{3.5.18}

The evaluation rules involving |if| expression is modified as follows.
\begin{Proofs}
  \AxiomC{$\If{|true|}{|v|_1}{|v|_2} \to |v|_1$}
  \next
  \AxiomC{$\If{|false|}{|v|_1}{|v|_2} \to |v|_2$}
  \next
  \AxiomC{$|t|_2 \to |t|'_2$}
  \UnaryInfC{$\If{|t|_1}{|t|_2}{|t|_3} \to
              \If{|t|_1}{|t|'_2}{|t|_3}$}
  \next
  \AxiomC{$|t|_2 \to |t|'_2$}
  \UnaryInfC{$\If{|t|_1}{|v|}{|t|_2} \to
              \If{|t|_1}{|v|}{|t|'_2}$}
\end{Proofs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 4.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An ML Implementation of Arithmetic Expressions}

Rust implementation is put at |src/bin/arith.rs|.

\Ex{4.2.1}
Omitted since I cannot talk about a good programming style in ML.

\Ex{4.2.2}
Omitted.
It can be implemented by fully evaluating arguments of each expression recursively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 5.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Untyped Lambda-Calculus}

\Ex{5.2.1}
\begin{Code}
  or  = $\Ab{bc}$ b tru c;
  not = $\Ab b$ b fls tru;
\end{Code}

\Ex{5.2.2}
\begin{Code}
  scc = $\Ab{nsz}$ n s (s z);
\end{Code}

\Ex{5.2.3}
\begin{Code}
  times$'$ = $\Ab{mns}$ m (n s);
\end{Code}
For example, $3 \times 2$ is evaluated as follows.
\begin{Code}
     times$'$ c$_3$ c$_2$ s z
  $=$   ($\Ab{mn{s'}{z'}}$ m (n s$'$) z$'$) c$_3$ c$_2$ s z
  $\to$ ($\Ab{n{s'}{z'}}$ c$_3$ (n s$'$) z$'$) c$_2$ s z
  $\to$ ($\Ab{{s'}{z'}}$ c$_3$ (c$_2$ s$'$) z$'$) s z
  $\to$ ($\Ab{{z'}}$ c$_3$ (c$_2$ s) z$'$) z
  $\to$ c$_3$ (c$_2$ s) z
  $=$   c$_3$ (($\Ab{{s'}{z'}}$ s$'$ (s$'$ z$'$)) s) z
  $\to$ c$_3$ ($\Ab{{z'}}$ s (s z$'$)) z
  $=$   ($\Ab{{s'}{z'}}$ s$'$ (s$'$ (s$'$ z$'$))) ($\Ab{{z'}}$ s (s z$'$)) z
  $\to$ ($\Ab{{z'}}$ ($\Ab{{z''}}$ s (s z$''$)) (($\Ab{{z''}}$ s (s z$''$)) (($\Ab{{z''}}$ s (s z$''$)) z$'$))) z
  $\to$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) z))
  $\to$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) (s (s z)))
  $\to$ ($\Ab{{z'}}$ s (s z$'$)) (s (s (s (s z))))
  $\to$ s (s (s (s (s (s z)))))
\end{Code}

\Ex{5.2.4}

There are at least two ways to define a power function.
\begin{Code}
  pow = $\Ab{mn}$ m (times n) c$_1$;
  pow$'$ = $\Ab{mn}$ m n;
\end{Code}
The first one is analogous to the definition of |times|.
The second one is simpler but trickier.
Here, an application of $|pow|'$ is evaluated as
\begin{align*}
  |pow|' \App |c|_m \App |c|_n \App |s z|
  \to |c|_m \App |c|_n \App |s z|
  \to \underbrace{|c|_n \App |(c|_n \App |(|\cdots|(c|_n}_m \CdSpc |s)| \cdots |))| \App |z|.
\end{align*}
Then, applying $|c|_n$ once multiplies the number of occurences of |s| by $n$.
Since it happens $m$ times, it results in $n^m$ occurences of |s| in total.

For example, $2^3$ is evaluated as follows.
\begin{Code}
     pow$'$ c$_3$ c$_2$ s z
  $=$   ($\Ab{mn}$ m n) c$_3$ c$_2$ s z
  $\to$ ($\Ab n$ c$_3$ n) c$_2$ s z
  $\to$ c$_3$ c$_2$ s z
  $=$   ($\Ab{{s'}{z'}}$ s$'$ (s$'$ (s$'$ z$'$))) c$_2$ s z
  $\to$ ($\Ab{{z'}}$ c$_2$ (c$_2$ (c$_2$ z$'$))) s z
  $\to$ c$_2$ (c$_2$ (c$_2$ s)) z
  $=$   c$_2$ (c$_2$ (($\Ab{{s'}{z'}}$ s$'$ (s$'$ z$'$)) s)) z
  $\to$ c$_2$ (c$_2$ ($\Ab{{z'}}$ s (s z$'$))) z
  $=$   c$_2$ (($\Ab{{s''}{z''}}$ s$''$ (s$''$ z$''$)) ($\Ab{{z'}}$ s (s z$'$))) z
  $\to$ c$_2$ ($\Ab{{z''}}$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) z$''$)) z
  $=$   ($\Ab{{s''}{z'''}}$ s$''$ (s$''$ z$'''$))
        ($\Ab{{z''}}$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) z$''$)) z
  $\to$ ($\Ab{{z'''}}$
        ($\Ab{{z''}}$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) z$''$))
        (($\Ab{{z''}}$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) z$''$)) z$'''$)
     ) z
  $\to$ ($\Ab{{z''}}$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) z$''$))
        (($\Ab{{z''}}$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) z$''$)) z)
  $\to$ ($\Ab{{z''}}$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) z$''$))
        (($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) z))
  $\to$ ($\Ab{{z''}}$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) z$''$))
        (($\Ab{{z'}}$ s (s z$'$)) (s (s z)))
  $\to$ ($\Ab{{z''}}$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) z$''$)) (s (s (s (s z))))
  $\to$ ($\Ab{{z'}}$ s (s z$'$)) (($\Ab{{z'}}$ s (s z$'$)) (s (s (s (s z)))))
  $\to$ ($\Ab{{z'}}$ s (s z$'$)) (s (s (s (s (s (s z))))))
  $\to$ (s (s (s (s (s (s (s (s z))))))))
\end{Code}

\Ex{5.2.5}
\begin{Code}
  subtract = $\Ab{mn}$ n prd m;
\end{Code}
It reads "apply |prd| for |n| times to |m|".

\Ex{5.2.6}
Full evaluation of |prd| |c|$_n$ involves applications of |ss|
  $n$ times starting from $|pair c|_0|\ c|_0$ and selecting |fst|.
The evaluation thus completes in $O(n)$ steps.

\Ex{5.2.7}
\begin{Code}
  equal = $\Ab{mn}$ and (iszro (m prd n)) (iszro (n prd m));
\end{Code}

\Ex{5.2.8}
\begin{Code}
  nil   = $\Ab{cn}$ n;
  cons  = $\Ab{htcn}$ c h (t c n);
  isnil = $\Ab t$ t ($\Ab{xy}$ fls) tru;
  head  = $\Ab t$ t ($\Ab{xy}$ x) nil;
\end{Code}
Here, we use |nil| for the default value of |head| when the argument is
  |nil|.

A |tail| function can be defined by copying a list into another list,
  simultaneously bookkeeping the list in the previous step using a pair.
\begin{Code}
  dcons = $\Ab{hp}$ pair (snd p) (cons h (snd p));
  tail  = $\Ab t$ fst (t dcons (pair nil nil));
\end{Code}

\Ex{5.2.9}
In the main text,
  |if| is used instead of |test| to avoid evaluating unused branches,
  which otherwise makes the evaluation diverge.
To use |test|,
  we need to prevent the unused branches from being evaluated
  by hiding the branches behind lambda abstractions and evaluating it later.
A dummy value $|c|_0$ is used to evaluate the lazy function.
\begin{Code}
  g$'$ = $\Ab{{{fct}}n}$
      test (iszro n) ($\Ab x$ c$_1$) ($\Ab x$ times n (fct (prd n) c$_0$)) c$_0$;
  factorial$'$ = fix g$'$;
\end{Code}

\Ex{5.2.10}
\begin{Code}
  churchnat = fix ($\Ab{fn}$
      if iszero n then c$_0$ else scc (f (pred n)))
\end{Code}

\Ex{5.2.11}
\begin{Code}
  sum = fix ($\Ab{fl}$ test (isnil l)
                          ($\Ab x$ c$_0$)
                          ($\Ab x$ plus (head l) (f (tail l) c$_0$)))
\end{Code}

\Ex{5.3.3}
We prove it by induction on term size.
Iff |t| is a varaible, it holds that $\It{size}(|t|) = 1 = \Cardi{FV(|t|)}$.
Suppose |t| is a non-variable term.
There are two cases.
\begin{enumerate}
  \item If $|t| = \Ab x |t|_1$, it holds that
      $\Cardi{FV(|t|)} \le \Cardi{FV(|t|_1)}$ and
      $\It{size}(|t|) = \It{size}(|t|_1) + 2$.
    By the induction hypothesis, we have $\Cardi{FV(|t|_1)} \le \It{size}(|t|_1)$.
    Combining them gives
      $\Cardi{FV(|t|)} \le \Cardi{FV(|t|_1)} \le \It{size}(|t|_1) \le \It{size}(|t|)$.
  \item Otherwise, |t| is written as $|t| = |t|_1 |\ t|_2$.
    It holds that $\Cardi{FV(|t|)} \le \Cardi{FV(|t|_1)} + \Cardi{FV(|t|_2)}$
      and $\It{size}(|t|) = \It{size}(|t|_1) + \It{size}(|t|_2) + 1$.
    By the induction hypothesis, we have
      $\Cardi{FV(|t|_1)} \le \It{size}(|t|_1)$ and $\Cardi{FV(|t|_2)} \le \It{size}(|t|_2)$.
    Combining them gives
      $\Cardi{FV(|t|)} \le \It{size}(|t|_1) + \It{size}(|t|_2) < \It{size}(|t|)$.
\end{enumerate}
\qed

\Ex{5.3.6}

\paragraph{Full beta-reduction}
Syntax is not changed (indeed, the category of values is not used).
Evaluation rules are as follows.
\begin{Proofs}
  \AxiomC{$|t|_1 \to |t|'_1$}
  \UnaryInfC{$|t|_1 \App |t|_2 \to |t|'_1 \App |t|_2$}
  \nexth
  \AxiomC{$|t|_2 \to |t|'_2$}
  \UnaryInfC{$|t|_1 \App |t|_2 \to |t|_1 \App |t|'_2$}
  \nexth
  \AxiomC{$|t| \to |t|'$}
  \UnaryInfC{$\Ab x |t| \to \Ab x |t|'$}
  \nexth
  \AxiomC{$\CParen{\Ab x |t|_1} \App |t|_2 \to [|x| \mapsto |t|_2] |t|_1$}
\end{Proofs}

\paragraph{Normal order}
Syntax is changed as follows.
\begin{Code}
  $\dots$
  nf $::=$
        $\Ab x$ nf
        nanf
  nanf $::=$
        x
        nanf nf
  na $::=$
        x
        t t
\end{Code}
Evaluation rules are as follows.
\begin{Proofs}
  \AxiomC{$|na|_1 \to |na|'_1$}
  \UnaryInfC{$|na|_1 \App |t|_2 \to |na|'_1 \App |t|_2$}
  \nexth
  \AxiomC{$|t|_2 \to |t|'_2$}
  \UnaryInfC{$|nanf|_1 \App |t|_2 \to |nanf|_1 \App |t|'_2$}
  \nexth
  \AxiomC{$|t| \to |t|'$}
  \UnaryInfC{$\Ab x |t| \to \Ab x |t|'$}
  \nexth
  \AxiomC{$\CParen{\Ab x |t|_1} \App |t|_2 \to [|x| \mapsto |t|_2] |t|_1$}
\end{Proofs}

\paragraph{Lazy evaluation}
Syntax is not changed. Evaluation rules are as follows.
\begin{Proofs}
  \AxiomC{$|t|_1 \to |t|'_1$}
  \UnaryInfC{$|t|_1 \App |t|_2 \to |t|'_1 \App |t|_2$}
  \nexth
  \AxiomC{$\CParen{\Ab x |t|_1} \App |t|_2 \to [|x| \mapsto |t|_2] |t|_1$}
\end{Proofs}

\Ex{5.3.7}
Add the following syntactic categories to \LambdaNB.
\begin{Code}
  badnat $::=$
        wrong
        true
        false
        $\Ab x$ t

  badbool $::=$
        wrong
        nv
        $\Ab x$ t

  badabs $::=$
        wrong
        true
        false
        nv
\end{Code}
Augment the evaluation relation with the following rules.
\begin{Proofs}
  \AxiomC{$\If{|badbool|}{|t|_1}{|t|_2} \to |wrong|$}
  \next
  \AxiomC{$|succ badnat| \to |wrong|$}
  \next
  \AxiomC{$|pred badnat| \to |wrong|$}
  \next
  \AxiomC{$|iszero badnat| \to |wrong|$}
  \next
  \AxiomC{$|badabs| ~|t| \to |wrong|$}
\end{Proofs}

\Ex{5.3.8}
\begin{Proofs}
  \AxiomC{$\Ab x |t| \Bigstep \Ab x |t|$}
  \nexth
  \AxiomC{$|t|_1 \Bigstep \Ab x |t|'_1$}
  \AxiomC{$|t|_2 \Bigstep |v|_2$}
  \AxiomC{$[|x| \mapsto |v|_2] |t|'_1 \Bigstep |v|_3$}
  \TrinaryInfC{$|t|_1 \App |t|_2 \Bigstep |v|_3$}
\end{Proofs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 6.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Nameless Representation of Terms}

\Ex{6.1.1}
\begin{Code}
  c$_0$    = $\Abn2$ 0;
  c$_2$    = $\Abn2$ 1 (1 0);
  plus = $\Abn4$ 3 1 (2 0 1);
  fix  = $\Abn1$ ($\Abn1$ 1 ($\Abn1$ (1 1) 0)) ($\Abn1$ 1 ($\Abn1$ (1 1) 0));
  foo  = ($\Abn1$ ($\Abn1$ 0)) ($\Abn1$ 0);
\end{Code}


\Ex{6.1.4}
Define a family of sets $S_{ni}, ~n, i \in \N$ inductively as follows.
\begin{align*}
  S_{n,0} &= \Set{0, \dots, n - 1}, ~n \in \N, \\
  S_{ni} &= S_{n, i - 1}
         \cup \Set{\Abn1 |t| \mid |t| \in S_{n + 1, i - 1}}
         \cup \Set{\CParen{|t|_1 \App |t|_2} \mid |t|_1, |t|_2 \in S_{n, i - 1}}, \\
         & \hspace{20em} n \in \N, ~i \in \N \setminus \Set{0}
\end{align*}
Then, define a family of sets
  $\cS = \Set{\cS_0, \cS_1, \cS_2, \dots}$ by
  $\cS_n = \bigcup_i S_{ni}, ~n \in \N$.
Each set $\cS_n$ in this family coincides with $\cT_n$.

\Proof:
We first prove $S_{ni} \subseteq \cT_n$ for all $n$ by induction on $i$.
By definition, it holds $S_{n, 0} \subseteq \cT_n$.
For $i>0$, suppose $|t| \in S_{ni}$.
There are three cases to consider.
\begin{itemize}
  \item If $|t| \in S_{n, i - 1}$, by the induction hypothesis,
      we have $|t| \in \cT_n$.
  \item If $|t| = \Abn1 |s|$ for some $|s| \in S_{n + 1, i - 1}$,
      by the induction hypothesis, we have $|s| \in \cT_{n + 1}$.
    Following \textsc{Definition 6.1.2.2},
      we obtain $|t| = \in \cT_{n}$.
  \item Otherwise, we can write $|t| = \CParen{|s|_1 \App |s|_2}$
      for some $|s|_1, |s|_2 \in S_{n, i - 1}$.
    By the induction hypothesis, we have $|s|_1, |s|_2 \in \cT_n$.
    Following \textsc{Definition 6.1.2.3},
      we obtain $|t| \in \cT_n$.
\end{itemize}
Therefore, $S_{ni} \subseteq \cT_n$ holds for all $n, i$.
We thus obtain $\cS_n = \bigcup_i S_{ni} \subseteq \cT_n$.

Next, we prove $\cT_n \subseteq \cS_n$ for all $n$.
To prove it, we show that
  the three conditions of \textsc{Definition 6.1.2} hold
  when replacing $\cT_n$ with $\cS_n$.
Then, by the minimality of $\cT_n$, we get $\cT_n \subseteq \cS_n$.
\begin{enumerate}
  \item By definition, it holds that $|k| \in S_{n,0} \subseteq \cS_n$
      whenever $0 \le |k| < n$.
  \item If $|t| \in \cS_n$, there exists $i$ such that $|t| \in S_{ni}$.
    By definition, it holds $\Abn1 |t| \in S_{n - 1, i + 1} \subseteq \cS_{n - 1}$.
  \item If $|t|_1, |t|_2 \in \cS_n$,
      there exist $i_1, i_2$ such that $|t|_1 \in S_{ni_1}$ and $|t|_2 \in S_{ni_2}$.
    Let $i = \max\Set{i_1, i_2}$,
      then we have $|t|_1, |t|_2 \in S_{ni}$.
    By definition, we have $\CParen{|t|_1 \App |t|_2} \in S_{n, i + 1} \subseteq \cS_n$.
\end{enumerate}
\qed

\Ex{6.1.5}
\begin{enumerate}
  \item
    \begin{alignat*}{2}
      &\RemoveNames_\Gamma(|x|) &&= (\text{index of the rightmost |x| in } \Gamma), \\
      &\RemoveNames_\Gamma(\Ab x |s|) &&= \Abn1 \RemoveNames_{\Gamma, |x|}(|s|), \\
      &\RemoveNames_\Gamma(|t|_1 \App |t|_2)
        &&= \RemoveNames_\Gamma(|t|_1) \CdSpc \RemoveNames_\Gamma(|t|_2).
    \end{alignat*}
  \item Let $\It{newname}(\Gamma)$ be
      the first variable name in $\cV \setminus \Dom(\Gamma)$.
    \begin{alignat*}{3}
      &\RestoreNames_\Gamma(|k|)
        &&= |x|_{|k|}
        && \Where \Gamma = |x|_n, \dots, |x|_0, \\
      &\RestoreNames_\Gamma(\Abn1 |s|)
        &&= \Ab x \RestoreNames_{\Gamma, |x|}(|s|)
        && \Where |x| = \It{newname}(\Gamma), \\
      &\RestoreNames_\Gamma(|t|_1 \App |t|_2)
        &&= \RestoreNames_\Gamma(|t|_1) \CdSpc \RestoreNames_\Gamma(|t|_2). &&
    \end{alignat*}
\end{enumerate}

\Ex{6.2.2}
\begin{enumerate}
  \item $\DShift^2(\Abn2 |\ 1 (0 2)|) = \Abn2 |\ 1 (0 4)|$.
  \item
    $\DShift^2(\Abn1 |\ 0 1\ | \CParen{\Abn1 |\ 0 1 2|})
     = \Abn1 |\ 0 3\ |\CParen{\Abn1 |\ 0 1 4|}$.
\end{enumerate}

\Ex{6.2.3}
We show it by structural induction.

If |t| is a variable, then $\DShift_c^d(|t|)$ is a $(n + d)$-term by definition.

If |t| is written as $|t| = \Abn1 |t|_1$, 
  $|t|_1$ is an $(n + 1)$-term.
By the induction hypothesis, $\DShift_{c+1}^d(|t|_1)$ is an $(n + d + 1)$-term.
Therefore,
  $\DShift_c^d(\Abn1 |t|_1) = \Abn1 \DShift_{c+1}^d(|t|_1)$ is an $(n + d)$-term.

If |t| is written as $|t| = |t|_1 \App |t|_2$,
  $|t|_1$ and $|t|_2$ are both $n$-terms.
By the induction hypothesis,
  $\DShift_c^d(|t|_1)$ and $\DShift_c^d(|t|_2)$ are $(n + d)$-terms.
Therefore,
  $\DShift_c^d(|t|_1 \App |t|_2) = \DShift_c^d(|t|_1) \CdSpc \DShift_c^d(|t|_2)$
  is an $(n + d)$-term. \qed

\Ex{6.2.5}
\begin{enumerate}
  \item \begin{align*}
      [|0| \mapsto |1|] \CParen{|0| \App \CParen{\Abn2 |2|}}
      &= |1| \App \CParen{[|0| \mapsto |1|] \Abn2 |2|} \\
      &= |1| \App \CParen{\Abn2 [|2| \mapsto |3|] |2|} \\
      &= |1| \App \CParen{\Abn2 |3|}
  \end{align*}
  \item \begin{align*}
      [|0| \mapsto |1| \App \CParen{\Abn1 |2|}] \CParen{|0| \App \CParen{\Abn1 |1|}}
      &= |1| \App \CParen{\Abn1 |2|} \App \CParen{[|0| \mapsto |1| \App \CParen{\Abn1 |2|}] \Abn1 |1|} \\
      &= |1| \App \CParen{\Abn1 |2|} \App \CParen{\Abn1 [|1| \mapsto |2| \App \CParen{\Abn1 |3|}] |1|} \\
      &= |1| \App \CParen{\Abn1 |2|} \App \CParen{\Abn1 |\ 2| \App \CParen{\Abn1 |3|}}.
  \end{align*}
  \item \begin{align*}
      [|0| \mapsto |1|] \CParen{\Abn1 |\ 0 2|}
      &= \Abn1 \CdSpc [|1| \mapsto |2|] |0 2| \\
      &= \Abn1 |\ 0 2|.
  \end{align*}
  \item \begin{align*}
      [|0| \mapsto |1|] \CParen{\Abn1 |\ 1 0|}
      &= \Abn1 [|1| \mapsto |2|] |1 0| \\
      &= \Abn1 |\ 2 0|.
  \end{align*}
\end{enumerate}

\Ex{6.2.6}
We show it by structural induction on |t|.

If |t| is a variable,
  $[|j| \mapsto |s|] |t|$ is |s| if $|j| = |t|$
  or |t| otherwise.
In either case, it is an $n$-term.

If $|t| = \Abn1 |t|_1$,
  we have $[|j| \mapsto |s|] |t|
           = \Abn1 [|j| + 1 \mapsto \DShift^1(|s|)] |t|_1$.
Since both $|t|_1$ and $\DShift^1(|s|)$ are $(n + 1)$-terms and $|j| + 1 \le n + 1$,
  by the induction hypothesis,
  $[|j| + 1 \mapsto \DShift^1(|s|)] |t|_1$ is an $(n + 1)$-term.
Therefore, $\Abn1 [|j| + 1 \mapsto \DShift^1(|s|)] |t|_1$ is an $n$-term.

Otherwise, we can write $|t| = |t|_1 |\ t|_2$.
In this case, both $|t|_1$ and $|t|_2$ are $n$-terms,
  and $[|j| \mapsto |s|] |t|
        = \CParen{[|j| \mapsto |s|] |t|_1} \App \CParen{[|j| \mapsto |s|] |t|_2}$.
By the induction hypothesis,
  both terms in the right hand side are $n$-terms,
  and thus the right hand side as a whole is also an $n$-term.
\qed

\Ex{6.2.7}
Omitted.

\Ex{6.2.8}
\Theorem:
Let $\Gamma$ be any naming context.
We overload the notation $\RemoveNames_\Gamma(|x|)$ for a variable |x| to
  denote the index of |x| in $\Gamma$ counting from the right.
Then, $\RemoveNames_\Gamma$ commutes with substitution;
  i.e., for any ordinary terms |t|, |s|, and variable |x|,
  \begin{equation}
    \RemoveNames_\Gamma([|x| \mapsto |s|] |t|)
    = [\RemoveNames_\Gamma(|x|) \mapsto \RemoveNames_\Gamma(|s|)]
      \RemoveNames_\Gamma(|t|).
      \label{eq:6.2.8}
  \end{equation}

{
\newcommand\Rem{\It{rem}}
\Proof:
Abbreviate $\RemoveNames_\Gamma$ by $\Rem_\Gamma$.
We prove it by structural induction on |t|.

If $|t| = |x|$, the both sides of Eq. \ref{eq:6.2.8} are $\Rem_\Gamma(|s|)$.

If $|t| = |y| \neq |x|$,
  we also have $\Rem_\Gamma(|x|) \neq \Rem_\Gamma(|y|)$,
  so the both sides of Eq. \ref{eq:6.2.8} are $\Rem_\Gamma(|y|)$.

If $|t| = \Ab y |t|_1$ where $|y| \neq |x|$ and $|y| \notin \FV(|s|)$,
  we have
\[
  \Rem_\Gamma([|x| \mapsto |s|] \CParen{\Ab y |t|_1})
   = \Rem_\Gamma(\Ab y [|x| \mapsto |s|] |t|_1) \\
   = \Abn1 \Rem_{\Gamma, |y|}([|x| \mapsto |s|] |t|_1).
\]
By the induction hypothesis,
  the rightmost side is
\[
  \Abn1 [\Rem_{\Gamma, |y|}(|x|) \mapsto \Rem_{\Gamma, |y|}(|s|)]
         \Rem_{\Gamma, |y|}(|t|_1).
\]
Since $|y| \notin \FV(|s|) \cup \Set{|x|}$,
  $\Rem_{\Gamma, |y|}(|x|) = \Rem_\Gamma(|x|) + 1$ and
  $\Rem_{\Gamma, |y|}(|s|) = \DShift^1 \Rem_\Gamma(|s|)$.
Therefore, the above term is
\[
  [\Rem_\Gamma(|x|) \mapsto \Rem_\Gamma(|s|)]
    \Abn1 \Rem_{\Gamma, |y|}(|t|_1)
  = [\Rem_\Gamma(|x|) \mapsto \Rem_\Gamma(|s|)]
     \Rem_\Gamma(\Ab y |t|_1).
\]
This is equal to the right hand side of Eq. \ref{eq:6.2.8}.

Otherwise, $|t| = |t|_1 |\ t|_2$. We have
\begin{align*}
  \Rem_\Gamma([|x| \mapsto |s|] \CParen{|t|_1 \App |t|_2})
  &= \Rem_\Gamma(\CParen{[|x| \mapsto |s|] |t|_1} \App
                        \CParen{[|x| \mapsto |s|] |t|_2}) \\
  &= \Rem_\Gamma([|x| \mapsto |s|] |t|_1) \App
     \Rem_\Gamma([|x| \mapsto |s|] |t|_2).
\end{align*}
By the induction hypothesis, we have
\begin{align*}
  &\PhantomRel=
    \Rem_\Gamma([|x| \mapsto |s|] |t|_1) \App
    \Rem_\Gamma([|x| \mapsto |s|] |t|_2) \\
  &= \CParen{
       [\Rem_\Gamma(|x|) \mapsto \Rem_\Gamma(|s|)]
       \Rem_\Gamma(|t|_1)
     } \App \CParen{
       [\Rem_\Gamma(|x|) \mapsto \Rem_\Gamma(|s|)]
       \Rem_\Gamma(|t|_2)
     } \\
  &= [\Rem_\Gamma(|x|) \mapsto \Rem_\Gamma(|s|)]
     \CParen{\Rem_\Gamma(|t|_1) \App \Rem_\Gamma(|t|_2)} \\
  &= [\Rem_\Gamma(|x|) \mapsto \Rem_\Gamma(|s|)]
      \Rem_\Gamma(|t|_1 \App |t|_2).
\end{align*}
\qed
}

\Ex{6.3.1}
In the argument of $\DShift^{-1}$ in \Rule{E-AppAbs},
  the variable |0| is substituted away with $\DShift^1(|v|_2)$,
  which does not refer |0| due to the shift operator.
Therefore, the negative shift does not cause any ill-formed terms.

\Ex{6.3.2}
\Todo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 7.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An ML Implementation of the Lambda Calculus}
Rust implementation of |untyped| is put at |src/bin/untyped.rs|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 8.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Typed Arithmetic Expressions}

\Ex{8.2.3}
It immediately follows from 3, 5, 6, and 7 of \textsc{Lemma 8.2.2}.

\Ex{8.3.4}
We proceed by case analysis on the final rule in the evaluation derivation.

\Case\textsc{E-IfTrue}:
We have $|t| = \If{|true|}{|t|_1}{|t|_2} \to |t|_1$.
By the inversion lemma, we have $\TyRel{|t|_1}{|T|}$.
\textsc{E-IfFalse} case is similar.

\Case\textsc{E-If}:
We have $|t| = \If{|t|_1}{|t|_2}{|t|_3}$
  and $|t|' = \If{|t|'_1}{|t|_2}{|t|_3}$
  where $|t|_1 \to |t|'_1$.
Since $\TyRel{|t|}{|T|}$,
  we have $\TyRel{|t|_1}{|Bool|}$, $\TyRel{|t|_2}{|T|}$,
  and $\TyRel{|t|_3}{|T|}$ by the inversion lemma.
By the induction hypothesis, it holds that $\TyRel{|t|'_1}{|Bool|}$.
We thus conclude $\TyRel{|t|'}{|T|}$.

\Case\textsc{E-Succ}:
We have $|t| = |succ t|_1$ and $|t|' = |succ t|'_1$
  where $|t|_1 \to |t|'_1$.
It holds that $|T| = |Nat|$ and, by the inversion lemma,
  $\TyRel{|t|_1}{|Nat|}$.
We can derive $\TyRel{|t|'_1}{|Nat|}$ by the induction hypothesis.
Therefore, we conclude $\TyRel{|t|'}{|Nat|}$.
We can apply similar discussions to \Rule{E-Pred} and \Rule{E-IsZero}.

\Case\textsc{E-PredZero}:
It is obvious that $\TyRel{|pred 0|}{|Nat|}$ and $\TyRel{|0|}{|Nat|}$.
The other remaining cases immediately follow from the definition in the same way.
\qed

\Ex{8.3.5}
Simply removing \Rule{E-PredZero} breaks the progress property
  because, by $\TyRel{|0|}{|Nat|}$ and \Rule{T-Pred},
  we have $\TyRel{|pred 0|}{|Nat|}$,
  which could not be evaluated anymore.

\Ex{8.3.6}
This property does not hold.
For example, let $|t| = |if true then 0 else true|$,
  then $|t| \to |0|$ and $\TyRel{|0|}{|Nat|}$,
  while |t| is ill-typed.

\Ex{8.3.7}
\begin{itemize}
  \item If |t| is a well typed term, then |t| is evaluated to a value |v|, i.e.,
        $|t| \Bigstep |v|$.
  \item If $\TyRel{|t|}{|T|}$ and $|t| \Bigstep |v|$, then $\TyRel{|v|}{|T|}$.
\end{itemize}

\Ex{8.3.8}
Every term, either typed or untyped, is evaluated to some value,
  so the progress property trivially holds.
The preservation property also holds because |wrong| has no type
  and any typed term is not evaluated to a stuck state with the original rules,
  which indicates that such a term is not evaluated to |wrong| with the augmented
  ones.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 9.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simply Typed Lambda-Calculus}

\Ex{9.2.1}
The only type constructor of the pure simply typed lambda-calculus with no base types
  is $\to$,
  which requires two types as the arguments.
Therefore, there is no finite sequence of symbols that conform to the language of
  types,
  which means we cannot write any abstraction term with an argument type annotation.

\Ex{9.2.2}
1. Let $\Gamma = b$ be a typing context with only one binding
    $b = \TyRel{|f|}{|Bool| \to |Bool|}$.
\begin{Proofs}
  \AxiomC{$b \in \Gamma$}
  \RuleLabel{T-Var}
  \UnaryInfC{$\Ctx{\Gamma}{b}$}
  \AxiomC{} \RuleLabel{T-False} \UnaryInfC{$\CtxTyRel{\Gamma}{|false|}{|Bool|}$}
  \AxiomC{} \RuleLabel{T-True} \UnaryInfC{$\CtxTyRel{\Gamma}{|true|}{|Bool|}$}
  \AxiomC{} \RuleLabel{T-False} \UnaryInfC{$\CtxTyRel{\Gamma}{|false|}{|Bool|}$}
  \RuleLabel{T-If}
  \TrinaryInfC{$\CtxTyRel{\Gamma}{|if false then true else false|}{|Bool|}$}
  \RuleLabel{T-App}
  \BinaryInfC{$\CtxTyRel{\Gamma}{|f (if false then true else false)|}{|Bool|}$}
\end{Proofs}

2. Let $b = \TyRel{|f|}{|Bool| \to |Bool|}$ and $\Gamma = (b, \TyRel{|x|}{|Bool|})$.
\begin{Proofs}
  \AxiomC{$b \in \Gamma$}
  \RuleLabel{T-Var}
  \UnaryInfC{$\Ctx{\Gamma}{b}$}
  \AxiomC{$|x:Bool| \in \Gamma$}
    \RuleLabel{T-Var} \UnaryInfC{$\CtxTyRel{\Gamma}{|x|}{|Bool|}$}
  \AxiomC{} \RuleLabel{T-False} \UnaryInfC{$\CtxTyRel{\Gamma}{|false|}{|Bool|}$}
  \AxiomC{$|x:Bool| \in \Gamma$}
    \RuleLabel{T-Var} \UnaryInfC{$\CtxTyRel{\Gamma}{|x|}{|Bool|}$}
  \RuleLabel{T-If}
  \TrinaryInfC{
    $\CtxTyRel{\Gamma}{|if x then false else x|}{|Bool|}$
  }
  \RuleLabel{T-App}
  \BinaryInfC{
    $\CtxTyRel{\Gamma}{|f (if x then false else x)|}{|Bool| \to |Bool|}$
  }
  \RuleLabel{T-Abs}
  \UnaryInfC{
    $\CtxTyRel{b}{\AbTy{|x|}{|Bool|} \CdSpc |f (if x then false else x)|}{|Bool| \to |Bool|}$
  }
\end{Proofs}

\Ex{9.2.3}
An example is
  $
    \TyRel{|f|}{|Bool| \to |Bool| \to |Bool|},
    ~ \TyRel{|x|}{|Bool|},
    ~ \TyRel{|y|}{|Bool|}
  $.
Any such context is written as
  $
    \TyRel{|f|}{|T|_1 \to |T|_2 \to |Bool|},
    ~ \TyRel{|x|}{|T|_1},
    ~ \TyRel{|y|}{|T|_2}
  $
  where $|T|_1$ and $|T|_2$ are arbitrary types.

\Ex{9.3.2}
\textbf{No}.
\Proof:
Assume, for contradiction, that there exists a context $\Gamma$ and a type |T|
  such that $\CtxTyRel{\Gamma}{|x x|}{|T|}$.
By the inversion lemma,
  there is a type |S| that satisfies
  $\CtxTyRel{\Gamma}{|x|}{|S| \to |T|}$ and $\CtxTyRel{\Gamma}{|x|}{|S|}$.
By the inversion lemma again,
  it holds that $\TyRel{|x|}{|S| \to |T|} \in \Gamma$ and
  $\TyRel{|x|}{|S|} \in \Gamma$.
Since any environment can hold only one type binding for one variable,
  we can derive $|S| \to |T| = |S|$.
However, the sizes of the both hand sides do not match.
This contradicts to the equality.
\qed

\Ex{9.3.9}
We show it by induction on derivations of $\CtxTyRel{\Gamma}{|t|}{|T|}$.
We prove each induction step by case analysis of the derivation rule
  used at the last derivation step.

\Case\Rule{T-True}, \Rule{T-False}, and \Rule{T-Abs}:
In these cases, |t| is a value,
  so there is no evaluation rule that derives $|t| \to |t|'$ for any $|t|'$,
  and the statement vacuously holds.

\Case\Rule{T-If}:
In this case, we can write $|t| = \If{|t|_1}{|t|_2}{|t|_3}$
  with subderivations of
  $\CtxTyRel{\Gamma}{|t|_1}{|Bool|}$,
  $\CtxTyRel{\Gamma}{|t|_2}{|T|}$, and
  $\CtxTyRel{\Gamma}{|t|_3}{|T|}$.
We show this case by case analysis of the evaluation rule applied to $|t|$.
\begin{itemize}
  \item \Case\Rule{E-IfTrue}:
    In this case, we have $|t|_1 = |true|$ and $|t| \to |t|_2$.
    By the uniqueness of evaluation, it holds $|t|' = |t|_2$.
    We then immediately obtain $\CtxTyRel{\Gamma}{|t|'}{|T|}$.
  \item \Case\Rule{E-IfFalse}: Similar as \Rule{E-IfTrue} case.
  \item \Case\Rule{E-If}:
    In this case, we have $|t|_1 \to |t|'_1$
      and $|t| \to \If{|t|'_1}{|t|_2}{|t|_3} = |t|'$.
    By the induction hypothesis, it holds $\CtxTyRel{\Gamma}{|t|'_1}{|Bool|}$.
    Therefore, we get $\CtxTyRel{\Gamma}{|t|'}{|T|}$.
\end{itemize}

\Case\Rule{T-Var}:
In this case,
  $|t| = |x|$ is a variable
  and therefore there is no evaluation rule that evaluates $|t|$.

\Case\Rule{T-App}:
In this case,
  we can write $|t| = |t|_1 \App |t|_2$
  with subderivations of
  $\CtxTyRel{\Gamma}{|t|_1}{|S| \to |T|}$ and
  $\CtxTyRel{\Gamma}{|t|_2}{|S|}$ for some type |S|.
There are three cases of the evaluation rule that derives $|t| \to |t|'$.
\begin{itemize}
  \item \Case\Rule{E-App1}:
    In this case, we have $|t|_1 \to |t|'_1$ and $|t| \to |t|'_1 \App |t|_2$.
    By the induction hypothesis,
      it holds $\CtxTyRel{\Gamma}{|t|'_1}{|S| \to |T|}$.
    By applying the typing rule \Rule{T-App} to
      this typing relation and $\CtxTyRel{\Gamma}{|t|_2}{|S|}$,
      we get $\CtxTyRel{\Gamma}{|t|'}{|T|}$.
  \item \Case\Rule{E-App2}:
    We can prove for this case similarly as \Rule{E-App1} case.
  \item \Case\Rule{E-AppAbs}:
    In this case,
      we can write $|t| = \CParen{\AbTy{|x|}{|S|} |t|_{12}} |v|_2$ and
      $|t|' = [|x| \mapsto |v|_2] |t|_{12}$.
    By the inversion lemma of typing relations,
      we have
      $\CtxTyRel{\Gamma}{\CParen{\AbTy{|x|}{|S|} |t|_{12}}}{|S| \to |T|}$
      and
      $\CtxTyRel{\Gamma}{|v|_2}{|S|}$.
    The former relation is derived by \Rule{T-Abs},
      with which we have $\CtxTyRel{\Gamma, |x:S|}{|t|_{12}}{|T|}$.
    By the substitution lemma,
      we get $\CtxTyRel{\Gamma}{[|x| \mapsto |v|_2] |t|_{12}}{|T|}$,
      which is what we wanted to prove.
      \qed
\end{itemize}

\Ex{9.3.10}
\textbf{No}.
For example,
  let $\Gamma = \TyRel{|y|}{|Bool| \to |Bool|}$
  and $|t| = \CParen{\AbTy{|x|}{|Bool|} |x|} \App |y|$.
Applying \Rule{E-AppAbs} yields
  $|t| \to |t|' = [|x| \mapsto |y|] |x| = |y|$.
Using \Rule{T-Var}, we can derive $\CtxTyRel{\Gamma}{|t|'}{|Bool| \to |Bool|}$.
However, it is obvious that |t| is not typed under $\Gamma$,
  so $\CtxTyRel{\Gamma}{|t|}{|Bool| \to |Bool|}$ does not hold.

\Ex{9.4.1}
|Bool|: \Rule{T-True} and \Rule{T-False} are the introduction rules,
  and \Rule{T-If} is the elimination rule.

|Nat|: \Rule{T-Zero} and \Rule{T-Succ} are the introduction rules,
  and \Rule{T-Pred} and \Rule{T-IsZero} are the elimination rules.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 10.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An ML Implementation of Simple Types}
Rust implementation is put at |src/bin/simplebool.rs|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 11.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simple Extensions}

\Ex{11.2.1}
Define $|t|_1 = |unit|$ and
\[
  |t|_{n + 1} = \CParen{
    \AbTy{|f|}{|Unit| \to |Unit|} ~|f (f unit)|
  } \App \CParen{
    \AbTy{|x|}{|Unit|} |t|_n
  }
\]
  for $n = 1, 2, \dots$.
It is obvious that the size of $|t|_n$ grows linearly with $n$.
Evaluation of $|t|_{n + 1}$ proceeds as follows.
\begin{alignat*}{2}
  && \quad &\PhantomRel\to |t|_{n + 1} \\
  &\EqComment{\Rule{E-AppAbs}} &&\to
    \CParen{\AbTy{|x|}{|Unit|} |t|_n} \App
    \CParen{ \CParen{\AbTy{|x|}{|Unit|} |t|_n} \App |unit|} \\
  &\EqComment{\Rule{E-AppAbs}} &&\to
    \CParen{\AbTy{|x|}{|Unit|} |t|_n} \App |t|_n \\
  &\EqComment{evaluate $|t|_n$} &&\to^*
    \CParen{\AbTy{|x|}{|Unit|} |t|_n} \App |unit| \\
  &\EqComment{\Rule{E-AppAbs}} &&\to |t|_n \\
  &\EqComment{evaluate $|t|_n$} &&\to^* |unit|.
\end{alignat*}
During the evaluation,
  $|t|_n$ is evaluated twice,
  so we can show by induction that the number of steps to evaluate $|t|_n$ is $O(2^n)$.
\qed

\Ex{11.3.2}{
\newcommand\Ctxx[3]{#2 \vdash^{#1} #3}
\newcommand\CtxxTyRel[4]{\Ctxx{#1}{#2}{\TyRel{#3}{#4}}}

Let $e : \lambda^E \to \lambda^I$ be the elaboration function.
We show for typing and evaluation both by induction on structure of |t|.

Typing rule:
\begin{Proofs}
  \AxiomC{$\CtxTyRel{\Gamma}{|t|_2}{|T|_2}$}
  \UnaryInfC{$\CtxTyRel{\Gamma}{\AbTy{|\_|}{|T|_1} |t|_2}{|T|_1 \to |T|_2}$}
\end{Proofs}
If $\CtxxTyRel E{\Gamma}{\AbTy{|\_|}{|T|_1} |t|_2}{|T|_1 \to |T|_2}$,
  it is derived from $\CtxxTyRel E{\Gamma}{|t|_2}{|T|_2}$.
By the induction hypothesis,
  it holds $\CtxxTyRel I{\Gamma}{e(|t|_2)}{|T|_2}$.
Choose a variable name |x| from the outside of $\Gamma$.
Then, weakining yields $\CtxxTyRel I{\Gamma, |x:T|_1}{e(|t|_2)}{|T|_2}$,
  from which we can derive
  $\CtxxTyRel I{\Gamma}{\AbTy{|x|}{|T|_1} e(|t|_2)}{|T|_1 \to |T|_2}$.

If $\CtxxTyRel I{\Gamma}{\AbTy{|x|}{|T|_1} e(|t|_2)}{|T|_1 \to |T|_2}$
  where $|x| \notin \Gamma$ and $|x| \notin \FV(|t|_2)$,
  it is derived from $\CtxxTyRel I{\Gamma, |x:T|_1}{e(|t|_2)}{|T|_2}$.
By the induction hypothesis,
  it holds $\CtxxTyRel E{\Gamma, |x:T|_1}{|t|_2}{|T|_2}$.
Since |x| does not appear in $|t|_2$ as a free variable,
  we can omit it from the context as $\CtxxTyRel E{\Gamma}{|t|_2}{|T|_2}$,
  from which we can derive
  $\CtxxTyRel E{\Gamma}{\AbTy{|\_|}{|T|_1} |t|_2}{|T|_1 \to |T|_2}$.

Evaluation rule:
\begin{Proofs}
  \AxiomC{$\CParen{\AbTy{|\_|}{|T|_{11}} |t|_{12}} \App |v|_2 \to |t|_{12}$}
\end{Proofs}
If $|t| \to_E |t|'$,
  we should only care about the case when |t| is written as
  $|t| = \CParen{\AbTy{|\_|}{|T|_{11}} |t|_{12}} \App |v|_2$,
  or otherwise $e(|t|) \to_I e(|t|')$ follows immediately from
  the induction hypothesis.
However, even this case is obvious as we have $|t|' = |t|_{12}$
  and, by choosing $|x| \notin \FV(|t|_{12})$,
  we can derive
  $
    e(|t|) = \CParen{\AbTy{|x|}{|T|_{11}} e(|t|_{12})} \App |v|_2
           \to_I e(|t|_{12})
           = e(|t|')
  $.

If $e(|t|) \to_I e(|t|')$,
  we again should only care about the case when $|t|$ is written as
  $|t| = \CParen{\AbTy{|\_|}{|T|_{11}} |t|_{12}} \App |v|_2$.
In this case,
  we have $e(|t|) = \CParen{\AbTy{|x|}{|T|_{11}} e(|t|_{12})} \App |v|_2$
  where the name |x| is chosen arbitrarily from the outside of $\FV(|t|_{12})$.
It is then derived that $e(|t|') = e(|t|_{12})$, while we have $|t| \to |t|_{12}$.
Note that this is what we can show; see the errata of the text.
}

\Ex{11.4.1}
\begin{itemize}
  \item[(1)]
    We can define a derived form as
      $|t as T| \EqDef \CParen{\AbTy{|x|}{|T|} |x|} \App |t|$.
    The evaluation and typing rules are derived directly from those of the
      inner language.
  \item[(2)]
    To delay the evalution of |t|, we define a derived form as follows.
    \[
      |t as T| \EqDef
        \CParen{\AbTy{|x|}{|Unit| \to |T|} ~|x unit|} \App
        \CParen{\AbTy{|\_|}{|Unit|} |t|}.
    \]
    The right hand side is evaluated as follows.
    \begin{alignat*}{2}
      &&\quad&\PhantomRel\to
        \CParen{\AbTy{|x|}{|Unit| \to |T|} ~|x unit|} \App
          \CParen{\AbTy{|\_|}{|Unit|} |t|} \\
      &\EqComment{\Rule{E-AppAbs}} &&\to \CParen{\AbTy{|\_|}{|Unit|} |t|} \App |unit| \\
      &\EqComment{\Rule{E-AppAbs}} &&\to |t|.
    \end{alignat*}
    Note that it requires two steps to evaluate the desugared form.
    Equivalence of typing is straightforward.
\end{itemize}

\Ex{11.5.1}
See |src/bin/lexexercise.rs| for
  a Rust implementation of a simply typed lambda-calculus with |unit| and |let|.
It includes an implementation of small-step evaluation and typing of
  let expressions.

\Ex{11.5.2}
I do not think this approach is a good idea because it breaks the evaluation order.
For example, it may cause the size of the desugared code to bloat up.
Consider the following code.
\begin{Code}
  let x = (
    let y = (
      let z = false
        in if true then z else z
    ) in if true then y else y
  ) in if true then x else x;
\end{Code}
Using the original derived form, this term is desugared into the following code:
\begin{Code}
  ($\Lm$x:Bool$\to$Bool. if true then x else x) (
    ($\Lm$y:Bool$\to$Bool. if true then y else y) (
      ($\Lm$z:Bool$\to$Bool. if true then z else z) false
    )
  )
\end{Code}
Evaluation proceeds by interleaved usages of \Rule{E-AbsApp} and \Rule{E-IfTrue},
  and any intermediate results are smaller than the original code.

If we use the derived form using substitution, it would be as follows:
\begin{Code}
  if true then (
    if true then (
      if true then false else false
    ) else (
      if true then false else false
    )
  ) else (
    if true then (
      if true then false else false
    ) else (
      if true then false else false
    )
  )
\end{Code}
It is obvious that the size of the code bloat up exponentially with the depth
  of the nested |let| expressions.
If we repeat this structure more times (say, of depth $n$),
  the size of the desugared code would grow exponentially, i.e., $O(2^n)$.

\Ex{11.8.1}
\[
  \Rcd{
    |l|_i |=| |v|_i \Indices{i \in 1 .. j - 1} |,| ~
    |l|_j |=| |v|_j |,| ~
    |l|_k |=| |v|_k \Indices{k \in j + 1 .. n}
  } |.l|_j
  \to |v|_j
\]

\Ex{11.8.2}
\begin{enumerate}
  \item We introduce \emph{pattern typing relations}
      with the following syntactic rule.
    \begin{Code}
  pt $::=$ p : T $\To$ $\Gamma$
    \end{Code}
    Pattern typing relations are derived by the following derivation rules.
    \begin{Proofs}
      \AxiomC{}
      \RuleLabel{PT-Var}
      \UnaryInfC{$\TyRel{|x|}{|T|} \To \TyRel{|x|}{|T|}$}
      \nexth
      \AxiomC{for each $i$ ~ $\TyRel{|p|_i}{|T|_i} \To \Gamma_i$}
      \RuleLabel{PT-Rcd}
      \UnaryInfC{$
        \TyRel{
          \Rcd{|l|_i |=| |p|_i \Indices{i \in 1..n}}
        }{
          \Rcd{|l|_i |:| |T|_i \Indices{i \in 1..n}}
        }
        \To
        \Gamma_1 |,| \dots |,| \Gamma_n
      $}
    \end{Proofs}
    Using pattern typing, we add the following typing rule.
    \begin{Proofs}
      \AxiomC{$\CtxTyRel{\Gamma_1}{|t|_1}{|T|_1}$}
      \AxiomC{$\TyRel{|p|}{|T|_1} \To \Gamma_2$}
      \AxiomC{$\CtxTyRel{\Gamma_1, \Gamma_2}{|t|_2}{|T|_2}$}
      \RuleLabel{T-Let}
      \TrinaryInfC{$\CtxTyRel{\Gamma_1}{\Let{|p|}{|t|_1} |t|_2}{|T|_2}$}
    \end{Proofs}

  \item Type preservation for \Rule{E-Let} is straight-forward.
    To show it for \Rule{E-LetV},
      we need the following lemma, which is a generalization of \textsc{Lemma 9.3.8}.

    \Lemma{11.8.2.1}.
    If $\CtxTyRel{\Gamma}{|v|}{|S|}$,
      $\TyRel{|p|}{|S|} \To \Gamma'$,
      and $\CtxTyRel{\Gamma, \Gamma'}{|t|}{|T|}$,
      then $\CtxTyRel{\Gamma}{[\It{match}(|p|, |v|)] |t|}{|T|}$. \qed

    The lemma is shown by induciton on derivation of $\TyRel{|p|}{|S|} \To \Gamma'$.

    Type progress is shown by induction on derivation of the type of the term.
    Suppose we have a typing relation
      $\CtxTyRel{\Gamma}{\Let{|p|}{|t|_1} |t|_2}{|T|_2}$.
    Since it should be derived by \Rule{T-Let},
      we have $\CtxTyRel{\Gamma}{|t|_1}{|T|_1}$ for some type $|T|_1$.
    If $|t|_1$ is not a value,
      then $|t|_1$ is evaluated to another term $|t|'_1$ by the induction hypothesis.
    Otherwise, the |let| expression is evaluated by \Rule{E-LetV}. \qed
\end{enumerate}

\Ex{11.9.1}
The boolean syntaxes can be defined as derived forms as follows.
\begin{alignat*}{2}
  & |Bool| &&\EqDef |Unit| + |Unit| \\
  & |true| &&\EqDef |inl unit| \\
  & |false| &&\EqDef |inr unit| \\
  & \If{|t|_1}{|t|_2}{|t|_3}
    &&\EqDef \CaseOf{|t|_1} \CaseArm{|inl x|_2}{|t|_2} \CaseArm{|inr x|_3}{|t|_3}
\end{alignat*}
  where, in the last line, $|x|_2$ and $|x|_3$ are fresh.

\Ex{11.11.1}
\begin{Code}
  equal = fix ($\Lm$eq:Nat$\to$Nat$\to$Bool. $\Lm$m:Nat. $\Lm$n:Nat.
                   if iszero m then iszero n
                   else if iszero n then false
                   else eq (pred m) (pred n));
  plus = fix ($\Lm$p:Nat$\to$Nat$\to$Nat. $\Lm$m:Nat. $\Lm$n:Nat.
                  if iszero n then m
                  else succ (p m (pred n));
  times = fix ($\Lm$t:Nat$\to$Nat$\to$Nat. $\Lm$m:Nat. $\Lm$n:Nat.
                   if iszero n then 0
                   else plus m (t m (pred n)));
  factorial = fix ($\Lm$f:Nat$\to$Nat. $\Lm$n:Nat.
                       if iszero n then 1
                       else times n (f (pred n)));
\end{Code}

\Ex{11.11.2}
\begin{Code}
  plus = letrec p : Nat$\to$Nat$\to$Nat =
           $\Lm$m:Nat. $\Lm$n:Nat.
             if iszero n then m else succ(p m (pred n))
         in p;
  times = letrec t : Nat$\to$Nat$\to$Nat =
            $\Lm$m:Nat. $\Lm$n:Nat.
              if iszero n then 0 else plus m (t m (pred n))
          in t;
  factorial = letrec f : Nat$\to$Nat =
                $\Lm$n:Nat.
                  if iszero n then 1 else times n (f (pred n))
              in f;
\end{Code}

\Ex{11.12.1}
\textsc{Preservation}:
We show it by induction on derivation of $|t| \to |t|'$.
We perform case analysis on the last rule used for the derivation.
We omit the cases not involving lists as they are proved in the same way as before.

\Case\Rule{E-Cons1}, \Rule{E-Isnil}, \Rule{E-Head}, \Rule{E-Tail}:
These rules only evaluate a subterm of |t|,
  whose type is preserved by the induction hypothesis.

\Case\Rule{E-IsnilNil}:
In this case,
  we can write $|t| = |isnil[S] (nil[T])|$.
Using \Rule{T-Nil} and \Rule{T-Isnil},
  we derive $\TyRel{|t|}{|Bool|}$,
  while $|t|' = |true|$, whose type is |Bool|.

\Case\Rule{E-IsnilCons}:
Let
  $
    |t| = |isnil| \CBracket{|S|_1} \App \CParen{
      |cons| \CBracket{|S|_2} \App |v|_1 \App |v|_2
    }
  $
  and $\CtxTyRel{\Gamma}{|t|}{|T|}$.
By the inversion lemma for \Rule{T-Isnil}
  (we omit the precise statement and proof here;
   same for that for other typing rules),
  we obtain $|T| = |Bool|$, while we have $|t|' = |false|$, which has type |Bool|.

\Case\Rule{E-HeadCons}:
Let
  $
    |t| = |head| \CBracket{|S|_1} \App \CParen{
      |cons| \CBracket{|S|_2} \App |v|_1 \App |v|_2
    }
  $
  and $\CtxTyRel{\Gamma}{|t|}{|T|}$.
Using the inversion lemma for \Rule{T-Head},
  we obtain $\CtxTyRel{\Gamma}{|cons| \CBracket{|S|_2} \App |v|_1 \App |v|_2}{|List S|_1}$
  and $|T| = |S|_1$.
By applying the inversion lemma for \Rule{T-Cons},
  we further obtain $\CtxTyRel{\Gamma}{|v|_1}{|S|_1}$.
Since $|t| \to |v|_1$, the type is preserved.

\Case\Rule{E-TailCons}:
Proof is almost identical to the case of \Rule{E-HeadCons},
  except that the use of \Rule{T-Head} is replaced with \Rule{T-Tail}. \qed

\textsc{Progress}:
The progress property does not hold.
For example,
  for any type |T|,
  non-value, well-typed terms |head[T] nil[T]| and |tail[T] nil[T]| are normal forms,
  i.e., stuck states.

\Ex{11.12.2}
The annotation in |nil[T]| is required to make the type unique
  in the same sense as the |as T| ascription for sum and variant types.
All the other annotations can be safely removed,
  as the types are obtained by premises of the type derivaiton rules.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 12.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Normalization}

\Ex{12.1.1}
For example, given a value |a| of type |A|,
  applying a function $\AbTy{|f|}{|A| \to |A|} |\ f (f a)|$ to
  a very long abstraction term of type $|A|\to|A|$ duplicates the abstraction term,
  which leads to a term of size larger than the original.

\Ex{12.1.7}
We extend \textsc{Definition 12.1.2} by adding the following items.
\begin{itemize}
  \item $R_{|Bool|}(|t|)$ iff |t| halts.
  \item $R_{|T|_1 \times |T|_2}(|t|)$
          iff |t| halts, $R_{|T|_1}(|t.1|)$, and $R_{|T|_2}(|t.2|)$.
\end{itemize}
We then extend \textsc{Lemma 12.1.5} with booleans and products.
Abbreviate $\Gamma = |x|_1 |,| \dots |,| |x|_n$ and
  $\sigma = [|x|_1 \mapsto |v|_1] \cdots [|x|_n \mapsto |v|_n]$
  throughout the proof.

\Case\Rule{T-True}, \Rule{T-False}: Immediate.

\Case\Rule{T-If}:
In this case, we have
  $|t| = \If{|t|_1}{|t|_2}{|t|_3}$,
  $\CtxTyRel{\Gamma}{|t|_1}{|Bool|}$,
  $\CtxTyRel{\Gamma}{|t|_2}{|T|}$, and
  $\CtxTyRel{\Gamma}{|t|_3}{|T|}$.
By the induction hypothesis, $R_{|Bool|}(\sigma |t|_1)$.
By \textsc{Lemma 12.1.3}, we have $\sigma |t|_1 \to^* |v|'_1$ for some $|v|'_1$.
If $|v|'_1 = |true|$, $\sigma |t| \to^* \sigma |t|_2$.
By the induction hypothesis, $R_{|T|}(\sigma |t|_2)$, and thus $R_{|T|}(\sigma |t|)$.
The case of $|v|'_1 = |false|$ is similar.

\Case\Rule{T-Pair}:
In this case, we have
  $|t| = \Rcd{|t|_1 |,t|_2}$,
  $\CtxTyRel{\Gamma}{|t|_1}{|T|_1}$, and
  $\CtxTyRel{\Gamma}{|t|_2}{|T|_2}$.
By the induction hypothesis,
  $R_{|T|_1}(\sigma |t|_1)$ and $R_{|T|_2}(\sigma |t|_2)$.
Therefore,
  we have $\sigma |t|_1 \to^* |v|'_1$ and $\sigma |t|_2 \to^* |v|'_2$
  for some $|v|'_1$ and $|v|'_2$.
With \Rule{E-Pair1} and \Rule{E-Pair2},
  it follows that $\sigma |t| \to^* \Rcd{|v|'_1 |,v|'_2}$.
By combining it with $R_{|T|_1}(\sigma |t|_1)$ and $R_{|T|_2}(\sigma |t|_2)$,
  we obtain $R_{|T|_1 \times |T|_2}(\sigma |t|)$.

\Case\Rule{T-Proj1}:
In this case, we have
  $|t| = |t|_1 |.1|$ and $\CtxTyRel{\Gamma}{|t|_1}{|T|_{11} \times |T|_{12}}$.
By the induction hypothesis,
  $R_{|T|_{11} \times |T|_{12}}(\sigma |t|_1)$ holds,
  which implies $R_{|T|_{11}}(\sigma |t|_1 |.1|)$.

\Case\Rule{T-Proj2}: Similar to \Case\Rule{T-Proj1}. \qed

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 13.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{References}

We use the dereference operator |!| without parentheses for readability.
The precedence of |!| is higher than function applications,
  i.e., $|!x y|$ is equivalent to $|(!x) y|$.

\Ex{13.1.1}
Omitted to avoid drawing...
|a| is a pair of references pointing to distinct |0|s,
  while |b| is a pair of references pointing to the same |0|.

\Ex{13.1.2}
No.
With this definition,
  looking up the updated |a| with a key not matching to |m| used in the udpate
  will examine the function referenced by the same |a| instead of the old one,
  resulting in divergence.

\Ex{13.1.3}
Define an operator |free r| that takes a reference and frees its storage,
  which will be reused in the use of |ref| operator in the next time.
Then, the following well-typed program
\begin{Code}
  let r = ref 0 in
  let s = r in
  free r;
  let t = ref false in
  succ !s
\end{Code}
  will be evaluated to a stuck state |succ false|.

\Ex{13.3.1}
{
\newcommand\Locations{\It{locations}}
\newcommand\Reachable{\It{reachable}}
Garbage collection requires to track the set of locations
  reachable from the outermost term.
To model it,
  we introduce a function $\Reachable(|t|, \mu)$ that
  maps a term and a store to the set of locations reachable from them,
  and a \emph{gc step} $\to_{\text{gc}}$ that models the action of garbage collection.

First, define $\Locations(|t|)$ recursively as follows.
\begin{alignat*}{2}
  & \Locations(|x|) &&= \emptyset, \\
  & \Locations(\AbTy{|x|}{|T|} |t|) &&= \Locations(|t|), \\
  & \Locations(|t|_1 \App |t|_2) &&= \Locations(|t|_1) \cup \Locations(|t|_2), \\
  & \Locations(|unit|) &&= \emptyset, \\
  & \Locations(|ref t|) &&= \emptyset, \\
  & \Locations(|!t|) &&= \Locations(|t|), \\
  & \Locations(|t|_1 |:=| |t|_2) &&= \Locations(|t|_1) \cup \Locations(|t|_2), \\
  & \Locations(l) &&= \Set{l}.
\end{alignat*}
This function simply collects all the occurences of locations in a term.
Using this function,
  we define $\Reachable(|t|, \mu)$ as the smallest subset $L$ of
  the domain of $\mu$ that satisfies the following conditions.

\begin{itemize}
  \item $\Locations(|t|) \subseteq L$.
  \item If $l \in L$, then $\Locations(\mu(l)) \subseteq L$.
\end{itemize}

Using this function, we define a gc step as follows.
\[
  \Store{|t|}{\mu} \longrightarrow_{\text{gc}}
  \Store{|t|}{(l \mapsto \mu(l) \mid l \in \Reachable(|t|, \mu))}
\]
Then, we form an evaluation of a term by interleaving evaluation and gc steps.

To show the correctness of this refinement,
  we need to confirm that the gc steps do not affect the result of evaluations.

\Theorem:
If $\Store{|t|}{\mu} \to^* \Store{|t|'}{\mu'}$,
  the evaluation is reproduced with an additional gc step,
  i.e.,
  $\Store{|t|}{\mu} \to_{\text{gc}} \Store{|t|}{\tilde\mu} \to^* \Store{|t|'}{\tilde\mu'}$.
  \qed

Given this theorem,
  we can insert a gc step to an arbitrary position of a sequence of evaluation steps
  without affecting the evaluation result.
}

\Ex{13.4.1}
\begin{Code}
  let r1 = ref $\Lm$n:Nat. n in
  let r2 = ref $\Lm$n:Nat. !r1 n in
  r1 := $\Lm$n:Nat. !r2 n;
  !r1 0
\end{Code}

\Ex{13.5.2}
Let
  $\Gamma = \emptyset$,
  $\mu = (l \mapsto \AbTy{|x|}{|Unit|} \CParen{|!|l} \App |x|)$,
  $\Sigma_1 = (l \mapsto |Unit| \to |Unit|)$, and
  $\Sigma_2 = (l \mapsto |Unit| \to |Unit| \to |Unit|)$.
Then,
  both $\CtxSto{\Gamma}{\Sigma_1}{\mu}$ and $\CtxSto{\Gamma}{\Sigma_2}{\mu}$
  hold.

\Ex{13.5.8}
Not normalizing on well-typed terms in general.
The code in Exercise 13.4.1 is an example of well-typed terms that do not normalize.

The following is a well-typed factorial function.
\begin{Code}
  factorial =
      let r = ref $\Lm$n:Nat. 0 in
      (
        r := $\Lm$n:Nat. if iszero n
                     then 1
                     else times n (!r (pred n));
        !r
      );
\end{Code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 14.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Exceptions}

\Ex{14.1.1}
This approach does not work since the type of |error| does not preserve
  through evaluation steps.
For example, in a term |error unit|,
  |error| is assigned a type $|Unit| \to |T|$ for some type |T|,
  while the term after one-step evaluation, |error|, is of type |T|.
Simply letting the programmer to annotate the type for |error| terms and use them
  thgouhout the evaluation steps breaks type preservation.
We may just erase the type annotation on evaluation
  as we have done for type ascription,
  in which case we anyway need \Rule{T-Error}
  to correctly type terms after any evaluation involving |error|,
  and the difficulty remains unsolved.

\Ex{14.3.1, 14.3.2, 14.3.3} \Todo.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 15.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subtyping}

\Ex{15.2.1}
\begin{Proofs}
  \AxiomC{}
  \RuleLabel{S-RcdPerm}
  \UnaryInfC{$
    \begin{aligned}
      &\PhantomRel\Sb \Rcd{|x:Nat,y:Nat,z:Nat|} \\
      &\Sb \Rcd{|y:Nat,x:Nat,z:Nat|}
    \end{aligned}
  $}
  \AxiomC{}
  \RuleLabel{S-RcdWidth}
  \UnaryInfC{$
    \begin{aligned}
      &\PhantomRel\Sb \Rcd{|y:Nat,x:Nat,z:Nat|} \\
      &\Sb \Rcd{|y:Nat|}
    \end{aligned}
  $}
  \RuleLabel{S-Trans}
  \BinaryInfC{$\Sub{\Rcd{|x:Nat,y:Nat,z:Nat|}}{\Rcd{|y:Nat|}}$}
\end{Proofs}

\Ex{15.2.2}
There is another derivation that uses subtyping of |f| instead of |xy| as follows.
\begin{Proofs}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\CtxTyRel{}{|f|}{|Rx| \to |Nat|}$}
  \AxiomC{}
  \RuleLabel{S-RcdWidth}
  \UnaryInfC{$\Sub{|Rxy|}{|Rx|}$}
  \AxiomC{}
  \RuleLabel{S-Refl}
  \UnaryInfC{$\Sub{|Nat|}{|Nat|}$}
  \RuleLabel{S-Arrow}
  \BinaryInfC{$\Sub{|Rx| \to |Nat|}{|Rxy| \to |Nat|}$}
  \RuleLabel{T-Sub}
  \BinaryInfC{$\CtxTyRel{}{|f|}{|Rxy| \to |Nat|}$}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\CtxTyRel{}{|xy|}{|Rxy|}$}
  \RuleLabel{T-App}
  \BinaryInfC{$\CtxTyRel{}{|f xy|}{|Nat|}$}
\end{Proofs}

\Ex{15.2.3}
\begin{itemize}
  \item[(1)] There are six supertypes:
      \Rcd{|a:Top,b:Top|},
      \Rcd{|b:Top,a:Top|},
      \Rcd{|a:Top|},
      \Rcd{|b:Top|},
      \Rcd{}, and
      |Top|.
  \item[(2)]
    Let $|S|_0 = \Rcd{}$ and $|S|_{i + 1} = \Rcd{|x:S|_i}$ for $i\in\N$.
    We have $\Sub{|S|_1 = \Rcd{|x:|\Rcd{}}}{\Rcd{} = |S|_0}$.
    For each $i > 0$, if $\Sub{|S|_i}{|S|_{i - 1}}$,
      then $\Sub{|S|_{i + 1} = \Rcd{|x:S|_i}}{\Rcd{|x:S|_{i - 1}} = |S|_i}$.
    Therefore, $(|S|_i)_i$ is an infinite sequence of descending types.
  \item[(3)]
    Using $|S|_i$ defined above, let $|T|_i = |S|_i \to |Top|$.
    Then, $(|T|_i)_i$ is an infinite sequence of ascending types.
\end{itemize}

\Ex{15.2.4}
There is no such type.
\Proof:
Any type is either a function type, a record type, or |Top|.
Any function type is not a subtype of record types, and vice versa.
And |Top| is not a subtype of any other types.

It implies that no arrow type is a supertype of every other arrow type.
If there were such a type,
  its domain type would have a type that is a subtype of
  the domain type of any other arrow types,
  which does not exist as shown above.

\Ex{15.2.5}
It is not a good idea since, e.g., it breaks the progress property as follows.
Let $|t| = \Rcd{\AbTy{|x|}{\Rcd{}} |x,\ | \Rcd{}}$.
We have $\CtxTyRel{}{|t|}{\CParen{\Rcd{} \to \Rcd{}} \times \Rcd{}}$.
With the rule \Rule{S-ProdWidth},
  we can derive $\CtxTyRel{}{|t|}{\Rcd{} \to \Rcd{}}$.
Therefore, a term |t |\Rcd{} is well-typed, which is obviously a stuck state.

\Ex{15.3.1}
The progress property may break with an additional subtyping rule,
  as we saw in Excercise 15.2.5.
The preservation property may break as well;
  consider adding the following subtyping rule.
\[ \Sub{|T|_1 \to |T|_2}{|T|_1} \]
Let $|f| = \AbTy{|x|}{|Top| \to |Unit|} |0|$.
With the above rule, we can derive $\CtxTyRel{}{|f|}{|Top| \to |Unit|}$.
Therefore, we have
  $\CtxTyRel{}{|f| \App \CParen{\AbTy{|x|}{|Top|} |unit|}}{|Unit|}$.
However,
  this term is evaluated as $|f| \App \CParen{\AbTy{|x|}{|Top|} |unit|} \to |0|$,
  which cannot have type |Unit|.

Removing any subtyping rule does not break the progress nor preservation property.

\Ex{15.3.2}
\Proof: By induction on derivation of subtyping.
\begin{enumerate}
  \item We perform case analysis of the last rule used
    for deriving $\Sub{|S|}{|T|_1 \to |T|_2}$

    \Case\Rule{S-Refl}:
      We have $|S| = |T|_1 \to |T|_2$.
      By \Rule{S-Refl}, $\Sub{|T|_1}{|T|_1}$ and $\Sub{|T|_2}{|T|_2}$.
    
    \Case\Rule{S-Trans}:
      We have $\Sub{|S|}{|U|}$ and $\Sub{|U|}{|T|_1 \to |T|_2}$ for some type |U|.
      By the induction hypothesis,
        |U| has the form $|U|_1 \to |U|_2$ with
        $\Sub{|T|_1}{|U|_1}$ and $\Sub{|U|_2}{|T|_2}$.
      By the induction hypothesis again,
        |S| has the form $|S|_1 \to |S|_2$ with
        $\Sub{|U|_1}{|S|_1}$ and $\Sub{|S|_2}{|U|_2}$.
      Using \Rule{S-Trans},
        we derive $\Sub{|T|_1}{|S|_1}$ and $\Sub{|S|_2}{|T|_2}$.

    \Case\Rule{S-Arrow}: Immediate.

    \Case\Rule{S-Top},
         \Rule{S-RcdWidth},
         \Rule{S-RcdDepth},
         \Rule{S-RcdPerm}: Impossible.

  \item We can show similarly as 1. by case analysis of the last rule used
    for deriving the subtyping relation.

    \Case\Rule{S-RcdWidth}: Immediate by combining with \Rule{S-Refl}.

    \Case\Rule{S-RcdDepth}: Immediate.

    \Case\Rule{S-RcdPerm}:
      Let $\sigma$ be the permutation that satisfies $|l|_i = |k|_{\sigma(i)}$
        and $|T|_i = |S|_{\sigma(i)}$.
      It is obvious that
      $
        \Set{|l|_i \Indices{i\in1..n}}
        = \Set{|k|_{\sigma(i)} \Indices{i\in1..n}}
        = \Set{|k|_j \Indices{j\in1..n}}
      $, and $\Sub{|S|_{\sigma(i)} = |T|_i}{|T|_i}$ for each $i$.

    \Case\Rule{S-Arrow}, \Rule{S-Top}: Impossible.

    \Case\Rule{S-Refl}, \Rule{S-Trans}: Similar to 1. \qed
\end{enumerate}

\Ex{15.3.6}
\begin{enumerate}
  \item
    A closed value |v| has the form of either
      $\AbTy{|x|}{|S|} |t|$ or $\Rcd{|l|_i |=v|_i \Indices{i\in1..n}}$
      (we can exclude the possibilities of $|v| = |x|$ and $|v| = |x.l|$
       because |v| is a closed value).
    If $\CtxTyRel{}{|v|}{|T|_1 \to |T|_2}$,
      |v| can only take the former form by the inversion lemma.
  \item Similarly shown by the inversion lemma. \qed
\end{enumerate}

\Ex{15.5.1}
By induction on evaluation derivations.
We only need to check for the case that \Rule{E-Downcast} is used for the
  last step of the derivation.
Let $|v as T| \to |v|$ be derived by \Rule{E-Downcast}.
By the premise, we have $\CtxTyRel{}{|v|}{|T|}$.
By \Rule{T-Ascribe}, $\CtxTyRel{}{|v as T|}{|T|}$.
Therefore, the type is preserved by the evaluation step $|v as T| \to |v|$. \qed

\Ex{15.5.2}
\begin{itemize}
  \item[(1)] $|(|\Lm|x:Ref \{a:Nat\}. (!x).a) (ref \{\})|$
  \item[(2)] |let r = ref \{a=1\} in (r := \{\}; (!r).a)|
\end{itemize}

\Ex{15.5.3} Omitted.

\Ex{15.6.3}
Almost same as the translations for records;
  just replace those for \Rule{S-RcdDepth}, \Rule{T-Rcd}, and \Rule{T-Proj}
  with corresponding rules for tuples,
  and remove those for \Rule{S-RcdWidth} and \Rule{S-RcdPerm}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 16.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Metatheory of Subtyping}

\Ex{16.1.2}
\begin{enumerate}
  \item
    By induction on structure of the type |S|.
    The type |S| is either an arrow type, a record type, or |Top|.
    Let us examine each case one by one.

    \Case $|S| = |T|_1 \to |T|_2$:
    By the induction hypothesis,
      we have $\Sub{|T|_1}{|T|_1}$ and $\Sub{|T|_2}{|T|_2}$.
    Then, $\Sub{|S|}{|S|}$ is derived by \Rule{S-Arrow}.

    \Case $|S| = \Rcd{|l|_i |:T|_i \Indices{i \in 1..n}}$:
    By the induction hypothesis,
      we have $\Sub{|T|_i}{|T|_i}$ for all $i \in 1..n$.
    Then, $\Sub{|S|}{|S|}$ is derived by \Rule{S-Rcd}.

    \Case $|S| = |Top|$: $\Sub{|Top|}{|Top|}$ is derived immediately by \Rule{S-Top}.

  \item
    By induction on derivations of $\Sub{|S|}{|T|}$.
    When the last rule used in the derivation is not \Rule{S-Trans},
      by the induction hypothesis,
      it can be derived without \Rule{S-Trans} at all.
    Let us assume that $\Sub{|S|}{|T|}$ is derived directly by \Rule{S-Trans}.
    Then, there is a type |U| such that $\Sub{|S|}{|U|}$ and $\Sub{|U|}{|T|}$.
    By the induction hypothesis,
      these subtyping relations can be derived without using \Rule{S-Trans}.
    We perform case analysis on the form of |T|.

    \Case $|T| = |T|_1 \to |T|_2$:
    Using the inversion of subtyping lemma twice,
      we can write $|U| = |U|_1 \to |U|_2$ and $|S| = |S|_1 \to |S|_2$
      where $|S|_1 \Sb |U|_1 \Sb |T|_1$ and $|S|_2 \Sb |S|_2 \Sb |T|_2$.
    Then, $\Sub{|S|_1 \to |S|_2}{|T|_1 \to |T|_2}$ is derived by \Rule{S-Arrow}.

    \Case $|T| = \Rcd{|l|_i |:T|_i \Indices{i\in1..n}}$:
    Similar to the above case.

    \Case $|T| = |Top|$: $\Sub{|S|}{|Top|}$ is immediately derived by \Rule{S-Top}.
    \qed
\end{enumerate}

\Ex{16.1.3}
The property of \Lemma{16.1.2.1} does not hold for $\Sub{|Bool|}{|Bool|}$,
  while the property of \Lemma{16.1.2.2} still holds for all subtyping relations.

\Ex{16.2.1}
The following derivation
\begin{Proofs}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\CtxTyRel{\Gamma}{|t|_1}{|S|_1}$}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\Sub{|S|_1}{|T|_1}$}
  \RuleLabel{T-Sub}
  \BinaryInfC{$\CtxTyRel{\Gamma}{|t|_1}{|T|_1}$}
  \AxiomC{$\vdots$}
  \LeftLabel{for each $i \in 2..n$}
  \UnaryInfC{$\CtxTyRel{\Gamma}{|t|_i}{|T|_i}$}
  \RuleLabel{T-Rcd}
  \BinaryInfC{$
    \CtxTyRel{\Gamma}{\Rcd{|l|_i |=t|_i \Indices{i\in1..n}}}{\Rcd{|l|_i |:T|_i \Indices{i\in1..n}}}
  $}
\end{Proofs}
can be transformed as follows.
\begin{Proofs}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\CtxTyRel{\Gamma}{|t|_1}{|S|_1}$}
  \AxiomC{$\vdots$}
  \LeftLabel{for each $i\in2..n$}
  \UnaryInfC{$\CtxTyRel{\Gamma}{|t|_i}{|T|_i}$}
  \RuleLabel{T-Rcd}
  \BinaryInfC{$
    \CtxTyRel{\Gamma}{\Rcd{|l|_i |=t|_i \Indices{i\in1..n}}}{\Rcd{|l|_1 |:S|_1 |,l|_i |:T|_i \Indices{i\in2..n}}}
  $}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\Sub{|S|_1}{|T|_1}$}
  \AxiomC{}
  \LeftLabel{for each $i\in2..n$}
  \RuleLabel{S-Refl}
  \UnaryInfC{$\Sub{|T|_i}{|T|_i}$}
  \RuleLabel{S-RcdDepth}
  \BinaryInfC{$
    \Sub{\Rcd{|l|_1 |:S|_1 |,l|_i |:T|_i \Indices{i\in2..n}}}{\Rcd{|l|_i |:T|_i \Indices{i\in1..n}}}
  $}
  \RuleLabel{T-Sub}
  \BinaryInfC{$
    \CtxTyRel{\Gamma}{\Rcd{|l|_i |=t|_i \Indices{i\in1..n}}}{\Rcd{|l|_i |:T|_i \Indices{i\in1..n}}}
  $}
\end{Proofs}
A similar transformation is applied when the record items are permutated so that
  \Rule{T-Sub} is applied to $\CtxTyRel{\Gamma}{|t|_j}{|T|_j}$ with $j \neq 1$.

The next derivation
\begin{Proofs}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\CtxTyRel{\Gamma}{|t|_1}{\Rcd{|k|_j |:S|_j \Indices{j\in1..m}}}$}
  \AxiomC{$\vdots$}
  \UnaryInfC{$
    \Sub{\Rcd{|k|_j |:S|_j \Indices{j\in1..m}}}{\Rcd{|l|_i |:T|_i \Indices{i\in1..n}}}
  $}
  \RuleLabel{T-Sub}
  \BinaryInfC{$\CtxTyRel{\Gamma}{|t|_1}{\Rcd{|l|_i |:T|_i \Indices{i\in1..n}}}$}
  \RuleLabel{T-Proj}
  \UnaryInfC{$\CtxTyRel{\Gamma}{|t|_1 |.l|_{i_1}}{|T|_{i_1}}$}
\end{Proofs}
is transformed as follows.
First, by the discussion of the previous section,
  we can assume that the right subderivation of \Rule{T-Sub} ends with \Rule{S-Rcd}.
Then, the derivation is written as follows.
\begin{Proofs}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\CtxTyRel{\Gamma}{|t|_1}{\Rcd{|k|_j |:S|_j \Indices{j\in1..m}}}$}
  \AxiomC{$\Set{|l|_i \Indices{i\in1..n}} \subseteq \Set{|k|_j \Indices{j\in1..m}}$}
  \AxiomC{$\vdots$}
  \UnaryInfC{$|k|_j = |l|_i \Implies \Sub{|S|_j}{|T|_i}$}
  \RuleLabel{S-Rcd}
  \BinaryInfC{$
    \Sub{\Rcd{|k|_j |:S|_j \Indices{j\in1..m}}}{\Rcd{|l|_i |:T|_i \Indices{i\in1..n}}}
  $}
  \RuleLabel{T-Sub}
  \BinaryInfC{$\CtxTyRel{\Gamma}{|t|_1}{\Rcd{|l|_i |:T|_i \Indices{i\in1..n}}}$}
  \RuleLabel{T-Proj}
  \UnaryInfC{$\CtxTyRel{\Gamma}{|t|_1 |.l|_{i_1}}{|T|_{i_1}}$}
\end{Proofs}
This derivation is then transformed as follows. Suppose $|k|_{j_1} = |l|_{i_1}$.
\begin{Proofs}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\CtxTyRel{\Gamma}{|t|_1}{\Rcd{|k|_j |:S|_j \Indices{j\in1..m}}}$}
  \RuleLabel{T-Proj}
  \UnaryInfC{$\CtxTyRel{\Gamma}{|t|_1 |.k|_{j_1}}{|S|_{j_1}}$}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\Sub{|S|_{j_1}}{|T|_{i_1}}$}
  \RuleLabel{T-Sub}
  \BinaryInfC{$\CtxTyRel{\Gamma}{|t|_1 |.l|_{i_1}}{|T|_{i_1}}$}
\end{Proofs}

\Ex{16.2.3}
Let $|s| = \CParen{\AbTy{|x|}{|Top|} |x|} \App \Rcd{}$ and $|t| = \Rcd{}$.
The term |s| is evaluated to |t| by \Rule{E-Abs}.
While the algorithmic type of |t| is \Rcd{},
  that of |s| is |Top|,
  as we have $\AlTyRel{}{\AbTy{|x|}{|Top|} |x|}{|Top| \to |Top|}$
  and $\Sub{\Rcd{}}{|Top|}$.

\Ex{16.2.5}
By induction on derivations of $\CtxTyRel{\Gamma}{|t|}{|T|}$.
Let us perform case analysis on the last rule used in the derivation.

\Case\Rule{T-Var}: Immediately derived with $|S| = |T|$.

\Case\Rule{T-Abs}:
We have $|t| = \AbTy{|x|}{|T|_1} |t|_2$ and $|T| = |T|_1 \to |T|_2$
  where the premise gives $\CtxTyRel{\Gamma, |x:T|_1}{|t|_2}{|T|_2}$.
By the induction hypothesis,
  the premise implies $\AlTyRel{\Gamma, |x:T|_1}{|t|_2}{|S|_2}$
  where $\Sub{|S|_2}{|T|_2}$.
Using \Rule{TA-Abs},
  we obtain $\AlTyRel{\Gamma}{|t|}{|T|_1 \to |S|_2}$.
Since $\Sub{|T|_1 \to |S|_2}{|T|_1 \to |T|_2}$ by \Rule{S-Refl} and \Rule{S-Arrow},
  the conclusion holds.

\Case\Rule{T-App}:
We have $|t| = |t|_1 \App |t|_2$ and $|T| = |T|_{12}$
  where the premises give $\CtxTyRel{\Gamma}{|t|_1}{|T|_{11} \to |T|_{12}}$ and
  $\CtxTyRel{\Gamma}{|t|_2}{|T|_{11}}$.
By the induction hypothesis,
  the premises imply
  $\AlTyRel{\Gamma}{|t|_1}{|S|_1}$ and
  $\AlTyRel{\Gamma}{|t|_2}{|S|'_{11}}$
  with $\Sub{|S|_1}{|T|_{11} \to |T|_{12}}$ and
  $\Sub{|S|'_{11}}{|T|_{11}}$.
By the inversion of subtyping lemma,
  we can write $|S|_1 = |S|_{11} \to |S|_{12}$
  where $\Sub{|T|_{11}}{|S|_{11}}$ and $\Sub{|S|_{12}}{|T|_{12}}$.
The first subtyping relation gives $\Sub{|S|'_{11}}{|S|_{11}}$.
Therefore, using \Rule{TA-App},
  we derive $\AlTyRel{\Gamma}{|t|_1 \App |t|_2}{|S|_{12}}$.
Since $\Sub{|S|_{12}}{|T|_{12}}$, this is the conclusion we wanted.

\Case\Rule{T-Sub}:
The first premise with the induction hypothesis gives $\AlTyRel{\Gamma}{|t|}{|T|}$.
The conclusion follows by combining it with the second premise $\Sub{|S|}{|T|}$.

\Case\Rule{T-Rcd}:
We have $|t| = \Rcd{|l|_i |=t|_i \Indices{i\in1..n}}$ and
  $|T| = \Rcd{|l|_i |:T|_i \Indices{i\in1..n}}$
  where the premises give $\CtxTyRel{\Gamma}{|t|_i}{|T|_i}$ for all $i$.
By the induction hypothesis,
  $\AlTyRel{\Gamma}{|t|_i}{|S|_i}$ with $\Sub{|S|_i}{|T|_i}$ for all $i$.
Using \Rule{TA-Rcd},
  we obtain $
    \AlTyRel{\Gamma}{\Rcd{|l|_i |=t|_i \Indices{i\in1..n}}}{\Rcd{|l|_i |:S|_i \Indices{i\in1..n}}}
  $.
\Rule{S-RcdDepth} gives
  $\Sub{\Rcd{|l|_i |:S|_i \Indices{i\in1..n}}}{\Rcd{|l|_i |:T|_i \Indices{i\in1..n}}}$.

\Case\Rule{T-Proj}:
We have $|t| = |t|_1 |.l|_{i_1}$ and $|T| = |T|_{i_1}$
  where the premise gives
  $\CtxTyRel{\Gamma}{|t|_1}{\Rcd{|l|_i |:T|_i \Indices{i\in1..n}}}$.
By the induction hypothesis,
  $\AlTyRel{\Gamma}{|t|_1}{|S|_1}$
  with $\Sub{|S|_1}{\Rcd{|l|_i |:T|_i \Indices{i\in1..n}}}$.
Following the discussion in the previous section,
  this subtyping relation can be derived by \Rule{S-Rcd}.
It implies that $|S|_1$ can be written as $\Rcd{|k|_j |:S|_j \Indices{j\in1..m}}$
  where $\Set{|l|_i \Indices{i\in1..n}} \subseteq \Set{|k|_j \Indices{j\in1..m}}$
  and $\Sub{|S|_j}{|T|_i}$ whenever $|k|_j = |l|_i$.
In particular, there exists $j_1$ such that $|k|_{j_1} = |l|_{i_1}$.
By \Rule{TA-Proj},
  $\AlTyRel{\Gamma}{|t|_1 |.l|_{i_1}}{|S|_{j_1}}$ is derived.
The type satisfies $\Sub{|S|_{j_1}}{|T|_{i_1}}$. \qed

\Ex{16.2.6}
\emph{No.}
Let $|t| = \AbTy{|x|}{\Rcd{}} |x|$.
In this system, it may have a declarative type $|T| = \Rcd{} \to |Top|$ as follows.
\begin{Proofs}
  \AxiomC{$|x:|\Rcd{} \in |x:|\Rcd{}$}
  \RuleLabel{T-Var}
  \UnaryInfC{$\CtxTyRel{|x:|\Rcd{}}{|x|}{\Rcd{}}$}
  \AxiomC{}
  \RuleLabel{S-Top}
  \UnaryInfC{$\Sub{\Rcd{}}{|Top|}$}
  \RuleLabel{T-Sub}
  \BinaryInfC{$\CtxTyRel{|x:|\Rcd{}}{|x|}{|Top|}$}
  \RuleLabel{T-Abs}
  \UnaryInfC{$\CtxTyRel{}{\AbTy{|x|}{\Rcd{}} |x|}{\Rcd{} \to |Top|}$}
\end{Proofs}
On the other hand, its algorithmic type is $|S| = \Rcd{} \to \Rcd{}$,
  which is derived as follows.
\begin{Proofs}
  \AxiomC{$|x:|\Rcd{} \in |x:|\Rcd{}$}
  \RuleLabel{TA-Var}
  \UnaryInfC{$\AlTyRel{|x:|\Rcd{}}{|x|}{\Rcd{}}$}
  \RuleLabel{TA-Abs}
  \UnaryInfC{$\AlTyRel{}{\AbTy{|x|}{\Rcd{}} |x|}{\Rcd{} \to \Rcd{}}$}
\end{Proofs}
In the system without \Rule{S-Arrow}, |S| is not a subtype of |T|.

\Ex{16.3.2}
We show both statements simultaneously by induction on the structure of |S|.

\begin{enumerate}
  \item We perform case analysis on the form of |S|.

    \Case $|S| = |Top|$:
    Only |Top| is the supertype of |S|, and is a supertype of |T|,
      thus $|S| \vee |T| = |Top|$.

    \Case $|S| = |Bool|$:
    Only |Top| and |Bool| are the supertypes of |S|.
    If $|T| = |Bool|$, $|S| \vee |T| = |Bool|$.
    Otherwise, |Bool| is not a supertype of |T|, thus $|S| \vee |T| = |Top|$.

    \Case $|S| = |S|_1 \to |S|_2$:
    Only |Top| and arrow types may be supertypes of |S|.
    If |Top| is the only common supertype of |S| and |T|,
      then $|S| \vee |T| = |Top|$.
    Suppose there is a common supertype $|U| \neq |Top|$ of |S| and |T|.
    Then, |U| has the form $|U|_1 \to |U|_2$
      with $\Sub{|U|_1}{|S|_1}$ and $\Sub{|S|_2}{|U|_2}$.
    By the inversion lemma of subtyping relations,
      we can write $|T| = |T|_1 \to |T|_2$
      where $\Sub{|U|_1}{|T|_1}$ and $\Sub{|T|_2}{|U|_2}$.
    By the induction hypothesis,
      there exist types $|J|_1 = |S|_1 \wedge |T|_1$ and $|J|_2 = |S|_2 \vee |T|_2$.
    By definition, $|J|_1$ is a common subtype of $|S|_1$ and $|T|_1$,
      and $|J|_2$ is a common supertype of $|S|_2$ and $|T|_2$.
    Therefore, we derive with \Rule{S-Arrow} that $|J|_1 \to |J|_2$ is
      a common supertype of $|S|_1 \to |S|_2$ and $|T|_1 \to |T|_2$.
    We also have $\Sub{|J|_1}{|U|_1}$ and $\Sub{|U|_2}{|J|_2}$
      by the minimality of $|J|_1$ and the maximality of $|J|_2$.
    Therefore, we again derive $\Sub{|J|_1 \to |J|_2}{|U|_1 \to |U|_2}$,
      that means, $\Sub{|J|_1 \to |J|_2} = |S| \vee |T|$.

    \Case $|S| = \Rcd{|l|_i |:S|_i \Indices{i\in1..n}}$:
    Only |Top| and record types may be supertypes of |S|.
    If |Top| is the only common supertype of |S| and |T|,
      then $|S| \vee |T| = |Top|$.
    Suppose there is a common supertype $|U| \neq |Top|$ of |S| and |T|.
    Then, |U| has the form $\Rcd{|k|_j |:U|_j \Indices{j\in1..m}}$
      with $\Set{|k|_j \Indices{j\in1..m}} \subseteq \Set{|l|_i \Indices{i\in1..n}}$
      and $\Sub{|S|_i}{|U|_j}$ whenever $|l|_i = |k|_j$.
    By the inversion lemma of subtyping relations,
      we can write $|T| = \Rcd{|l|'_{i'} \Indices{i'\in1..n'}}$
      where $\Set{|k|_j \Indices{j\in1..m}} \subseteq \Set{|l|'_{i'} \Indices{i'\in1..n'}}$
      and $\Sub{|T|_{i'}}{|U|_j}$ whenever $|l|'_{i'} = |k|_j$.
    For every $j \in 1..m$,
      there exist $i\in1..n$ and $i'\in1..n'$ such that $|k|_j = |l|_i = |l|'_{i'}$,
      for which, by the induction hypothesis,
      there exists a join type $|J|_j = |S|_i \vee |T|_{i'}$.
    Let $|J| = \Rcd{|k|_j |:J|_j \Indices{j\in1..m}}$.
    Then, it follows by \Rule{S-Rcd} that $|J|$ is a common supertype of |S| and |T|.
    Also, for every $j$,
      by the minimality of $|J|_j$, $\Sub{|J|_j}{|U|_j}$.
    Therefore, by \Rule{S-Rcd}, we can derive $\Sub{|J|}{|U|}$,
      which implies that |J| is a join type of |S| and |T|.

  \item We again proceed with case analysis on the form of |S|.
  
    \Case $|S| = |Top|$: We immediately have $|S| \wedge |T| = |T|$.

    \Case $|S| = |Bool|$:
    Only |Bool| is the subtype of |S|.
    By the assumption, it is also a subtype of |T|,
      thus the only common subtype of them.
    Therefore, $|S| \wedge |T| = |Bool|$.

    \Case $|S| = |S|_1 \to |S|_2$:
    Any subtype of |S| is an arrow type,
      whose supertypes are only |Top| and arrow types.
    Therefore, |T| is either of them.
    If $|T| = |Top|$, then immediately $|S| \wedge |T| = |S|$.
    Otherwise, |T| has the form $|T|_1 \to |T|_2$.
    Let $|U| = |U|_1 \to |U|_2$ be a common subtype of |S| and |T|.
    Then, $|U|_2$ is a common subtype of $|S|_2$ and $|T|_2$.
    By the induction hypothesis,
      with the existence of $|U|_2$,
      there is a meet type $|M|_2 = |S|_2 \wedge |T|_2$.
    By the induction hypothesis again,
      there is a join type $|J|_1 = |S|_1 \vee |T|_1$.
    Let $|M| = |J|_1 \to |M|_2$.
    Then, |M| is a common subtype of |S| and |T|,
      and, by the minimality of $|J|_1$ and the maximality of $|M|_2$,
      we obtain $\Sub{|J|_1}{|U|_1}$ and $\Sub{|U|_2}{|M|_2}$.
    Therefore, $\Sub{|U|}{|M|}$.
    Note that |M| is taken independently with |U|,
      and thus is a meet type of |S| and |T|.

    \Case $|S| = \Rcd{|l|_i |:S|_i \Indices{i\in1..n}}$:
    Any subtype of |S| is a record type,
      whose supertypes are only |Top| and record types.
    Therefore, |T| is either of them.
    If $|T| = |Top|$, then immediately $|S| \wedge |T| = |S|$.
    Otherwise, |T| has the form $\Rcd{|l|'_{i'} |:T|'_{i'} \Indices{i'\in1..n'}}$.
    Let $|U| = \Rcd{|k|_j |:U|_j \Indices{j\in1..m}}$
      be a common subtype of |S| and |T|.
    Then, $
      \Set{|k|_j \Indices{j\in1..m}}
      \supseteq \Set{|l|_i \Indices{i\in1..n}}
      \cup \Set{|l|'_{i'} \Indices{i'\in1..n'}}
    $.
    We also have $\Sub{|U|_j}{|S|_i}$ whenever $|k|_j = |l|_i$,
      and $\Sub{|U|_j}{|T|_{i'}}$ whenever $|k|_j = |l|'_{i'}$.
    Let $\Set{|k|^\star_{j^\star} \Indices{j^\star \in 1..m^\star}}$
      be the intersection of the label sets of |S| and |T|.
    Then,
      by the induction hypothesis,
      there exists a meet type $|M|_{j^\star} = |S|_i \wedge |T|_{i'}$
      for every $j^\star$ with $|k|^\star_{j^\star} = |l|_i = |l|'_{i'}$.
    Let $I = \Set{i \in 1..n \mid \forall j^\star, ~ |l|_i \neq |k|^\star_{j^\star}}$,
      and $I' = \Set{i' \in 1..{n'} \mid \forall j^\star, ~ |l|'_{i'} \neq |k|^\star_{j^\star}}$.
    Define $
      |M| = \Rcd{
        |k|^\star_{j^\star} |:M|_{j^\star} \Indices{j^\star\in1..{m^\star}}, ~
        |l|_i |:S|_i \Indices{i\in I}, ~
        |l|'_{i'} |:T|_{i'} \Indices{i'\in I'}
      }
    $.
    Then, |M| is a common subtype of |S| and |T|,
      and is a supertype of |U|.
    Note that |M| is taken independently with |U|,
      and thus is a meet type of |S| and |T|. \qed
\end{enumerate}

\Ex{16.3.3}
|Top|, as this is the only common supertype of |Bool| and \Rcd{}.
This behavior would not be kind for users.
When the value that is not discarded is type-checked as |Top| as
  a join type of branches,
  it would be better to show a warning.

\Ex{16.3.4}
Suppose the system does not have |Source| and |Sink| types.
For any types |S| and |T|,
  if $|T| = |Ref S|'$ where $|S|'$ is equivalent to |S|,
  then $|(Ref S)| \vee |T| = |Ref S|$ and $|(Ref S)| \wedge |T| = |Ref S|$.
Otherwise, $|(Ref S)| \vee |T| = |Top|$, and $|(Ref S)| \wedge |T|$ does not exist.

If we introduce |Source| and |Sink| types,
  \textsc{Proposition 16.3.2} does not hold anymore,
  as the following counterexamples show.
\begin{enumerate}
  \item
    Let $|S| = |Ref \{\}|$ and $|T| = |Ref Top|$.
    Then, both |Source Top| and |Sink \{\}| are supertypes of each of them.
    Any common subtype of them is a |Ref| type,
      which cannot be a common supertype of |S| and |T|.
  \item
    Let $|S| = |Source Top|$ and $|T| = |Sink \{\}|$.
    Then, both |Ref \{\}| and |Ref Top| are subtypes of each of them.
    Any common subtype of |S| and |T| is a |Ref| type,
      which cannot be a common supertype of |Ref \{\}| and |Ref Top|.
\end{enumerate}

\Ex{16.4.1}
We need the following rule:
\begin{Proofs}
  \AxiomC{$\AlTyRel{\Gamma}{|t|_1}{|T|_1}$}
  \AxiomC{$|T|_1 = |Bot|$}
  \AxiomC{$\AlTyRel{\Gamma}{|t|_2}{|T|_2}$}
  \AxiomC{$\AlTyRel{\Gamma}{|t|_3}{|T|_3}$}
  \AxiomC{$|T|_2 \vee |T|_3 = |T|$}
  \QuinaryInfC{$\AlTyRel{\Gamma}{\If{|t|_1}{|t|_2}{|t|_3}}{|T|}$}
\end{Proofs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 17.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An ML Implementation of Subtyping}
Rust implementations of subtyping are put at the following locations:

\begin{itemize}
  \item |src/rcdsubbot.rs|, which is an implementation of the simply typed lambda-calculus
    with subtyping, records, bottom type, and refined error messages as
    asked in \textsc{Exercise} 17.3.2 and 17.3.3.
  \item |src/joinexercise.rs|, which is an implementation of the
    simply typed lambda-calculus with subtyping, records, and booleans,
    as asked in \textsc{Exercise} 17.3.1.
    It includes an implementation of join and meet.
\end{itemize}

\textsc{Exercise} 17.3.4 is omitted.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 18.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Case Study: Imperative Objects}

\Ex{18.6.1}
\begin{Code}
  DecCounter = {get: Unit$\to$Nat,
                inc: Unit$\to$Unit,
                reset: Unit$\to$Unit,
                dec: Unit$\to$Unit};

  decCounterClass =
    $\Lm$r:CounterRep.
      let super = resetCounterClass r in
        {get = super.get,
         inc = super.inc,
         reset = super.reset,
         dec = $\Lm$_:Unit. r.x:=pred(!(r.x))};

  newResetDecCounter =
    $\Lm$_:Unit. let r = {x=ref 1} in resetDecCounterClass r;
\end{Code}

\Ex{18.6.2}
Syntax:
\begin{Code}
  t $::=$ $\ldots$
        t with t
\end{Code}

Operational semantics:
\begin{Proofs}
  \AxiomC{$|t|_1 \to |t|'_1$}
  \RuleLabel{E-With1}
  \UnaryInfC{$|t|_1 | with | |t|_2 \to |t|'_1 | with | |t|_2$}
  \next
  \AxiomC{$|t|_2 \to |t|'_2$}
  \RuleLabel{E-With2}
  \UnaryInfC{$|v|_1 | with | |t|_2 \to |v|_1 | with | |t|'_2$}
  \next
  \AxiomC{$
    \Set{|l|_i \Indices{i\in1..n}} \cap \Set{|k|_j \Indices{j\in1..m}}
    = \emptyset
  $}
  \RuleLabel{E-WithRcd}
  \UnaryInfC{$
    \Rcd{|l|_i |=v|_i \Indices{i\in1..n}} | with |
    \Rcd{|k|_j |=w|_j \Indices{j\in1..m}}
    \to
    \Rcd{|l|_i |=v|_i \Indices{i\in1..n} |, |
         |k|_j |=w|_j \Indices{j\in1..m}}
  $}
\end{Proofs}

Typing:
\begin{Proofs}
  \AxiomC{$
    \Set{|l|_i \Indices{i\in1..n}} \cap \Set{|k|_j \Indices{j\in1..m}}
    = \emptyset
  $}
  \AxiomC{$\CtxTyRel{\Gamma}{|t|_1}{\Rcd{|l|_i |:S|_i \Indices{i\in1..n}}}$}
  \AxiomC{$\CtxTyRel{\Gamma}{|t|_2}{\Rcd{|k|_j |:T|_j \Indices{j\in1..m}}}$}
  \RuleLabel{T-With}
  \TrinaryInfC{$\CtxTyRel{\Gamma}{|t|_1 | with | |t|_2}{
    \Rcd{|l|_i |:S|_i \Indices{i\in1..n} |, | |k|_j |:T|_j \Indices{j\in1..m}}
  }$}
\end{Proofs}

Note that this definition does not support \emph{method overriding};
  \Rule{E-WithRcd} and \Rule{T-With} do not handle cases that
  the label sets of both operands overlap.

\Ex{18.7.1}
\begin{Code}
  DoubleBackupCounterRep = {x: Ref Nat, b: Ref Nat, c: Ref Nat};

  DoubleBackupCounter = {get: Unit$\to$Nat,
                         inc: Unit$\to$Unit,
                         reset: Unit$\to$Unit,
                         backup: Unit$\to$Unit,
                         reset2: Unit$\to$Unit,
                         backup2: Unit$\to$Unit};

  doubleBackupCounterClass =
    $\Lm$r:DoubleBackupCounterRep.
      let super = backupCounterClass r in
         {get = super.get,
          inc = super.inc,
          reset = super.reset,
          backup = super.backup,
          reset2 = $\Lm$_:Unit. r.x:=!(r.c),
          backup2 = $\Lm$_:Unit. r.b:=!(r.x)};

  newDoubleBackupCounter =
    $\Lm$_:Unit. let r = {x=ref 1, b=ref 1, c=ref 1}
             in doubleBackupCounterClass r;
\end{Code}

\Ex{18.11.1}
\begin{Code}
  instrCounterClass =
    $\Lm$r:InstrCounterRep.
    $\Lm$self:Unit$\to$InstrCounter.
    $\Lm$_:Unit.
      let super = setCounterClass r self unit in
         {get = $\Lm$_:Unit. (r.a:=succ(!(r.a)); super.get unit),
          set = $\Lm$i:Nat. (r.a:=succ(!(r.a)); super.set i),
          inc = super.inc,
          accesses = $\Lm$_:Unit. !(r.a)};

  ResetInstrCounter = {get: Unit$\to$Nat,
                       set: Nat$\to$Unit,
                       inc: Unit$\to$Unit,
                       accesses: Unit$\to$Nat,
                       reset: Unit$\to$Unit};
  resetInstrCounterClass =
    $\Lm$r:InstrCounterRep.
    $\Lm$self:Unit$\to$ResetInstrCounter.
    $\Lm$_:Unit.
      let super = instrCounterClass r self unit in
         {get = super.get,
          set = super.set,
          inc = super.inc,
          accesses = super.accesses,
          reset = $\Lm$_:Unit. (self unit).set 0};

  BackupInstrCounter = {get: Unit$\to$Nat,
                        set: Nat$\to$Unit,
                        inc: Unit$\to$Unit,
                        accesses: Unit$\to$Nat,
                        reset: Unit$\to$Unit,
                        backup: Unit$\to$Unit};
  BackupInstrCounterRep = {x: Ref Nat, a: Ref Nat, b: Ref Nat};
  backupInstrCounterClass =
    $\Lm$r:BackupInstrCounterRep.
    $\Lm$self:Unit$\to$BackupInstrCounter.
    $\Lm$_:Unit.
      let super = resetInstrCounterClass r self unit in
         {get = super.get,
          set = super.set,
          inc = super.inc,
          accesses = super.accesses,
          reset = $\Lm$_:Unit. super.set (!(r.b)),
          backup = $\Lm$_:Unit. r.b:=super.get unit};
\end{Code}

\Ex{18.13.1}
Define |Object| class that should be inherited by all other classes in the system
  as follows.
\begin{Code}
  Object = {id: Nat};
  ObjectRep = {};
  objectClass =
    let nextId = ref 0 in
      $\Lm$_:ObjectRep. $\Lm$_:Source Object.
        (nextId:=succ(!nextId); {id = !nextId});
\end{Code}
Here, |id| is not included in the object representation
  but instead bound directly to the method definition.
This allows subclasses to avoid repeating the definition of |id|.
For example, the |Counter| class is redefined as follows.
\begin{Code}
  Counter = {id: Nat, get: Unit$\to$Nat, inc: Unit$\to$Unit};
  CounterRep = {x: Ref Nat};
  counterClass =
    $\Lm$r:CounterRep. $\Lm$self:Source Counter.
    let super = objectClass r self in
       {id = super.id,
        get = $\Lm$_:Unit. !(r.x),
        inc = $\Lm$_:Unit. r.x:=succ(!(r.x))};
  dummyCounter = {id = 0, get = $\Lm$_:Unit. 0, inc: $\Lm$_:Unit. unit};
  newCounter =
    $\Lm$_:Unit.
      let r = {x = ref 1} in
      let cAux = ref dummyCounter in
      (cAux := counterClass r cAux; !cAux);
\end{Code}
Note that the type of every object is then a subtype of |Object|,
  so we can define |sameObject| as follows.
\begin{Code}
  sameObject = $\Lm$x:Object. $\Lm$y:Object. eq (x.id) (y.id)
\end{Code}
  where $|eq:Nat|\to|Nat|\to|Bool|$ is a function that tests if
  two integers are equal:
\begin{Code}
  eq = fix (
    $\Lm$f:Nat$\to$Nat$\to$Bool. $\Lm$m:Nat. $\Lm$n:Nat.
      if iszero m then iszero n else
      if iszero n then false else
      f (pred m) (pred n)
  );
\end{Code}

We can also use the |Ref| trick used in the official solution of this exercise
  to avoid dependency on |eq|
  (we use |Ref Bool| instead of |Ref Nat| for further simplicity):
\begin{Code}
  Object = {id: Ref Bool};
  ObjectRep = {};
  objectClass = $\Lm$_:ObjectRep. $\Lm$_:Source Object. {id = ref true};

  sameObject =
    $\Lm$x:Object. $\Lm$y:Object.
      (x.id := false; y.id := true; !(x.id));
\end{Code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 19.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Case Study: Featherweight Java}
{
\newcommand\ClassDef[6]{|class |#1| extends |#2| \{|#3| |#4|; |#5| |#6|\}|}
\newcommand\ClassDefDefault{\ClassDef{|C|}{|D|}{\Cbar C}{\Cbar f}{|K|}{\Cbar M}}
\newcommand\CT{\It{CT}}
\newcommand\Fields{\It{fields}}
\newcommand\Mbody{\It{mbody}}
\newcommand\Mtype{\It{mtype}}
\newcommand\Override{\It{override}}

\Ex{19.4.1}
For any class |C|,
  we can derive $\Sub{|C|}{|Object|}$ from subtyping rules.

\Proof: Assume $|C| \not\Sb |Object|$.
Define a sequence of types $(|C|_i)_i$ recursively as follows.
\[ |C|_0 = |C|, \quad
   \CT(|C|_i) = |class C|_i | extends C|_{i + 1} | \{ | \ldots | \} | \]
By the assumption,
  |Object| does not appear in the sequence,
  and thus $|C|_i$ is well-defined for any index $i \in \N$.
Since the relation $\Sb$ is antisymmetric,
  the class $|C|_i$ is distinct from each other.
It contradicts with the finiteness of $\Dom(\CT)$. \qed

\Ex{19.4.2}
Some ideas:
\begin{itemize}
  \item Drop constructor declarations.
  \item Simplify the method declaration syntax;
    e.g., $|C m(|\bar{|C|}| |\bar{|x|}|) = t;|$.
  \item Remove the |new| keyword; this does not make the syntax ambiguous.
  \item Unite the cast typing rules into one; e.g.,
    \begin{Proofs}
      \AxiomC{$\CtxTyRel{\Gamma}{|t|}{|D|}$}
      \RuleLabel{T-Cast}
      \UnaryInfC{$\CtxTyRel{\Gamma}{|(C)t|}{|C|}$}
    \end{Proofs}
\end{itemize}

\Ex{19.4.3}
{
\newcommand\Meval{\It{meval}}
\newcommand\Obj[2]{\It{obj}(#1\CParen{#2})}

\paragraph{Syntax:}
Change method declarations as follows.
\begin{flalign*}
  |M| ::=& &\\
    & |C m(|\Cbar C| |\Cbar x|) \{MB\}| & \\
  |MB| ::=& & \It{method body with assignments} \\
    & |t.f = t; MB| & \\
    & |return t;| &
\end{flalign*}
Each object becomes a mutable entity,
  which we represent as an item in a \emph{store}.
Let us update the terms and values syntax as well.
\begin{flalign*}
  |t| ::=& && \\
    &\vdots && \\
    &\Meval(|MB|) && \\
    &l && \\
  |v| ::=& && \\
    &\Obj{|C|}{\bar l} && \\
    &l &&
\end{flalign*}
Here, $l$ denotes a \emph{location} in a store.
Unlike |ref| introduced in Part 13,
  a location is implicitly dereferenced in each evaluation rule if necessary.

The \Meval{} term is a method body that is being evaluated.
This term is not written directly in the source code, just like locations.

In this extension,
  the |new| expression is not a value anymore;
  it allocates a new object in the store and returns its location.
To distinguish the object value from the |new| expression,
  we introduce \It{obj} value that represents the object stored in the location.

\paragraph{Auxiliary functions:}
We need to update \Mbody{} to include the assignment statements.
\begin{Proofs}
  \AxiomC{$\CT(|C|) = \ClassDefDefault$}
  \AxiomC{$|B m (|\Cbar B| |\Cbar x|) \{MB\}| \in \Cbar M$}
  \BinaryInfC{$\Mbody(|m|, |C|) = (\Cbar x, |MB|)$}
  \next
  \AxiomC{$\CT(|C|) = \ClassDefDefault$}
  \AxiomC{|m| is not defined in $\Cbar M$}
  \BinaryInfC{$\Mbody(|m|, |C|) = \Mbody(|m|, |D|)$}
\end{Proofs}
Other functions are trivially updated with the new syntax.

\paragraph{Evaluation}
We largely update the evaluation rules using stores and locations.
Here, substitution $\sigma = \Subst{\dots}$ is defined recursively by
  $\sigma(|return t;|) = |return |\sigma(|t|)|;|$ and
  $
    \sigma(|t|_1 |.f|_1 | = t|_2 |; MB|) =
    \CParen{\sigma |t|_1} |.f|_1 | = | \CParen{\sigma |t|_2} |; | \sigma |MB|
  $.
\begin{Proofs}
  \AxiomC{$l \notin \Dom(\mu)$}
  \RuleLabel{ES-New}
  \UnaryInfC{$
    \Store{|new C|\CParen{\Cbar v}}{\mu}
    \to
    \Store{l}{(\mu, l \mapsto \Obj{|C|}{\Cbar v})}
  $}
  \next
  \AxiomC{$\Fields(|C|) = \Cbar C| |\Cbar f$}
  \AxiomC{$\mu(l) = \Obj{|C|}{\Cbar v}$}
  \RuleLabel{ES-ProjLoc}
  \BinaryInfC{$\Store{l|.f|_i}{\mu} \to \Store{|v|_i}{\mu}$}
  \next
  \AxiomC{$\Mbody(|m|, |C|) = (\Cbar x, |MB|)$}
  \AxiomC{$\mu(l) = \Obj{|C|}{\Cbar v}$}
  \RuleLabel{ES-InvkLoc}
  \BinaryInfC{$
    \Store{l |.m(|\Cbar u|)|}{\mu} \to
    \Store{\Meval(\Subst{\Cbar x \mapsto \Cbar u, |this| \mapsto l} |MB|)}{\mu}
  $}
  \next
  \AxiomC{$\Store{|t|_{11} \to |t|'_{11}}{\mu}$}
  \RuleLabel{ES-EvalLeft}
  \UnaryInfC{$
    \Store{\Meval(|t|_{11} |.f|_1 | = t|_{12} |; MB|_2)}{\mu} \to
    \Store{\Meval(|t|'_{11} |.f|_1 | = t|_{12} |; MB|_2)}{\mu}
  $}
  \next
  \AxiomC{$\Store{|t|_{12} \to |t|'_{12}}{\mu}$}
  \RuleLabel{ES-EvalRight}
  \UnaryInfC{$
    \Store{\Meval(|v|_{11} |.f|_1 | = t|_{12} |; MB|_2)}{\mu} \to
    \Store{\Meval(|v|_{11} |.f|_1 | = t|'_{12} |; MB|_2)}{\mu}
  $}
  \next
  \AxiomC{$\Fields(|C|) = \Cbar C| |\Cbar f$}
  \AxiomC{$\mu(l_1) = \Obj{|C|}{\Cbar v}$}
  \RuleLabel{ES-EvalAssign}
  \BinaryInfC{$
    \begin{aligned}
      &\PhantomRel\to
      \Store{\Meval(l_1|.f|_i | = v|'_i|; MB|_2)}{\mu} \\
      &\to
      \Store{\Meval(|MB|_2)}{\Subst{l_1 \mapsto \Obj{|C|}{
        |v|_j \Indices{j\in1..i-1} |, |
        |v|'_i |, |
        |v|_k \Indices{k\in i+1..n}
      }}\mu}
    \end{aligned}
  $}
  \next
  \AxiomC{\hbox{\phantom0}}
  \RuleLabel{ES-EvalReturn}
  \UnaryInfC{$\Store{\Meval(|return t|_1|;|)}{\mu} \to \Store{|t|_1}{\mu}$}
  \next
  \AxiomC{$\Sub{|C|}{|D|}$}
  \AxiomC{$\mu(l) = \Obj{|C|}{\Cbar v}$}
  \RuleLabel{ES-CastLoc}
  \BinaryInfC{$\Store{|(D)| l}{\mu} \to \Store{l}{\mu}$}
  \next
  \AxiomC{$\Store{|t|_0}{\mu} \to \Store{|t|'_0}{\mu}$}
  \RuleLabel{ES-Field}
  \UnaryInfC{$\Store{|t|_0 |.f|}{\mu} \to \Store{|t|'_0 |.f|}{\mu}$}
  \next
  \AxiomC{$\Store{|t|_0}{\mu} \to \Store{|t|'_0}{\mu}$}
  \RuleLabel{ES-InvkRecv}
  \UnaryInfC{$
    \Store{|t|_0 |.m| \CParen{\Cbar t}}{\mu}
    \to
    \Store{|t|'_0 |.m| \CParen{\Cbar t}}{\mu}
  $}
  \next
  \AxiomC{$\Store{|t|_i}{\mu} \to \Store{|t|'_i}{\mu}$}
  \RuleLabel{ES-InvkArg}
  \UnaryInfC{$
    \begin{aligned}
      &\PhantomRel\to
        \Store{|v|_0 |.m| \CParen{\Cbar v|, t|_i|, |\Cbar t}}{\mu} \\
      &\to
        \Store{|v|_0 |.m| \CParen{\Cbar v|, t|'_i|, |\Cbar t}}{\mu}
    \end{aligned}
  $}
  \next
  \AxiomC{$\Store{|t|_i}{\mu} \to \Store{|t|'_i}{\mu}$}
  \RuleLabel{ES-NewArg}
  \UnaryInfC{$
    \begin{aligned}
      &\PhantomRel\to
        \Store{|new C| \CParen{\Cbar v|, t|_i|, |\Cbar t}}{\mu} \\
      &\to
        \Store{|new C| \CParen{\Cbar v|, t|'_i|, |\Cbar t}}{\mu}
    \end{aligned}
  $}
  \next
  \AxiomC{$\Store{|t|_0}{\mu} \to \Store{|t|'_0}{\mu}$}
  \RuleLabel{ES-Cast}
  \UnaryInfC{$\Store{|(D)t|_0}{\mu} \to \Store{|(D)t|'_0}{\mu}$}
\end{Proofs}
}

\paragraph{Typing:}
The typing rules are almost same as the original FJ,
  except for the method typing.
\begin{Proofs}
  \AxiomC{$
    \begin{aligned}
      &\CtxTyRel{\Cbar x|:|\Cbar C, |this:C|}{|t|_0}{|E|_0} \\
      &\CtxTyRel{\Cbar x|:|\Cbar C, |this:C|}{\Cbar t_1}{\Cbar E_1} \\
      &\CtxTyRel{\Cbar x|:|\Cbar C, |this:C|}{\Cbar t_2 |.| \Cbar f}{\Cbar E_2}
    \end{aligned}
  $}
  \AxiomC{$
    \begin{aligned}
      &\Sub{|E|_0}{|C|_0} \qquad \Sub{\Cbar E_1}{\Cbar E_2} \\
      &\CT(|C|) = |class C extends D \{| \ldots |\}| \\
      &\Override(|m|, |D|, \Cbar C \to |C|_0)
    \end{aligned}
  $}
  \BinaryInfC{$
    |C|_0 | m|\CParen{\Cbar C| |\Cbar x}| \{|
    \Cbar t_2 |.| \Cbar f |=| \Cbar t_1 |; return t|_0|;|
    |\} OK in C|
  $}
\end{Proofs}

\Ex{19.4.4}
{
\newcommand\Try{\It{try}}
\paragraph{Syntax:}
Change method declarations and terms as follows.
\begin{flalign*}
  |M| ::=& && \\
    & \vdots && \\
    & |C m| \CParen{\Cbar C| |\Cbar x} | \{ try \{ return t; \} |\Cbar{CA}| \}| && \\
  |CA| ::=& && \\
    & |catch (C t) \{ return t; \}| && \\
  |t| ::=& && \\
    & \vdots && \\
    & |throw t| && \\
    & \Try(|t|, \Cbar E| |\Cbar x| |\Cbar t) &&
\end{flalign*}
Here, \Try{} is a term in the |try| block that is being evaluated.

\paragraph{Auxiliary functions:}
Let us add the following cases to the definition of \Mtype{} and \Mbody{}.
\begin{Proofs}
  \AxiomC{$\CT(|C|) = \ClassDefDefault$}
  \AxiomC{$
    |B m | \CParen{\Cbar B| |\Cbar x} | \{|
    |try \{ return t; \} |\Cbar{CA} |\}| \in \Cbar M
  $}
  \BinaryInfC{$\Mtype(|m|, |C|) = \Cbar B \to |B|$}
  \next
  \AxiomC{$\CT(|C|) = \ClassDefDefault$}
  \AxiomC{$
    \begin{aligned}
      &|B m | \CParen{\Cbar B| |\Cbar x} | \{|
       |try \{ return t; \} |\Cbar{CA} |\}| \in \Cbar M \\
      &|CA|_i = |catch | \CParen{|E|_i | y|_i} | \{ return t|_i|; \}|
    \end{aligned}
  $}
  \BinaryInfC{$\Mbody(|m|, |C|) = (\Cbar x, |t|, \Cbar E| |\Cbar y| |\Cbar t)$}
\end{Proofs}

\paragraph{Evaluation:}
We add the following rules.
\begin{Proofs}
  \AxiomC{$\Mbody(|m|, |C|) = (\Cbar x, |t|, \Cbar E| |\Cbar y| |\Cbar t)$}
  \RuleLabel{E-Invk-New-Try}
  \UnaryInfC{$
    \begin{aligned}
      \CParen{|new C|\CParen{\Cbar v}} |.m| \CParen{\Cbar u}
      \to
      \Try(
        &\Subst{\Cbar x \mapsto \Cbar u, |this| \mapsto |new C| \CParen{\Cbar v}} |t|_0, \\
        &\Cbar E| |\Cbar y| |
         \Subst{\Cbar x \mapsto \Cbar u, |this| \mapsto |new C| \CParen{\Cbar v}} \Cbar t
      )
    \end{aligned}
  $}
  \next
  \AxiomC{}
  \RuleLabel{E-Try}
  \UnaryInfC{$\Try(|v|, \Cbar E| |\Cbar x| |\Cbar t) \to |v|$}
  \next
  \AxiomC{$|v| = |new C(|\Cbar t_0|)|$}
  \AxiomC{$\Sub{|C|}{|E|_j}$}
  \AxiomC{$\forall i<j, ~ |C| \not\Sb |E|_i$}
  \RuleLabel{E-Catch}
  \TrinaryInfC{$
    \Try(|throw v|, \Cbar E| |\Cbar x| |\Cbar t)
    \to
    \Subst{|x|_j \mapsto |v|_j} |t|_j
  $}
  \next
  \AxiomC{$|v| = |new C(|\Cbar t_0|)|$}
  \AxiomC{$\forall i, ~ |C| \not\Sb |E|_i$}
  \RuleLabel{E-Try-Throw}
  \BinaryInfC{$
    \Try(|throw v|, \Cbar E| |\Cbar x| |\Cbar t)
    \to
    |throw v|
  $}
  \next
  \AxiomC{$|t| \to |t|'$}
  \RuleLabel{E-Throw}
  \UnaryInfC{$|throw t| \to |throw t|'$}
  \next
  \AxiomC{}
  \RuleLabel{E-Throw-Field}
  \UnaryInfC{$|(throw v).f| \to |throw v|$}
  \next
  \AxiomC{}
  \RuleLabel{E-Throw-Invk-Recv}
  \UnaryInfC{$|(throw v).m(|\Cbar t|)| \to |throw v|$}
  \next
  \AxiomC{}
  \RuleLabel{E-Throw-Invk-Arg}
  \UnaryInfC{$|v|_0|.m(|\Cbar v|, throw v, |\Cbar t|)| \to |throw v|$}
  \next
  \AxiomC{}
  \RuleLabel{E-Throw-New}
  \UnaryInfC{$|new C(|\Cbar v|, throw v, |\Cbar t|)| \to |throw v|$}
  \next
  \AxiomC{}
  \RuleLabel{E-Throw-Cast}
  \UnaryInfC{$|(D)(throw v)| \to |throw v|$}
\end{Proofs}

\paragraph{Typing}
We add the following rule to type |throw| terms.
\begin{Proofs}
  \AxiomC{$\CtxTyRel{\Gamma}{|throw t|}{|C|}$}
\end{Proofs}
We also add the following case to method typing.
\begin{Proofs}
  \AxiomC{$
    \begin{aligned}
      &\CtxTyRel{\Cbar x|:|\Cbar C, |this:C|}{|t|}{|C|_0} \\
      \forall i\in1..n, ~
      &\CtxTyRel{\Cbar x|:|\Cbar C, |this:C|, |x|_i|:E|_i}{|t|_i}{|C|_i}
    \end{aligned}
  $}
  \AxiomC{$
    \begin{aligned}
      &\Sub{|C|_0}{|B|} \\
      \forall i\in1..n, ~
      &\Sub{|C|_i}{|B|}
    \end{aligned}
  $}
  \BinaryInfC{$
    |B m | \CParen{\Cbar C| |\Cbar x} | \{ try \{return t;\} |
      |catch | \CParen{|E|_i | x|_i} | \{return t|_i|;\} |
      \Indices{i\in1..n}
    |\} OK in C|
  $}
\end{Proofs}
}

\Ex{19.4.5}
We can remove the subtyping premises except for \Rule{T-DCast} and \Rule{T-SCast}.

\Ex{19.4.6}
\begin{enumerate}
  \item Let |I| and |J| be metavariables for interfaces,
    and |S|, |T|, and |U| be metavariables for types including classes and interfaces.

    \paragraph{Syntax:} Redefine the syntax as follows.
    \begin{flalign*}
      |CL| ::=& && \\
      &|class C extends C, |\Cbar I| \{|\Cbar T| |\Cbar f|; K |\Cbar M|\}| && \\
      |K| ::=& && \\
        &|C|\CParen{\Cbar T| |\Cbar f}| \{super|\CParen{\Cbar f}|; this.|\Cbar f|=|\Cbar f|;\}| && \\
      |M| ::=& && \\
        &|T m| \CParen{\Cbar T| |\Cbar x} |\{return t;\}| && \\
      |IF| ::=& && \\
        &|interface I extends |\Cbar I| \{|\Cbar{AM}|\}| && \\
      |AM| ::=& && \\
        &|T m| \CParen{\Cbar T| |\Cbar x} |;| && \\
      |T| ::=& && \\
        &|C| && \\
        &|I| && \\
      |t| ::=& ~ \dots && \\
      |v| ::=& ~ \dots &&
    \end{flalign*}
    Note that an interface may have no superinterface,
      in which case the |extends| keyword is omitted.
    The class table \CT{} is extended to also accomodate interface definitions.

    \paragraph{Subtyping}
    Define the subtyping rules as follows.
    \begin{Proofs}
      \AxiomC{$\Sub{|T|}{|T|}$}
      \next
      \AxiomC{$\Sub{|S|}{|T|}$}
      \AxiomC{$\Sub{|T|}{|U|}$}
      \BinaryInfC{$\Sub{|S|}{|U|}$}
      \next
      \AxiomC{$\CT(|C|) = |class C extends D, |\Cbar I| \{| \dots |\}|$}
      \UnaryInfC{$\Sub{|C|}{|D|}$}
      \next
      \AxiomC{$\CT(|C|) = |class C extends D, I|_i \Indices{i\in1..n} | \{| \dots |\}|$}
      \UnaryInfC{$\Sub{|C|}{|I|_j}$}
      \next
      \AxiomC{$\CT(|I|) = |interface I extends I|_i \Indices{i\in1..n} | \{| \dots |\}|$}
      \UnaryInfC{$\Sub{|I|}{|I|_j}$}
    \end{Proofs}
    We omit the subtyping relation $\Sub{|I|}{|Object|}$
      which exists in Java;
      one has to explicitly side-cast a term of any interface type to |Object|
      when needed.
    Note that any class is still a subtype of |Object|,
      and thus such a side-cast always succeeds.

    \paragraph{Auxiliary functions:}
    We update \Mtype{} and \Override{} as follows.
    \begin{Proofs}
      \AxiomC{$
        \CT(|C|) = |class C extends D, |\Cbar I| \{|
          \Cbar S| |\Cbar f|; K |\Cbar M
        |\}|
      $}
      \AxiomC{$
        |T m |\CParen{\Cbar T| |\Cbar x}| \{|\dots|\}| \in \Cbar M
      $}
      \BinaryInfC{$\Mtype(|m|, |C|) = \Cbar T \to |T|$}
      \next
      \AxiomC{$\Mtype(|m|, |C|) = \Cbar S \to |S|_0$
              implies
              $\Cbar T = \Cbar S$ and $|T|_0 = |S|_0$}
      \UnaryInfC{$\Override(|m|, |C|, \Cbar T \to \Cbar T_0)$}
    \end{Proofs}

    \paragraph{Evaluation:}
    Update the \Rule{E-CastNew} rule as follows.
    \begin{Proofs}
      \AxiomC{$\Sub{|C|}{|T|}$}
      \RuleLabel{E-CastNew}
      \UnaryInfC{$
        \CParen{|T|}\CParen{|new C|\CParen{\Cbar v}}
        \to
        |new C|\CParen{\Cbar v}
      $}
    \end{Proofs}

    \paragraph{Typing}
    Finally, update the typing rules as follows.
    \begin{Proofs}
      \AxiomC{$|x:T| \in \Gamma$}
      \RuleLabel{T-Var}
      \UnaryInfC{$\CtxTyRel{\Gamma}{|x|}{|T|}$}
      \next
      \AxiomC{$\CtxTyRel{\Gamma}{|t|_0}{|C|_0}$}
      \AxiomC{$\Fields(|C|_0) = \Cbar T| |\Cbar f$}
      \RuleLabel{T-Field}
      \BinaryInfC{$\CtxTyRel{\Gamma}{|t|_0|.f|_i}{|T|_i}$}
      \next
      \AxiomC{$\CtxTyRel{\Gamma}{|t|_0}{|T|_0}$}
      \AxiomC{$\Mtype(|m|, |T|_0) = \Cbar S \to |T|$}
      \AxiomC{$\CtxTyRel{\Gamma}{\Cbar t}{\Cbar T}$}
      \AxiomC{$\Sub{\Cbar T}{\Cbar S}$}
      \RuleLabel{T-Invk}
      \QuaternaryInfC{$\CtxTyRel{\Gamma}{|t|_0|.m|\CParen{\Cbar t}}{|T|}$}
      \next
      \AxiomC{$\Fields(|C|) = \Cbar S| |\Cbar f$}
      \AxiomC{$\CtxTyRel{\Gamma}{\Cbar t}{\Cbar T}$}
      \AxiomC{$\Sub{\Cbar T}{\Cbar S}$}
      \RuleLabel{T-New}
      \TrinaryInfC{$\CtxTyRel{\Gamma}{|new C|\CParen{\Cbar t}}{|C|}$}
      \next
      \AxiomC{$\CtxTyRel{\Gamma}{|t|_0}{|S|}$}
      \AxiomC{$\Sub{|S|}{|T|}$}
      \RuleLabel{T-UCast}
      \BinaryInfC{$\CtxTyRel{\Gamma}{\CParen{|T|}|t|_0}{|T|}$}
      \next
      \AxiomC{$\CtxTyRel{\Gamma}{|t|_0}{|T|}$}
      \AxiomC{$\Sub{|S|}{|T|}$}
      \AxiomC{$|S| \neq |T|$}
      \RuleLabel{T-DCast}
      \TrinaryInfC{$\CtxTyRel{\Gamma}{\CParen{|S|}|t|_0}{|S|}$}
      \next
      \AxiomC{$\CtxTyRel{\Gamma}{|t|_0}{|S|}$}
      \AxiomC{$|S| \not\Sb |T|$}
      \AxiomC{$|T| \not\Sb |S|$}
      \AxiomC{\It{stupid warning}}
      \RuleLabel{T-SCast}
      \QuaternaryInfC{$\CtxTyRel{\Gamma}{\CParen{|T|}|t|_0}{|T|}$}
      \next
      \AxiomC{$
        \begin{gathered}
          \CtxTyRel{\Cbar x|:|\Cbar T, |this:C|}{|t|_0}{|S|_0} \\
          \CT(|C|) = |class C extends D, |\Cbar I| \{|\dots|\}|
        \end{gathered}
      $}
      \AxiomC{$\Sub{|S|_0}{|T|_0}$}
      \AxiomC{$
        \begin{gathered}
          \Override(|m|, |J|, \Cbar T \to |T|_0) \\
          |J| = |D |\text{or one of}| |\Cbar I
        \end{gathered}
      $}
      \TrinaryInfC{$
        |T|_0| m |\CParen{\Cbar T| |\Cbar x}| \{return t|_0|;\} OK in C|
      $}
    \end{Proofs}

  \item Suppose the following declarations.
    \begin{Code}
  interface A {}
  interface B {}
  interface C extends A, B {}
  interface D extends A, B {}
    \end{Code}
    Then, types |C| and |D| have common supertypes |A| and |B|,
      but no least common supertype.

  \item In Java's conditional expression,
      one branch must have a supertype of the other's,
      which is the type of the expression.
    We cannot relax this rule by type-checking a conditional
      as a join of the types of branches,
      since we may have no unique join in general.
\end{enumerate}

\Ex{19.4.7}
{
\newcommand\Super{\It{super}}
We employ preprocessing on the syntax tree
  to automatically annotate the class whose method should be invoked
  with |super| syntax.
Define the super method call syntax as $|super.m|\CParen{\Cbar t}$.
For every appearance of this syntax in a class that extends |D|,
  rewrite this term to $\Super(|D|, |this|)|.m|\CParen{\Cbar t}$.

\paragraph{Syntax:}
Add the following syntax to terms.
\begin{flalign*}
  |t| ::=& && \\
    & \dots && \\
    & \Super(|C|, |x|)|.m|\CParen{\Cbar t} &&
\end{flalign*}

\paragraph{Evaluation:}
Add the following rule to evaluation.
\begin{Proofs}
  \AxiomC{$\Mbody(|m|, |D|) = (\Cbar x, |t|_0)$}
  \RuleLabel{E-InvkSuper}
  \UnaryInfC{$
    \Super(|D|, |new C|\CParen{\Cbar v}) |.m| \CParen{\Cbar u}
    \to
    \Subst{\Cbar x \mapsto \Cbar u, |this| \mapsto |new C| \CParen{\Cbar v}} |t|_0
  $}
\end{Proofs}

\paragraph{Typing:}
Add the following rule to term typing.
\begin{Proofs}
  \AxiomC{$\Mtype(|m|, |C|_0) = \Cbar D \to |C|$}
  \AxiomC{$\CtxTyRel{\Gamma}{\Cbar t}{\Cbar C}$}
  \AxiomC{$\Sub{\Cbar C}{\Cbar D}$}
  \RuleLabel{T-InvkSuper}
  \TrinaryInfC{$
    \CtxTyRel{\Gamma}{\Super(|C|_0, |v|_0) |.m| \CParen{\Cbar t}}{|C|}
  $}
\end{Proofs}
}

\Ex{19.5.1}
We need the following lemmata.

\Lemma{19.5.1.1}.
If $\CtxTyRel{\Gamma, |x:C|}{|t|}{|D|}$, $\CtxTyRel{\Gamma}{|t|_0}{|C|'}$,
  and $\Sub{|C|'}{|C|}$,
  then $\CtxTyRel{\Gamma}{\Subst{|x| \mapsto |t|_0} |t|}{|D|}$.

\Proof: \Todo

\Lemma{19.5.1.2}.
If $\Mtype(|m|, |C|_0) = \Cbar D \to |C|$ and $\Sub{|D|_0}{|C|_0}$,
  then $\Mtype(|m|, |D|_0) = \Cbar D \to |C|$.

\Proof: \Todo

\It{Proof of Theorem 19.5.1}:
By induction on typing derivations.
We perform case analysis on the last rule used in the derivation.

\Case\Rule{T-Var}: Impossible; there is no rule that evaluates a variable.

\Case\Rule{T-Field}: $|t| = |t|_0|.f|_i, ~ |C| = |C|_i$ \\
  The evaluation rule applied to |t| is either
  \Rule{E-ProjNew} or \Rule{E-Field}.
  \begin{itemize}
    \item \Subcase\Rule{E-ProjNew}:
        $|t|_0 = |new C|\CParen{\Cbar v}, ~ |t|' = |v|_i$ \\
      The premises of \Rule{T-Field} give
        $\CtxTyRel{\Gamma}{|new C|\CParen{\Cbar v}}{|C|_0}$ and
        $\Fields(|C|_0) = \Cbar C| |\Cbar f$.
      The former relation is derived only from \Rule{T-New},
        which gives $|C|_0 = |C|$ and $\CtxTyRel{\Gamma}{\Cbar v}{\Cbar D}$,
        where $\Cbar D$ satisfies $\Sub{\Cbar D}{\Cbar C}$.
      Therefore, $\CtxTyRel{\Gamma}{|v|_i}{|D|_i}$ and $\Sub{|D|_i}{|C|_i}$.
    \item \Subcase\Rule{E-Field}: $|t|_0 \to |t|'_0, ~ |t|' = |t|'_0|.f|_i$ \\
      The first premise of \Rule{T-Field} gives $\CtxTyRel{\Gamma}{|t|_0}{|C|_0}$.
      By the induction hypothesis, $\CtxTyRel{\Gamma}{|t|'_0}{|C|'_0}$
        for some $\Sub{|C|'_0}{|C|_0}$.
      By definition, $\Fields(|C|'_0)$ includes $\Fields(|C|_0)$.
      Therefore, applying \Rule{T-Field} to $|t|'_0$ gives
        $\CtxTyRel{\Gamma}{|t|'_0|.f|_i}{|C|_i}$.
  \end{itemize}

\Case\Rule{T-Invk}: $|t| = |t|_0|.m|\CParen{\Cbar t}$ \\
  There are three evaluation rules applicable to |t|.
  In either case, we use $\CtxTyRel{\Gamma}{|t|_0}{|C|_0}$ that is obtained as
    the first premise of \Rule{T-Invk}.
  \begin{itemize}
    \item \Subcase\Rule{E-InvkNew}:
        \vtop{
          $|t|_0 = |new D|\CParen{\Cbar v}$, ~
          $|t|' = \Subst{\Cbar x \mapsto \Cbar t, |this| \mapsto |new D|\CParen{\Cbar v}} |s|_0$ \\
          where $\Mbody(|m|, |D|) = (\Cbar x, |s|_0)$
        } \\
      Since $|t|_0 = |new D|\CParen{\Cbar v}$,
        its type is derived only from \Rule{T-New},
        with which we obtain $|D| = |C|_0$.
      The second premise of \Rule{T-Invk} gives $\Mtype(|m|, |C|_0) = \Cbar D \to |C|$.
      Combining the premises of the derivation of \Mbody{} and \Mtype{},
        we recover the definition of method |m| in the least supertype $|B|_0$ of $|C|_0$
        that defines |m| as $|M| = |C m| \CParen{\Cbar D| |\Cbar x}| \{return s|_0|;\}|$.
      The premises of the method typing $|M OK in B|_0$ gives
        $\CtxTyRel{\Cbar x|:|\Cbar D, |this:B|_0}{|s|_0}{|E|}$
        where $\Sub{|E|}{|C|}$.
      Therefore,
        combining it with the other premises of \Rule{T-Invk} that give
        $\CtxTyRel{\Gamma}{\Cbar t}{\Cbar C}$ and $\Sub{\Cbar C}{\Cbar D}$,
        we obtain
        $\CtxTyRel{\Gamma}{
           \Subst{\Cbar x \mapsto \Cbar t, |this| \mapsto |new C|_0\CParen{\Cbar v}} |s|_0
         }{|E|}$ by \Lemma{19.5.1.1}.
    \item \Subcase\Rule{E-Invk-Recv}:
        $|t|' = |t|'_0|.m|\CParen{\Cbar t}$ where $|t|_0 \to |t|'_0$ \\
      By the induction hypothesis, $\CtxTyRel{\Gamma}{|t|'_0}{|D|_0}$ where
        $\Sub{|D|_0}{|C|_0}$.
      The second premise of \Rule{T-Invk} gives $\Mtype(|m|, |C|_0) = \Cbar D \to |C|$.
      By \Lemma{19.5.1.2}, $\Mtype(|m|, |D|_0) = \Cbar D \to |C|$.
      Therefore, by applying \Rule{T-Invk} to $|t|'_0$,
        we obtain $\CtxTyRel{\Gamma}{|t|'_0|.m|\CParen{\Cbar t}}{|C|}$.
    \item \Subcase\Rule{E-Invk-Arg}:
        \vtop{
          $
            |t|_0 = |v|_0, ~
            \Cbar t = (\Cbar v|, t|_i|, |\Cbar s), ~
            |t|' = |v|_0|.m|\CParen{\Cbar v|, t|'_i|, |\Cbar s}
          $
          where \\
          $|t|_i \to |t|'_i$
        }
      The third premise of \Rule{T-Invk} gives $\CtxTyRel{\Gamma}{|t|_i}{|C|_i}$.
      By the induction hypothesis, $\CtxTyRel{\Gamma}{|t|'_i}{|C|'_i}$
        where $\Sub{|C|'_i}{|C|_i}$.
      By the fourth premise of \Rule{T-Invk} and the transitivity of subtyping,
        we have $\Sub{|C|'_i}{|D|_i}$.
      Therefore, by applying \Rule{T-Invk} to $|t|'$,
        we obtain $\CtxTyRel{\Gamma}{|t|'}{|C|}$.
  \end{itemize}

\Case\Rule{T-New}: $|t| = |new C|\CParen{\Cbar t}$ \\
  The evaluation rule applicable to |t| is only \Rule{E-New-Arg},
    where $|t| = |new C|\CParen{\Cbar v|, t|_i|, |\Cbar s}$
    and $|t|' = |new C|\CParen{\Cbar v|, t|'_i|, |\Cbar s}$ with $|t|_i \to |t|'_i$.
  The second premise of \Rule{T-New} gives $\CtxTyRel{\Gamma}{|t|_i}{|C|_i}$.
  By the induction hypothesis, $\CtxTyRel{\Gamma}{|t|'_i}{|C|'_i}$
    for some $\Sub{|C|'_i}{|C|_i}$.
  The other premises of \Rule{T-New} give $\Fields(|C|) = \Cbar D| |\Cbar f$ and
    $\Sub{\Cbar C}{\Cbar D}$.
  By the transitivity of subtyping, $\Sub{|C|'_i}{|D|_i}$.
  Therefore, \Rule{T-New} gives
    $\CtxTyRel{\Gamma}{|new C|\CParen{\Cbar v|, t|'_i|, |\Cbar s}}{|C|}$.

\Case\Rule{T-UCast}: $|t| = \CParen{|C|}|t|_0$ \\
  The evaluation rule applicable to |t| is either \Rule{E-CastNew} or \Rule{E-Cast}.
  \begin{itemize}
    \item \Subcase\Rule{E-CastNew}: $|t|' = |t|_0 = |new D|\CParen{\Cbar v}$ \\
      By the first premise of \Rule{T-UCast}, $\CtxTyRel{\Gamma}{|t|_0}{|D|}$.
      By the premise of \Rule{E-CastNew}, $\Sub{|D|}{|C|}$.
    \item \Subcase\Rule{E-Cast}:
        $|t|' = \CParen{|C|}|t|'_0$ where $|t|_0 \to |t|'_0$ \\
      The premises of \Rule{T-UCast} give
        $\CtxTyRel{\Gamma}{|t|_0}{|D|}$ and $\Sub{|D|}{|C|}$.
      By the induction hypothesis, $\CtxTyRel{\Gamma}{|t|'_0}{|E|}$
        where $\Sub{|E|}{|D|}$.
      By the transitivity of subtyping, $\Sub{|E|}{|C|}$.
      By applying \Rule{T-UCast} to $|t|'_0$,
        we obtain $\CtxTyRel{\Gamma}{\CParen{|C|}|t|'_0}{|C|}$.
  \end{itemize}

\Case\Rule{T-DCast}: $|t| = \CParen{|C|}|t|_0$ \\
  Again, the evaluation rule applicable to |t| is
    either \Rule{E-CastNew} or \Rule{E-Cast}.
  \begin{itemize}
    \item \Subcase\Rule{E-CastNew}:
      Impossible; the premises of \Rule{E-CastNew} and \Rule{T-DCast} contradict.
    \item \Subcase\Rule{E-Cast}:
        $|t|' = \CParen{|C|}|t|'_0$ where $|t|_0 \to |t|'_0$ \\
      The first two premises of \Rule{T-DCast} give
        $\CtxTyRel{\Gamma}{|t|_0}{|D|}$ and $\Sub{|C|}{|D|}$.
      By the induction hypothesis,
        $\CtxTyRel{\Gamma}{|t|'_0}{|E|}$ for some $\Sub{|E|}{|D|}$.
      Depending on the subtyping relation between |C| and |E|,
        we can use either of \Rule{T-UCast}, \Rule{T-DCast}, or \Rule{T-SCast}
        to obtain $\CtxTyRel{\Gamma}{\CParen{|C|}|t|'_0}{|C|}$.
      Note that, when there is no subtyping relation between |C| and |E|,
        we need to additionally emit a \It{stupid warning} on type checking $|t|'$.
      This case may happen when one writes a side cast as a combination of
        upcasts and downcasts.
  \end{itemize}

\Case\Rule{T-SCast}: Similar to \Case\Rule{T-DCast}. \qed

\Ex{19.5.5, 19.5.6}
Omitted.

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 20.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Recursive Types}

\Ex{20.1.1}
\begin{Code}
  NatTree = $\Mu$X. <leaf:Unit, node:{Nat, X, X}>;

  leaf = <leaf=unit> as NatTree;
  node = $\Lm$n:Nat. $\Lm$l:NatTree. $\Lm$r:NatTree.
             <node={l, n, r}> as NatTree;

  isleaf = $\Lm$t:NatTree. case t of
                            <leaf=u> $\To$ true
                          | <node=n> $\To$ false;
  label = $\Lm$t:NatTree. case t of <leaf=u> $\To$ 0 | <node=n> $\To$ n.1;
  left = $\Lm$t:NatTree. case t of <leaf=u> $\To$ u | <node=n> $\To$ n.2;
  right = $\Lm$t:NatTree. case t of <leaf=u> $\To$ u | <node=n> $\To$ n.3;

  dfs = fix (
      $\Lm$f:NatList$\to$NatTree$\to$NatList.
      $\Lm$l:NatList. $\Lm$t:NatTree.
          case t of <leaf=u> $\To$ l
                  | <node=n> $\To$ cons n.1 (f (f l n.2) n.3)
  ) nil;
\end{Code}

\Ex{20.1.2}
Let $|plus:Nat|\to|Nat|\to|Nat|$ be a function that adds two numbers.
\begin{Code}
  fib = fix (
      $\Lm$f:Nat$\to$Nat$\to$Stream.
      $\Lm$m:Nat. $\Lm$n:Nat. $\Lm$_:Unit. {n, f n (plus m n)}
  ) 0 1;
\end{Code}

\Ex{20.1.3}
\begin{Code}
  BackupCounter = $\Mu$C. {get:Nat, inc:Unit$\to$C, dec:Unit$\to$C,
                           backup:Unit$\to$C, reset:Unit$\to$C};
  c = let create = fix (
      $\Lm$f:{x:Nat, b:Nat}$\to$BackupCounter. $\Lm$s:{x:Nat, b:Nat}.
        {get = s.x,
         inc = $\Lm$_:Unit. f {x=succ(s.x), b=s.b},
         dec = $\Lm$_:Unit. f {x=pred(s.x), b=s.b},
         backup = $\Lm$_:Unit. f {x=s.x, b=s.x},
         reset = $\Lm$_:Unit. f {x=s.b, b=s.b}}
  ) in create {x=0, b=0};
\end{Code}

\Ex{20.1.4}
Extend the encoding with booleans and conditionals as follows.
\begin{Code}
  D = $\Mu$X. <nat:Nat, bool:Bool, fn:X$\to$X>;
  lam = $\Lm$f:D$\to$D. <fn=f> as D;
  ap = $\Lm$f:D. $\Lm$a:D.
           case f of <nat=n> $\To$ diverge$_D$ unit
                   | <bool=b> $\To$ diverge$_D$ unit
                   | <fn=f> $\To$ f a;
  ifels = $\Lm$c:D. $\Lm$t:D. $\Lm$e:D.
              case c of <bool=b> $\To$ if b then t else e
                      | <nat=n> $\To$ diverge$_D$ unit
                      | <fn=f> $\To$ diverge$_D$ unit;
\end{Code}
The terms
\begin{Code}
  if false then 1 else 0;
  if false then 1 else false;
\end{Code}
  are encoded as
\begin{Code}
  ifels (<bool=false> as D) (<nat=1> as D) (<nat=0> as D);
  ifels (<bool=false> as D) (<nat=1> as D) (<bool=false> as D);
\end{Code}
These terms are evaluated to |<nat=0> as D| and |<bool=false> as D|, respectively.

\Ex{20.1.5}
\begin{Code}
  D = $\Mu$X. <nat:Nat, fn:X$\to$X, rcd:Nat$\to$X>;
  lam = $\Lm$f:D$\to$D. <fn=f> as D;
  ap = $\Lm$f:D. $\Lm$a:D.
           case f of <nat=n> $\To$ diverge$_D$ unit
                   | <fn=f> $\To$ f a
                   | <rcd=r> $\To$ diverge$_D$ unit;
  rcd = $\Lm$r:Nat$\to$D. <rcd=r> as D;
  rcdset = $\Lm$f:D. $\Lm$k:Nat. $\Lm$v:D.
           case f of
             <nat=n> $\To$ diverge$_D$ unit
           | <fn=f> $\To$ diverge$_D$ unit
           | <rcd=r> $\To$ <rcd=$\Lm$n:Nat. if eq n k then v else r n> as D;
  rcdproj = $\Lm$f:D. $\Lm$k:Nat.
            case f of
              <nat=n> $\To$ diverge$_D$ unit
            | <fn=f> $\To$ diverge$_D$ unit
            | <rcd=r> $\To$ r k;
\end{Code}

\Ex{20.2.1}
Hungry functions:
\begin{Code}
  Hungry = $\Mu$A. Nat$\to$A;
  f = fold[Hungry] (fix ($\Lm$f:Nat$\to$Hungry. $\Lm$n:Nat. fold[Hungry] f))
\end{Code}
Streams:
\begin{Code}
  Stream = $\Mu$A. Unit$\to${Nat, A};
  hd = $\Lm$s:Stream. (unfold[Stream] s unit).1;
  tl = $\Lm$s:Stream. (unfold[Stream] s unit).2;
  upfrom0 = fold[Stream] (
      fix (
          $\Lm$f:Nat$\to$Stream. $\Lm$n:Nat.
              fold[Stream] ($\Lm$_:Unit. {n, f (succ n)})
      ) 0
  );
\end{Code}
Processes:
\begin{Code}
  Process = $\Mu$A. Nat$\to${Nat, A};
  p = fold[Process] (fix (
      $\Lm$f:Nat$\to$Process. $\Lm$acc:Nat. fold[Process] (
          $\Lm$n:Nat. let newacc = plus acc n in {newacc, f newacc}
      )
  ) 0);
  curr = $\Lm$s:Process. (unfold[Process] s 0).1;
  send = $\Lm$n:Nat. $\Lm$s:Process. (unfold[Process] s n).2;
\end{Code}
Objects:
\begin{Code}
  Counter = $\Mu$C. {get:Nat, inc:Unit$\to$C, dec:Unit$\to$C};
  c = let create = fix ($\Lm$f: {x:Nat}$\to$Counter. $\Lm$s: {x:Nat}.
                            fold[Counter] {
                                get = s.x,
                                inc = $\Lm$_:Unit. f {x=succ(s.x)},
                                dec = $\Lm$_:Unit. f {x=pred(s.x)}
                            })
      in create {x=0};
\end{Code}
Fixed-point:
\begin{Code}
  fix$_T$ = $\Lm$f:T$\to$T.
      ($\Lm$x:($\Mu$A.A$\to$T). f (unfold[$\Mu$A.A$\to$T] x x))
      (fold[$\Mu$A.A$\to$T] ($\Lm$x:($\Mu$A.A$\to$T). f (unfold[$\Mu$A.A$\to$T] x x)));
  diverge$_T$ = $\Lm$_:Unit. fix$_T$ ($\Lm$x:T. x);
\end{Code}
Untyped lambda-calculus:
\begin{Code}
  D = $\Mu$X. X$\to$X;
  lam = fold[D];
  ap = unfold[D];
\end{Code}

\Ex{20.2.2}
\textsc{Progress}:
By induction on typing derivations.
We perform case analysis on the last rule used in the derivations.

\Case\Rule{T-Fld}: Immediate by the induction hypothesis.

\Case\Rule{T-Unfld}:
  The premise $\CtxTyRel{\Gamma}{|t|_1}{\Subst{|X|\mapsto|U|}|T|_1}$ is
    derived only by \Rule{T-Fld},
    and thus we can apply \Rule{E-UnfldFld} to proceed the evaluation.

\textsc{Preservation}:
By induction on evaluation derivations.
We again perform case analysis on the last rule used in the derivations.

\Case\Rule{E-UnfldFld}:
Immediate by combining \Rule{T-Fld} and \Rule{T-Unfld}.

\Case\Rule{E-Fld, E-Unfld}: Immediate by the induction hypothesis.  \qed

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 21.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Metatheory of Recursive Types}

\Ex{21.1.7}
\begin{alignat*}{4}
  &E_2(\emptyset) &&= \Set{a} & \qquad &E_2(\Set{a, b}) &&= \Set{a, c} \\
  &E_2(\Set{a}) &&= \Set{a} && E_2(\Set{a, c}) &&= \Set{a, b} \\
  &E_2(\Set{b}) &&= \Set{a} && E_2(\Set{b, c}) &&= \Set{a, b} \\
  &E_2(\Set{c}) &&= \Set{a, b} && E_2(\Set{a, b, c}) &&= \Set{a, b, c}
\end{alignat*}
The $E_2$-closed sets are $\Set{a}$ and $\Set{a, b, c}$.
The $E_2$-consistent stes are $\emptyset$, $\Set{a}$, and $\Set{a, b, c}$.
The extreme fixed points are $\mu E_2 = \Set{a}$ and $\nu E_2 = \Set{a, b, c}$.

\Ex{21.1.9}
\textsc{Ordinary induction on natural numbers}:
Suppose that a predicate $P$ on the natural numbers satisfies $P(0)$ and,
  for all $i$, $P(i)$ implies $P(i + 1)$.
Let $S_P = \Set{i \in \N \mid P(i)}$.
Define a monotone function $F$ on $\Pow(\N)$ by
  $F(S) = \Set{0} \cup \Set{i + 1 \mid i \in S}$.
By the conditions on $P$, 
  $F(S_P) \subseteq S_P$, i.e., $S_P$ is $F$-closed.
Therefore, by the principle of induction, $\mu F \subseteq S_P$.
By the definition of natural numbers,
  $\mu F = \N$, and thus $S_P = \N$.

\textsc{Lexicographic induction}:
{ \newcommand\NN{\N\times\N}
Suppose that a predicate $P$ on the pairs of natural numbers satisfies,
  for every $(i, j)$, $P(i, j)$ if $P(i', j')$ holds for all $(i', j') < (i, j)$.
Let $S_P = \Set{(i, j) \in \NN \mid P(i, j)}$.
Define a monotone function $F$ on $\Pow(\NN)$ by
  $F(S) = \Set{(i, j) \in \NN \mid \forall (i', j') < (i, j), ~ (i', j') \in S}$.
By the condition on $P$, $F(S_P) \subseteq S_P$, i.e., $S_P$ is $F$-closed.
Therefore, by the principle of induction, $\mu F \subseteq S_P$.
Assume $\mu F \neq \NN$ to derive contradiction.
Then, there exists $(k, l) = \min(\NN \setminus \mu F)$.
All the pairs smaller than $(k, l)$ belong to $\mu F$,
  and thus $(k, l) \in F(\mu F)$.
However, since $\mu F$ is $F$-closed, $(k, l) \in \mu F$, which contradicts.
Therefore, we obtain $\mu F = \NN$,
  and thus $S_P = \NN$. \qed
}

\Ex{21.2.2}
Define $\cU$ and $F$ as follows.
\begin{align*}
  \cU &= \Set{|T| \in \Set{1, 2}^* \Pto \Set{\to, \times, |Top|}
              \mid \EmptySeq \in \Dom(|T|), ~
                   (\pi, \sigma) \in \Dom(|T|) \To \sigma \in \Dom(|T|)}, \\
  F(S) &= \Set{|Top|} \cup
          \Set{|T|_1 \times |T|_2 \mid |T|_1, |T|_2 \in S} \cup
          \Set{|T|_1 \to |T|_2 \mid |T|_1, |T|_2 \in S}.
\end{align*}

Proof sketch of $\mu F = \cT_f$ and $\nu F = \cT$:

Since $\cT_f$ is $F$-closed, $\mu F \subseteq \cT_f$ by the principle of induction.
By the definition of tree types,
  any finite tree type |T| is written as either |Top|, $|T|_1 \times |T|_2$,
  or $|T|_1 \to |T|_2$.
Due to the finiteness,
  recursive applications of such decomposition stop at some point;
  i.e., they hit to the |Top| case at finite depths.
Therefore, |T| belongs to $F^n(\emptyset)$ for some finite $n$,
  i.e, $|T| \in \mu F$, and thus $\mu F = \cT_f$.

We also have that $\cT$ is $F$-consistent,
  and thus $\cT \subseteq \nu F$ by the principle of coinduction.
If $|T| \in \cU \setminus \cT$,
  then |T| is not written in a form of either |Top|, $|T|_1 \times |T|_2$, or
  $|T|_1 \to |T|_2$,
  and thus $|T| \notin \nu F$ since $\nu F$ is $F$-consistent.
Therefore, $\nu F = \cT$. \qed

\Ex{21.3.3}
A pair $(|Top|, |Top| \times |Top|)$ does not belong to $\nu S$.

\Ex{21.3.4}
Let $|T| = |Top| \to \CParen{|Top| \to \CParen{|Top| \to \dots}}$.
Then, a pair $(|T|, |T|)$ is related by $\nu S$ but not by $\mu S$.
It can be shown by observing that, to generate this pair with $S$,
  only the third rule could be used,
  for which we need both $(|Top|, |Top|)$ and $(|T|, |T|)$ in the fixed point.
The latter is the very original pair,
  and thus it cannot be generated inductively starting from the empty set.
It is also obvious that adding this pair to the set keeps the set fixed-point,
  and thus it still belongs to $\nu S$.

In the universe of finite trees, we have $\nu S_f = \mu S_f$.

\Ex{21.3.8}
Let $D = \Set{(|T|, |T|) \mid |T| \in \cT}$.
To show that $D$ is $S$-consistent,
  let $|T| \in \cT$ and show that $(|T|, |T|) \in S(D)$
  by case analysis on the shape of |T|.

\Case $|T| = |Top|$: Immediate.

\Case $|T| = |T|_1 \times |T|_2$:
  Since $(|T|_1, |T|_1), (|T|_2, |T|_2) \in D$,
    we have $(|T|_1 \times |T|_2, |T|_1 \times |T|_2) \in S(D)$.

\Case $|T| = |T|_1 \to |T|_2$: Similar to the previous case.

Therefore, $D \subseteq S(D)$, i.e., $D$ is $S$-consistent.
By the principle of coinduction, $D \subseteq \mu S$,
  i.e., $\mu S$ is reflexive. \qed

\Ex{21.4.2}
{ \newcommand\TR{\It{TR}}
For any $(x, y) \in \cU \times \cU$,
  we can take $z = x$ to have $(x, z), (z, y) \in \cU \times \cU$.
Therefore, $\TR(\cU \times \cU) = \cU \times \cU$,
  which implies $F^\TR(\cU \times \cU) = \cU \times \cU$.
That is, $\cU \times \cU$ is the largest fixed point of $F^\TR$. \qed
}

\Ex{21.5.2}
Let $x \in \cT_f \times \cT_f$ and $X \subseteq \cT_f \times \cT_f$.
There are four cases of the form of $x$.

\Case$x = (|T|, |Top|)$ where $|T| \in \cT_f$ \\
Then, $x \in S_f(\emptyset)$.
Obviously, $\emptyset \subseteq X$.

\Case$x = (|S|_1 \times |S|_2, |T|_1 \times |T|_2)$ where $(|S|_1, |T|_1), (|S|_2, |T|_2) \in \mu S_f$ \\
Then, $x \in S_f(\Set{(|S|_1, |T|_1), (|S|_2, |T|_2)})$.
If $x \in S_f(X)$, then $\Set{(|S|_1, |T|_1), (|S|_2, |T|_2)} \subseteq X$.

\Case$x = (|S|_1 \to |S|_2, |T|_1 \to |T|_2)$ where $(|T|_1, |S|_1), (|S|_2, |T|_2) \in \mu S_f$ \\
Then, $x \in S_f(\Set{(|T|_1, |S|_1), (|S|_2, |T|_2)})$.
If $x \in S_f(X)$, then $\Set{(|T|_1, |S|_1), (|S|_2, |T|_2)} \subseteq X$.

\Otherwise \\
By the definition of $S_f$, $x \notin S_f(X)$ for any $X$.

Therefore, the monotone function $S_f$ is invertible, and its support function is defined as follows.
\[
  \Support_{S_f}(x) =
  \begin{cases}
    ~ \emptyset &
      x = (|T|, |Top|), ~ |T| \in \cT_f \\
    ~ \Set{(|S|_1, |T|_1), (|S|_2, |T|_2)} &
      x = (|S|_1 \times |S|_2, |T|_1 \times |T|_2), ~
      (|S|_1, |T|_1), (|S|_2, |T|_2) \in \mu\cT_f \\
    ~ \Set{(|T|_1, |S|_1), (|S|_2, |T|_2)} &
      x = (|S|_1 \to |S|_2, |T|_1 \to |T|_2), ~
      (|T|_1, |S|_1), (|S|_2, |T|_2) \in \mu\cT_f \\
    ~ \Up & \text{otherwise} \\
  \end{cases}
\]

By replacing $\cT_f$ with $\cT$,
  we obtain a proof of the monotone function $S$ being invertible and its support function.

\Ex{21.5.4}
The inference rules corresponding to the generating function $E$ are as follows.

\begin{Proofs}
  \AxiomC{$a$} \AxiomC{$i$} \BinaryInfC{$h$} \nexth
  \AxiomC{$b$} \AxiomC{$c$} \BinaryInfC{$a$} \nexth
  \AxiomC{$e$} \UnaryInfC{$b$} \nexth
  \AxiomC{$b$} \UnaryInfC{$d$} \nexth
  \AxiomC{$d$} \UnaryInfC{$e$} \nexth
  \AxiomC{$f$} \AxiomC{$g$} \BinaryInfC{$c$} \nexth
  \AxiomC{$g$} \UnaryInfC{$f$} \nexth
  \AxiomC{} \UnaryInfC{$g$}
\end{Proofs}

The second, fourth, and last rules give $E(\Set{b, c}) = \Set{g, a, d}$,
  and the first and last rules give $E(\Set{a, i}) = \Set{h, g}$.
There are three fixed points of this generating function:
  $\Set{c, f, g}$, $\Set{b, c, d, e, f, g}$, and $\Set{a, b, c, d, e, f, g}$,
  and thus the first one is $\mu E$ and the last one is $\nu E$.

\Ex{21.5.6}
Not necessarily.
Consider a generating function $F$ on the universe
  $\N$ depicted by the following graph.

\begin{center}
  \begin{tikzpicture}
    \node (0) at (0, 0) {$0$};
    \node (1) at (1, 0) {$1$};
    \node (2) at (2, 0) {$2$};
    \node (n) at (3, 0) {$\dots$};
    \draw[->] (1) -- (0);
    \draw[->] (2) -- (1);
    \draw[->] (n) -- (2);
  \end{tikzpicture}
\end{center}

In this system,
  $\mu F = \Set{0}$ and $\nu F = \N$.
Therefore, all positive integers belong to $\nu F \setminus \mu F$,
  while there is no cycle.

\Ex{21.5.13}
{\newcommand\Lfp{\mathop{\It{lfp}}}
Let us prove each statement by induction on the recursive structure
  of a run of the algorithm.

If $\Lfp_F(X) = \True$,
  then either $X = \emptyset$ or $\Lfp_F(\Support(X)) = \True$ holds.
If $X = \emptyset$, then immediately $X \subseteq \mu F$.
If $\Lfp_F(\Support(X)) = \True$,
  by the induction hypothesis, $\Support(X) \subseteq \mu F$.
By \Lemma{21.5.8}, $X \subseteq \mu F$.

If $\Lfp_F(X) = \False$,
  then either $\Support(X) \Up$ or
  $X \neq \emptyset$ and $\Lfp_F(\Support(X)) = \False$ hold.
If $\Support(X) \Up$,
  then $X \not\subseteq F(Y)$ for any $Y \subseteq \cU$.
By choosing $Y = \mu F$, we obtain $X \not\subseteq F(\mu F) = \mu F$.
If $X \neq \emptyset$ and $\Lfp_F(\Support(X)) = \False$,
  by the induction hypothesis, $\Support(X) \not\subseteq \mu F$.
Since $\Support(X) \Down$,
  $X \not\subseteq \mu F$ by \Lemma{21.5.8}. \qed

If $\It{pred}^n(X) = \emptyset$ for some $n \in \N$, $\Lfp(X)$ is defined.
Therefore, if $F$ has no loop and a finite depth
  (i.e., there is no infinite chain in the graph),
  $\Lfp_F(X)$ terminates for any finite $X \subseteq \cU$.
}

\Ex{21.8.5}
Define the monotone function
  $S_d \in \Pow(\cT_m \times \cT_m) \to \Pow(\cT_m \times \cT_m)$ as follows.
\begin{align*}
  S_d(R)
  &= \Set{(|S|, |Top|) \mid |S| \in \cT_m} \\
  &\cup \Set{(|S|_1 \times |S|_2, |T|_1 \times |T|_2)
              \mid (|S|_1, |T|_1), (|S|_2, |T|_2) \in R} \\
  &\cup \Set{(|S|_1 \to |S|_2, |T|_1 \to |T|_2)
             \mid (|T|_1, |S|_1), (|S|_2, |T|_2) \in R} \\
  &\cup \Set{(|S|, \mu|X.T|) \mid (|S|, \Subst{|X| \mapsto \mu|X.T|}|T|) \in R} \\
  &\cup \Set{(\mu|X.S|, |T|) \mid (\Subst{|X| \mapsto \mu|X.S|}|S|, |T|) \in R}
\end{align*}
Let us show a counterexample of $S_d$ being invertible.
Let $|A| = \mu|X. X|\times|X|$,
  $x = (|A|, |A|)$,
  $X_1 = \Set{(|A|, |A| \times |A|)}$, and
  $X_2 = \Set{(|A| \times |A|, |A|)}$.
Then, $x \in S_d(X_1)$ and $x \in S_d(X_2)$.
However, $S_d(X_1 \cap X_2) = S_d(\emptyset) \notni x$.

Let us show $\nu S_d = \nu S_m$.
By the definitions, $S_d(\nu S_m) \supseteq S_m(\nu S_m) = \nu S_m$,
  i.e., $\nu S_m$ is $S_d$-consistent.
Therefore, by the principle of coinduction, $\nu S_m \subseteq \nu S_d$.

To show that $\nu S_d$ is $S_m$-consistent and thus $\nu S_m \supseteq \nu S_d$,
  let $x \in \nu S_d$.
Since $\nu S_d = S_d(\nu S_d)$,
  $x$ belongs to at least one of the cases in the definition of $S_d$.
If it directly belongs to the cases covered by the definition of $S_m$,
  then $x \in S_m(\nu S_d)$.
Otherwise, $x = (\mu|X.S|, \mu|Y.T|)$.
Let $x_0 = x$.
Suppose, for $j = 1, \dots, k$,
  that $x_{j-1}$ is generated by $x_j \in \nu S_d$ using
  the last case of the definition of $S_d$.
Since $\mu\It{-height}(\mu|X.S|)$ is finite,
  we can take the maximum of such $k$.
Then, $x_k \in \nu S_d$ is in the form of $(|S|', \mu|Y.T|)$
  which is generated by the cases other than the last one.
Therefore, $x_k$ is generated by the fourth case of the definition of $S_d$.
That is, letting $y = (|S|', \Subst{|Y| \mapsto \mu|Y.T|}|T|)$,
  we have $y \in \nu S_d$.
Applying the last rule of the definition of $S_d$ for $k$ times to $y$,
  we obtain $(\mu|X.S|, \Subst{|Y|, \mapsto \mu|Y.T|}|T|) \in \nu S_d$.
Therefore, we can generate $x$ directly with the fourth rule of the definition of
  $S_d$, which is equivalent to that of $S_m$,
  and thus $x \in S_m(\nu S_d)$.
\qed

\Ex{21.9.1}
\begin{Proofs}
  \AxiomC{$|T| \sqsubseteq |T|$}
  \nexth
  \AxiomC{$|S| \sqsubseteq |T|_1$}
  \UnaryInfC{$|S| \sqsubseteq |T|_1 \times |T|_2$}
  \nexth
  \AxiomC{$|S| \sqsubseteq |T|_2$}
  \UnaryInfC{$|S| \sqsubseteq |T|_1 \times |T|_2$}
  \nexth
  \AxiomC{$|S| \sqsubseteq |T|_1$}
  \UnaryInfC{$|S| \sqsubseteq |T|_1 \to |T|_2$}
  \nexth
  \AxiomC{$|S| \sqsubseteq |T|_2$}
  \UnaryInfC{$|S| \sqsubseteq |T|_1 \to |T|_2$}
  \nexth
  \AxiomC{$|S| \sqsubseteq \Subst{|X| \mapsto \mu|X.T|}|T|$}
  \UnaryInfC{$|S| \sqsubseteq \mu|X.T|$}
\end{Proofs}

\Ex{21.9.7}
\begin{Proofs}
  \AxiomC{$|T| \preceq |T|$}
  \nexth
  \AxiomC{$|S| \preceq |T|_1$}
  \UnaryInfC{$|S| \preceq |T|_1 \times |T|_2$}
  \nexth
  \AxiomC{$|S| \preceq |T|_2$}
  \UnaryInfC{$|S| \preceq |T|_1 \times |T|_2$}
  \nexth
  \AxiomC{$|S| \preceq |T|_1$}
  \UnaryInfC{$|S| \preceq |T|_1 \to |T|_2$}
  \nexth
  \AxiomC{$|S| \preceq |T|_2$}
  \UnaryInfC{$|S| \preceq |T|_1 \to |T|_2$}
  \next
  \AxiomC{$|S| \preceq |T|$}
  \UnaryInfC{$\Subst{|X| \mapsto \mu|X.T|}|S| \preceq \mu|X.T|$}
\end{Proofs}

\Ex{21.11.1}
{
\newcommand\Subtype{\It{subtype}^{\It{ac}}}
\newcommand\BinAnd{\mathbin{\text{and}}}
For example,
  let $|S| = \mu|X. (X| \times |X)| \times |X|$ and $|T| = \mu|X. X| \times |X|$.
Then, $\Sub{|S|}{|T|}$ is confirmed as follows
  (we use $\Subtype$ here for keeping the equations compact).
Let $A = \Set{(|S|, |T|)}$.
\begin{align*}
  \Subtype(\emptyset, |S|, |T|)
  &= \Subtype(A, (|S| \times |S|) \times |S|, |T|) \\
  &= \Subtype(A, (|S| \times |S|) \times |S|, |T| \times |T|) \\
  &= \Subtype(A, |S| \times |S|, |T|) \BinAnd \Subtype(A, |S|, |T|) \\
  &= \Subtype(A, |S| \times |S|, |T| \times |T|) \BinAnd \Subtype(A, |S|, |T|) \\
  &= \Subtype(A, |S|, |T|) \BinAnd \Subtype(A, |S|, |T|) \BinAnd \Subtype(A, |S|, |T|) \\
  &= \It{true}
\end{align*}
The opposite subtyping also holds.
\begin{align*}
  \Subtype(\emptyset, |T|, |S|)
  &= \Subtype(A, |T| \times |T|, |S|) \\
  &= \Subtype(A, |T| \times |T|, (|S| \times |S|) \times |S|) \\
  &= \Subtype(A, |T|, |S| \times |S|) \BinAnd \Subtype(A, |T|, |S|) \\
  &= \Subtype(A, |T| \times |T|, |S| \times |S|) \BinAnd \Subtype(A, |T|, |S|) \\
  &= \Subtype(A, |T|, |S|) \BinAnd \Subtype(A, |T|, |S|) \BinAnd \Subtype(A, |T|, |S|) \\
  &= \It{true}
\end{align*}
Indeed, |S| and |T| have the same tree type.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 22.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Type Reconstruction}

\Ex{22.2.3}
\begin{align*}
  &(\Subst{|X| \mapsto |Z| \to |W| \to |V|,
           |Y| \mapsto |Z| \to |W|},
    \CParen{|Z| \to |W| \to |V|} \to
    \CParen{|Z| \to |W|} \to
    |Z| \to
    |V|) \\
  &(\Subst{|X| \mapsto |Z| \to |Nat| \to |Nat|,
           |Y| \mapsto |Z| \to |Nat|},
    \CParen{|Z| \to |Nat| \to |Nat|} \to
    \CParen{|Z| \to |Nat|} \to
    |Z| \to
    |Nat|) \\
  &(\Subst{|X| \mapsto |Z| \to \CParen{|Z| \to |Z|} \to |Z|,
           |Y| \mapsto |Z| \to |Z| \to |Z|},
    \CParen{|Z| \to \CParen{|Z| \to |Z|} \to |Z|} \to
    \CParen{|Z| \to |Z| \to |Z|} \to
    |Z| \to
    |Z|)
\end{align*}

\Ex{22.3.3}
 vcdfdgdd756We omit some premises of \Rule{CT-App} that check the constraints.
Let $\Gamma = |x:X|, |y:Y|, |z:Z|$.
\begin{Proofs}
  \AxiomC{$|x:X| \in \Gamma$}
  \RuleLabel{CT-Var}
  \UnaryInfC{$\CtxTRC\Gamma{|x|}{|X|}{\emptyset}{\Set{}}$}
  \AxiomC{$|z:Z| \in \Gamma$}
  \RuleLabel{CT-Var}
  \UnaryInfC{$\CtxTRC\Gamma{|z|}{|Z|}{\emptyset}{\Set{}}$}
  \RuleLabel{CT-App}
  \BinaryInfC{$\CtxTRC\Gamma{|x z|}{|X|'}{\Set{|X|'}}{\Set{|X| = |Z| \to |X|'}}$}
  \AxiomC{$|y:Y| \in \Gamma$}
  \RuleLabel{CT-Var}
  \UnaryInfC{$\CtxTRC\Gamma{|y|}{|Y|}{\emptyset}{\Set{}}$}
  \AxiomC{$|z:Z| \in \Gamma$}
  \RuleLabel{CT-Var}
  \UnaryInfC{$\CtxTRC\Gamma{|z|}{|Z|}{\emptyset}{\Set{}}$}
  \RuleLabel{CT-App}
  \BinaryInfC{$\CtxTRC\Gamma{|y z|}{|Y|'}{\Set{|Y|'}}{\Set{|Y| = |Z| \to |Y|'}}$}
  \RuleLabel{CT-App}
  \BinaryInfC{$
    \CtxTRC\Gamma{|(x z) (y z)|}{|X|''}{\Set{|X|', |Y|', |X|''}}{
      \Set{|X| = |Z| \to |X|', |Y| = |Z| \to |Y|', |X|' = |Y|' \to |X|''}
    }
  $}
  \RuleLabel{CT-Abs}
  \UnaryInfC{$
    \CtxTRC{|x:X|, |y:Y|}{\Lm|z:Z. (x z) (y z)|}{|X|''}{
      \Set{|X|', |Y|', |X|''}
    }{
      \Set{|X| = |Z| \to |X|', |Y| = |Z| \to |Y|', |X|' = |Y|' \to |X|''}
    }
  $}
  \RuleLabel{CT-Abs}
  \UnaryInfC{$
    \CtxTRC{|x:X|}{\Lm|y:Y. |\Lm|z:Z. (x z) (y z)|}{|X|''}{
      \Set{|X|', |Y|', |X|''}
    }{
      \Set{|X| = |Z| \to |X|', |Y| = |Z| \to |Y|', |X|' = |Y|' \to |X|''}
    }
  $}
  \RuleLabel{CT-Abs}
  \UnaryInfC{$
    \CtxTRC{}{\Lm|x:X. |\Lm|y:Y. |\Lm|z:Z. (x z) (y z)|}{|X|''}{
      \Set{|X|', |Y|', |X|''}
    }{
      \Set{|X| = |Z| \to |X|', |Y| = |Z| \to |Y|', |X|' = |Y|' \to |X|''}
    }
  $}
\end{Proofs}

\Ex{22.3.9}{
\newcommand\CtxFTRC[6]{#1 \vdash_{#2} \TyRel{#3}{#4} \mid_{#5} #6}
For a sequence of variable names $F$,
  let us write
  $\Set{F...} \EqDef \Set{|X| \mid |X| \text{\ appears in\ } F}$.
We also write $F \setminus F' \EqDef \Set{F...} \setminus \Set{F'...}$
  for notational simplicity.
The following rules define the "threaded" constraint typing.
\begin{Proofs}
  \AxiomC{$|x:T| \in \Gamma$}
  \RuleLabel{TCT-Var}
  \UnaryInfC{$\CtxFTRC\Gamma F{|x|}{|T|}{F}{\Set{}}$}
  \nexth
  \AxiomC{$\CtxFTRC{\Gamma, |x:T|_1}{F}{|t|_2}{|T|_2}{F'}{C}$}
  \RuleLabel{TCT-Abs}
  \UnaryInfC{$
    \CtxFTRC\Gamma F{\Lm|x:T|_1|. t|_2}{|T|_1 \to |T|_2}{F'}{C}
  $}
  \next
  \AxiomC{$\begin{aligned}
    &\CtxFTRC\Gamma{F_1}{|t|_1}{|T|_1}{F_2}{C_1} \\
    &\CtxFTRC\Gamma{F_2}{|t|_2}{|T|_2}{F_3}{C_2}
  \end{aligned}$}
  \AxiomC{$\begin{gathered}
    F_3 = |X|, F_3' \\
    C' = C_1 \cup C_2 \cup \Set{|T|_1 = |T|_2 \to |X|}
  \end{gathered}$}
  \RuleLabel{TCT-App}
  \BinaryInfC{$\CtxFTRC\Gamma{F_1}{|t|_1\ |t|_2}{|X|}{F_3'}{C'}$}
  \nexth
  \AxiomC{\phantom{$\begin{gathered}\mid\\\mid\end{gathered}$}}
  \RuleLabel{TCT-Zero}
  \UnaryInfC{$\CtxFTRC\Gamma{F}{|0|}{|Nat|}{F}{C}$}
  \next
  \AxiomC{$\CtxFTRC\Gamma F{|t|_1}{|T|}{F'}{C}$}
  \AxiomC{$C' = C \cup \Set{|T| = |Nat|}$}
  \RuleLabel{TCT-Succ}
  \BinaryInfC{$\CtxFTRC\Gamma F{|succ t|_1}{|Nat|}{F'}{C'}$}
  \next
  \AxiomC{$\CtxFTRC\Gamma F{|t|_1}{|T|}{F'}{C}$}
  \AxiomC{$C' = C \cup \Set{|T| = |Nat|}$}
  \RuleLabel{TCT-Pred}
  \BinaryInfC{$\CtxFTRC\Gamma F{|pred t|_1}{|Nat|}{F'}{C'}$}
  \next
  \AxiomC{$\CtxFTRC\Gamma F{|t|_1}{|T|}{F'}{C}$}
  \AxiomC{$C' = C \cup \Set{|T| = |Nat|}$}
  \RuleLabel{TCT-IsZero}
  \BinaryInfC{$\CtxFTRC\Gamma F{|iszero t|_1}{|Bool|}{F'}{C'}$}
  \nexth
  \AxiomC{\phantom{$\mid$}}
  \RuleLabel{TCT-True}
  \UnaryInfC{$\CtxFTRC\Gamma F{|true|}{|Bool|}{F}{\Set{}}$}
  \next
  \AxiomC{\phantom{$\mid$}}
  \RuleLabel{TCT-False}
  \UnaryInfC{$\CtxFTRC\Gamma F{|false|}{|Bool|}{F}{\Set{}}$}
  \next
  \AxiomC{$\begin{gathered}
    \CtxFTRC\Gamma{F_1}{|t|_1}{|T|_1}{F_2}{C_1} \\
    \CtxFTRC\Gamma{F_2}{|t|_2}{|T|_2}{F_3}{C_2}
  \end{gathered}$}
  \AxiomC{$\begin{gathered}
    \CtxFTRC\Gamma{F_3}{|t|_3}{|T|_3}{F_4}{C_3} \\
    C' = C_1 \cup C_2 \cup C_3 \cup \Set{|T|_1 = |Bool|, |T|_2 = |T|_3}
  \end{gathered}$}
  \RuleLabel{TCT-If}
  \BinaryInfC{$
    \CtxFTRC\Gamma{F_1}{\If{|t|_1}{|t|_2}{|t|_3}}{|T|_2}{F_4}{C'}
  $}
\end{Proofs}
Equivalence to the original constraint typing is stated as follows.

\Theorem\ 1:
If $\CtxTRC\Gamma{|t|}{|S|}{\cX}{C}$,
  then there exists a permutation $F$ of $\cX$ such that
  $\CtxFTRC\Gamma F{|t|}{|S|}{\bullet}{C}$.

\Theorem\ 2:
If $\CtxFTRC\Gamma F{|t|}{|S|}{F'}{C}$
  where $F$ does not contain any names mentioned in $\Gamma$ and |t|,
  then $\CtxTRC\Gamma{|t|}{|S|}{F \setminus F'}{C}$.

Each theorem is shown by straight forward induction
  on (threaded) constraint typing derivations.
}

\Ex{22.3.10} \Todo

\Ex{22.3.11}
Add the following rule to constraint typing.
\begin{Proofs}
  \AxiomC{$\CtxTRC\Gamma{|t|_1}{|T|}{\cX}{C}$}
  \AxiomC{$|X| \notin \Gamma$, $|t|_1$, or $\cX$}
  \AxiomC{$C' = C \cup \Set{|T| = |X| \to |X|}$}
  \RuleLabel{CT-Fix}
  \TrinaryInfC{$\CtxTRC\Gamma{|fix t|_1}{|X|}{\cX \cup \Set{|X|}}{C'}$}
\end{Proofs}

\Ex{22.4.3}
The original ones on the left side, the principal unifiers on the right.
\begin{alignat*}{2}
  &\Set{|X| = |Nat|, |Y| = |X| \to |X|}
    &\qquad&\Subst{|X| \mapsto |Nat|, |Y| \mapsto |Nat| \to |Nat|} \\
  &\Set{|Nat| \to |Nat| = |X| \to |Y|}
    &&\Subst{|X| \mapsto |Nat|, |Y| \mapsto |Nat|} \\
  &\Set{|X| \to |Y| = |Y| \to |Z|, |Z| = |U| \to |W|}
    &&\Subst{|X| \mapsto |U| \to |W|,
             |Y| \mapsto |U| \to |W|,
             |Z| \mapsto |U| \to |W|} \\
  &\Set{|Nat| = |Nat| \to |Y|}
    &&\text{no unifier exists} \\
  &\Set{|Y| = |Nat| \to |Y|}
    &&\text{no unifier exists} \\
  &\Set{}
    &&\Subst{}
\end{alignat*}

\Ex{22.4.6} \Todo

\Ex{22.5.3}
\[
  \CParen{|Z| \to |Y|' \to |X|'}
  \to \CParen{|Z| \to |Y|'}
  \to |Z| \to |X|'
\]

\Ex{22.5.5} \Todo

\Ex{22.5.6}
With record types, a principal type may not exist for some terms
  anymore.
For example, consider a term $\Lm|x:X. x.l|$ for some label |l|.
Then,
  $\Rcd{|l:Y|} \to |Y|$, $\Rcd{|l:Y, l|'|:Y|'} \to |Y|$,
  $\Rcd{|l:Y, l|'|:Y|'|, l|''|:Y|''} \to |Y|$, and so on,
  are all possible types of the term,
  each of which is not less specific than the others.
Similar observations are also applied to the ordering of keys;
  for example, a term $\Lm|x:X. (x.l) (x.k)|$ could have a type
  $\Rcd{|l:Y| \to |Z, k:Y|}$ or $\Rcd{|k:Y, l:Y| \to |Z|}$,
  each of which is not less specific than the other.

To deal with the first problem,
  we may consider introducing variables for record entries.
For example, the term $\Lm|x:X. x.l|$ can have a type
  $\Rcd{|l:Y, Z...|} \to |Y|$,
  where the variable |Z| suffixed with |...| indicates that any
  number of key-type pairs could be substituted to it.
As for the second problem,
  we may extend the above mentioned |Z...| variables so that
  if the term is typed by a record with a |Z...| variable,
  then the order of keys are also generalized.

\Ex{22.5.7} \Todo

\Ex{22.7.1} \Todo

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 23.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Universal Types}

\Ex{23.4.1}
Here are the typing derivations of these terms.
\begin{Proofs}
  \AxiomC{$|x:X| \in |X|, |x:X|$}
  \RuleLabel{T-Var}
  \UnaryInfC{$\CtxTyRel{|X|, |x:X|}{|x|}{|X|}$}
  \RuleLabel{T-Abs}
  \UnaryInfC{$\CtxTyRel{|X|}{\Lm|x:X. x|}{|X|\to|X|}$}
  \RuleLabel{T-TAbs}
  \UnaryInfC{$\CtxTyRel{}{\Lm|X. |\Lm|x:X. x|}{\forall|X. X|\to|X|}$}
\end{Proofs}
Let $\Gamma = |X|, |f:X|\to|X|, |a:X|$ in the following tree.
\begin{Proofs}
  \AxiomC{$|f:X|\to|X| \in \Gamma$}
  \RuleLabel{T-Var}
  \UnaryInfC{$\CtxTyRel\Gamma{|f|}{|X|\to|X|}$}
  \AxiomC{$|f:X|\to|X| \in \Gamma$}
  \RuleLabel{T-Var}
  \UnaryInfC{$\CtxTyRel\Gamma{|f|}{|X|\to|X|}$}
  \AxiomC{$|a:X| \in \Gamma$}
  \RuleLabel{T-Var}
  \UnaryInfC{$\CtxTyRel\Gamma{|a|}{|X|}$}
  \RuleLabel{T-App}
  \BinaryInfC{$\CtxTyRel\Gamma{|f a|}{|X|}$}
  \RuleLabel{T-App}
  \BinaryInfC{$\CtxTyRel\Gamma{|f (f a)|}{|X|}$}
  \RuleLabel{T-Abs}
  \UnaryInfC{$\CtxTyRel{|X|, |f:X|\to|X|}{\Lm|a:X. f (f a)|}{|X| \to |X|}$}
  \RuleLabel{T-Abs}
  \UnaryInfC{$\CtxTyRel{|X|}{\Lm|f:X|\to|X. |\Lm|a:X. f (f a)|}{
    |(X| \to |X)| \to |X| \to |X|
  }$}
  \RuleLabel{T-TAbs}
  \UnaryInfC{$\CtxTyRel{}{\Lm|X. |\Lm|f:X|\to|X. |\Lm|a:X. f (f a)|}{
    \forall|X. (X| \to |X)| \to |X| \to |X|
  }$}
  \next
  \AxiomC{$|x:|\forall|X.X|\to|X| \in |x:|\forall|X.X|\to|X|$}
  \RuleLabel{T-Var}
  \UnaryInfC{$\CtxTyRel{|x:|\forall|X.X|\to|X|}{|x|}{\forall|X. X|\to|X|}$}
  \RuleLabel{T-TApp}
  \UnaryInfC{$\CtxTyRel{|x:|\forall|X.X|\to|X|}{|x [|\forall|X.X|\to|X]|}{
    \CParen{\forall|X. X|\to|X|} \to \CParen{\forall|X. X|\to|X|}
  }$}
  \AxiomC{$|x:|\forall|X.X|\to|X| \in |x:|\forall|X.X|\to|X|$}
  \RuleLabel{T-Var}
  \UnaryInfC{$\CtxTyRel{|x:|\forall|X.X|\to|X|}{|x|}{\forall|X. X|\to|X|}$}
  \RuleLabel{T-App}
  \BinaryInfC{$\CtxTyRel{|x:|\forall|X.X|\to|X|}{|x [|\forall|X.X|\to|X] x|}{
    \forall|X. X|\to|X|
  }$}
  \RuleLabel{T-Abs}
  \UnaryInfC{$\CtxTyRel{}{\Lm|x:|\forall|X.X|\to|X. x [|\forall|X.X|\to|X] x|}{
    \CParen{\forall|X. X|\to|X|} \to \CParen{\forall|X. X|\to|X|}
  }$}
\end{Proofs}
Let $|T|_|X| = (|X| \to |X|) \to |X| \to |X|$ in the following derivation,
  in which we omit subtrees for deriving
  $\CtxTyRel{|X|}{|double|}{\forall|X. T|_|X|}$, which is given above.
Note that we have $|T|_|X| \to |T|_|X| = \Subst{|X| \mapsto |X| \to |X|}|T|_|X|$.
\begin{Proofs}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\CtxTyRel{|X|}{|double|}{|T|_|X|}$}
  \RuleLabel{T-TApp}
  \UnaryInfC{$\CtxTyRel{|X|}{|double [X| \to |X]|}{|T|_|X| \to |T|_|X|}$}
  \AxiomC{$\vdots$}
  \UnaryInfC{$\CtxTyRel{|X|}{|double|}{|T|_|X|}$}
  \RuleLabel{T-TApp}
  \UnaryInfC{$\CtxTyRel{|X|}{|double [X]|}{|T|_|X|}$}
  \RuleLabel{T-App}
  \BinaryInfC{$\CtxTyRel{|X|}{|double [X|\to|X] (double [X])|}{|T|_|X|}$}
  \RuleLabel{T-TAbs}
  \UnaryInfC{$\CtxTyRel{}{\Lm|X. double [X|\to|X] (double [X])|}{
    \forall|X. T|_|X|
  }$}
\end{Proofs}

\Ex{23.4.2}
I omit the derivation here since it does not fit to the page width.
Informal description:
  the definition of |map| starts with $\Lm|X. |\Lm|Y. |\Lm|f: X|\to|Y.|$,
  which tells us that |map| has a type
  $\forall|X. |\forall|Y. |\CParen{|X|\to|Y|}\to\dots$
  as derived by \Rule{T-TAbs} and \Rule{T-Abs}.
The return type of this form is inferred by looking through the application of
  |fix| operator,
  which is applied to a function of type
  $|(List X| \to |List Y)| \to |List X| \to |List Y|$.
By the definition of |fix|, its return type is $|List X| \to |List Y|$.
Combining it with the form given above yields
  $\forall|X. |\forall|Y. |\CParen{|X|\to|Y|}\to|List X|\to|List Y|$,
  which is the type shown in the textbook.

\Ex{23.4.3}
\begin{Code}
  reverse = $\Lm$X. fix (
      $\Lm$f:List X$\to$List X$\to$List X. $\Lm$r:List X. $\Lm$l:List X.
          if isnil [X] l then
              r
          else
              f (cons [X] (head [X] l) r) (tail [X] l)
  ) (nil [X]);
\end{Code}

\Ex{23.4.4}
Here is a simple implementation of insertion sort.
\begin{Code}
  insert_sorted = $\Lm$X. $\Lm$le:X$\to$X$\to$Bool. fix (
      $\Lm$f:X$\to$List X$\to$List X. $\Lm$x:X. $\Lm$l:List X.
          if isnil [X] l then
              cons [X] x l
          else
              let h = head [X] l in
              if le x h then
                  cons [X] x l
              else
                  cons [X] h (f x (tail [X] l))
  );
  sort = $\Lm$X. $\Lm$le:X$\to$X$\to$Bool. fix (
      $\Lm$f:List X$\to$List X. $\Lm$l:List X.
          if isnil [X] l then
              l
          else
              insert_sorted [X] le (head [X] l) (f (tail [X] l))
  );
\end{Code}

\Ex{23.4.5}
\begin{Code}
  and = $\Lm$b:CBool. $\Lm$c:CBool. $\Lm$X. $\Lm$t:X. $\Lm$f:X. b [X] (c [X] t f) f;
\end{Code}

\Ex{23.4.6}
\begin{Code}
  iszero = $\Lm$n:CNat. c [CBool] ($\Lm$b:CBool. fls) tru;
\end{Code}

\Ex{23.4.7}
|ctimes|: Given |m:CNat|, |n:CNat|, and $|s:X|\to|X|$,
  the term |n [X] (m [X] s)| has the type $|X|\to|X|$,
  yielding the type printed in the textbook.
The definition reads that
  |ctimes m n [X] s z| applies |m [X] s| to |z| repeatedly for |n| times.
Since the function |m [X] s| applies |s| for |m| times to the argument,
  repeating it |n| times ends up with $|m| \times |n|$ applications of |s|.

|cexp|: Given |m:CNat| and |n:CNat|,
  the term $|n [X|\to|X]|$ has the type $|CNat| \to |CNat|$,
  which verifies the type of |cexp| shown in the textbook.
The correctness of the definition is best understood by induction on |n|.
Obviously, $|cexp c|_0| m| = \Lm|X. c|_0| [X| \to |X] (m [X])| = |c|_0 = |m|^|0|$.
For general |n|, we have
\begin{align*}
  |cexp (csucc n) m|
  &= \Lm|X. csucc n [X| \to |X] (m [X])| \\
  &= \Lm|X. |\Lm|s:X| \to |X. m [X] (n [X| \to |X] m s)| \\
  &= |ctimes m (n [X| \to |X] m)|.
\end{align*}
The conclusion follows by combining it with the induction hypothesis
  $|n [X|\to|X] m| = |m|^{|n|}$.

\Ex{23.4.8}
\begin{Code}
  pairNat = $\Lm$m:CNat. $\Lm$n:CNat. $\Lm$X. $\Lm$f:(CNat$\to$CNat$\to$X). f m n;
  fstNat = $\Lm$p:PairNat. p [CNat] ($\Lm$m:CNat. $\Lm$n:CNat. m);
  sndNat = $\Lm$p:PairNat. p [CNat] ($\Lm$m:CNat. $\Lm$n:CNat. n);
\end{Code}

\Ex{23.4.9}
\begin{Code}
  pred =
      let f = $\Lm$p:PairNat. pairNat (csucc (fstNat p)) (fstNat p) in
      $\Lm$n:CNat.
          sndNat (n [PairNat] f (pairNat c$_0$ c$_0$));
\end{Code}

\Ex{23.4.10}
An annotated definition of |vpred| is as follows.
\begin{Code}
  k = $\Lm$X. $\Lm$x:X. $\Lm$y:X$\to$X. x;
  i = $\Lm$X. $\Lm$x:X. x;
  vpred = $\Lm$n:CNat. $\Lm$X. $\Lm$s:X$\to$X. $\Lm$z:X.
      n [(X$\to$X)$\to$X] ($\Lm$p:(X$\to$X)$\to$X. $\Lm$q:X$\to$X. q (p s)) (k [X] z) (i [X]);
\end{Code}
Let us show the correctness of this definition.
Let
\[ |f| = \Lm|X. |\Lm|s:X| \to |X. |
         \Lm|p:(X| \to |X)| \to |X. |\Lm|q:X| \to |X. q (p s)|. \]
First, we have
\begin{align*}
  |vpred c|_0| [X] s z|
  &= |c|_0| [(X| \to |X)| \to |X] (f [X] s) (k [X] z) (i [X])| \\
  &\to^* |k [X] z (i [X])| \\
  &\to^* |z|.
\end{align*}
For general |n|, |vpred (csucc n)| is computed as follows.
\begin{align*}
  &\PhantomRel= |vpred (csucc n) [X] s z| \\
  &= |csucc n [(X| \to |X)| \to |X] (f [X] s) (k [X] z) (i [X])| \\
  &\to^* |f [X] s (n [(X| \to |X)| \to |X] (f [X] s) (k [X] z)) (i [X])| \\
  &\to^* |i [X] (n [(X| \to |X)| \to |X] (f [X] s) (k [X] z)) s| \\
  &\to^* |n [(X| \to |X)| \to |X] (f [X] s) (k [X] z) s|.
\end{align*}
A crucial observation is that the final term
  $|n [(X| \to |X)| \to |X] (f [X] s) (k [X] z) s|$
  and |n [X] s z| are evaluated to the same value.
Let us show it by induction on |n|.
For $|n| = |c|_0$, we have
\[
  |c|_0| [(X| \to |X)| \to |X] (f [X] s) (k [X] z) s|
  \to^* |k [X] z s|
  \to^* |z|
\]
  which is also obtained by evaluating $|c|_0| [X] s z|$.
Suppose the form is equivalent to |n [X] s z| for a given |n|.
Then,
\begin{align*}
  &\PhantomRel{\to^*} |csucc n [(X| \to |X)| \to |X] (f [X] s) (k [X] z) s| \\
  &\to^* |f [X] s (n [(X| \to |X)| \to |X] (f [X] s) (k [X] z)) s| \\
  &\to^* |s ((n [(X| \to |X)| \to |X] (f [X] s) (k [X] z)) s)|.
\end{align*}
By the induction hypothesis,
  this term and |s (n [X] s z)|, and thus |csucc n [X] s z|,
  are evaluated to the same value, concluding the induction.
Therefore, any Church numeral |n| is behaviorally equivalent to
  |vpred (csucc n)|,
  which, combined with $|vpred c|_0$ being equivalent to $|c|_0$,
  veryfies that |vpred| is a correct implementation of the |pred| function on
  Church numerals.

Informal explanation of the implementation:
let us see the lambda applications just as a sequence of terms.
Then, |f [X] s| copies |s| to the end of the sequence,
  pulling the last term to the left-most place.
At the initial state,
  the last term is |i [X]|, which does nothing,
  while from the second application of |f [X] s|,
  the last term is always |s|.
Therefore,
  the overall computation goes like adding one |i [X]| and
  $|n| - 1$ times of |s|,
  which matches to the definition of $|n| - 1$ as a Church numeral.
The |k [X] z| term is used to make up the final argument |z| of the sequence,
  i.e., it realizes the correctness of $|vpred c|_0$.

\Ex{23.4.11}
\begin{Code}
  head_df = $\Lm$X. $\Lm$l:List X. $\Lm$df:X. l [X] ($\Lm$hd:X. $\Lm$tl:X. hd) df;
\end{Code}

\Ex{23.4.12}
\begin{Code}
  insert = $\Lm$X. $\Lm$le:X$\to$X$\to$Bool. $\Lm$l:List X. $\Lm$x:X.
      fst [List X] [Bool] (
          l [Pair (List X) Bool] (
              $\Lm$y:X. $\Lm$p:Pair (List X) Bool.
                  let tl = fst [List X] [Bool] p in
                  let not_done = snd [List X] [Bool] p in
                  if and not_done (le y x) then
                      pair [List X] [Bool] (cons [X] y (cons [X] x tl)) false
                  else
                      pair [List X] [Bool] (cons [X] y tl) not_done
          ) (pair [List X] [Bool] (nil [X]) true)
      );

  sort = $\Lm$X. $\Lm$le:X$\to$X$\to$Bool. $\Lm$l:List X.
      l [List X] ($\Lm$x:X. $\Lm$tl:List X. insert [X] le tl x) (nil [X]);
\end{Code}

\Ex{23.5.1}
By induction on the evaluation derivations
  with case analysis on the last rule used in the derivations.

\Case\Rule{E-App1}: $|t| = |t|_1\ |t|_2$, $|t|' = |t|_1'\ |t|_2$ \\
The type $|T|_{12}$ of the term $|t|_1\ |t|_2$ is derived by \Rule{T-App},
  whose promise gives
  $\CtxTyRel\Gamma{|t|_1}{|T|_{11} \to |T|_{12}}$ and
  $\CtxTyRel\Gamma{|t|_2}{|T|_{11}}$ for some $|T|_{11}$ and $|T|_{12}$.
By the induction hypothesis,
  the premise $|t|_1 \to |t|_1'$ of \Rule{E-App1} preserves the type,
  i.e., $\CtxTyRel\Gamma{|t|_1'}{|T|_{11} \to |T|_{12}}$.
Therefore, we obtain with \Rule{T-App} that
  $\CtxTyRel\Gamma{|t|_1'\ |t|_2}{|T|_{12}}$.

\Case\Rule{E-App2}: $|t| = |v|_1\ |t|_2$, $|t|' = |v|_1\ |t|_2'$ \\
Similar to the \Rule{E-App1} case.

\Case\Rule{E-AppAbs}:
  $|t| = \CParen{\Lm|X:T|_{11}|. t|_{12}}\ |v|_2$,
  $|t|' = \Subst{|x| \mapsto |v|_2} |t|_{12}$ \\
The type $|T|_{12}$ of the term |t| is derived by \Rule{T-App},
  whose promise gives
  $\CtxTyRel\Gamma{\Lm|x:T|_{11}|. t|_{12}}{|T|_{11}' \to |T|_{12}}$ and
  $\CtxTyRel\Gamma{|v|_2}{|T|_{11}'}$.
The type of the term $\Lm|x:T|_{11}|. t|_{12}$ is then derived by \Rule{T-Abs},
  which forces $|T|_{11}' = |T|_{11}$.
In particular, we have $\CtxTyRel\Gamma{|v|_2}{|T|_{11}}$.
The promise of this rule also provides
  $\CtxTyRel{\Gamma, |x:T|_{11}}{|t|_{12}}{|T|_{12}}$,
  with which we obtain
  $\CtxTyRel\Gamma{\Subst{|x| \mapsto |v|_2} |t|_{12}}{|T|_{12}}$.

\Case\Rule{E-TApp}:
  $|t| = |t|_1\ |[T|_2|]|$, $|t|' = |t|_1'\ |[T|_2|]|$ \\
The type of the term |t| is derived by \Rule{T-TApp},
  which gives $\CtxTyRel\Gamma{|t|_1}{\forall|X. T|_{12}}$
  and $\CtxTyRel\Gamma{|t|}{\Subst{|X| \mapsto |T|_2} |T|_{12}}$.
By the induction hypothesis,
  the promise of \Rule{E-TApp}, $|t|_1 \to |t|_1'$ preserves the type,
  i.e., $\CtxTyRel\Gamma{|t|_1'}{\forall|X. T|_{12}}$.
Therefore,
  by applying \Rule{T-TApp} to the term $|t|'$,
  we obtain $\CtxTyRel\Gamma{|t|'}{\Subst{|X| \mapsto |T|_2} |T|_{12}}$.

\Case\Rule{E-TappTabs}:
  $|t| = \CParen{\Lm|X. t|_{12}}\ |[T|_2|]|$,
  $|t|' = \Subst{|X| \mapsto |T|_2} |t|_{12}$ \\
The type of the term |t| is again derived by \Rule{T-TApp},
  which gives $\CtxTyRel\Gamma{\Lm|X. t|_{12}}{\forall|X. T|_{12}}$
  and $\CtxTyRel\Gamma{\CParen{\Lm|X. t|_{12}}\ |[T|_2|]|}{\Subst{|X| \mapsto |T|_2} |T|_{12}}$.
The former typing relation is derived by \Rule{T-TAbs},
  whose promise gives $\CtxTyRel{\Gamma, |X|}{|t|_{12}}{|T|_{12}}$.
We need the following lemma to conclude the proof.

\Lemma:
  Given $\CtxTyRel{\Gamma, |X|, \Gamma'}{|t|}{|T|}$ and a type $|S|$,
  it holds that
  $\CtxTyRel{
    \Gamma, \Subst{|X| \mapsto |S|} \Gamma'
  }{
    \Subst{|X| \mapsto |S|} |t|
  }{\Subst{|X| \mapsto |S|} |T|}$.

\Proof:
  By induction on typing derivations.
  Basically, applying the same rule as the last rule used to derive
    the type of |t| works.
  The cases of \Rule{T-App}, \Rule{T-TAbs}, and \Rule{T-TApp} are
    straight-forward.
  The \Rule{T-Var} case is shown by considering two cases of either or not
    $|x:T|$ includes |X|.
  In particular, if it includes |X|,
    it should appear in $\Gamma'$,
    thus the substitution works correctly.
  In the \Rule{T-Abs} case,
    the additional context in the premise $|x:T|_1$ appears in $\Gamma'$,
    thus again the substitution works. \qed

\Ex{23.5.2}
By induction on the typing derivations with case analysis on the last rule
  used in the derivations.

\Case\Rule{T-Var}: $|t| = |x|$ \\
It contradicts with the assumption that |t| is a closed term.

\Case\Rule{T-Abs}: $|t| = \Lm|x:T|_1|. t|_2$ \\
Immediate, as an abstraction is a value.

\Case\Rule{T-App}: $|t| = |t|_1\ |t|_2$ \\
The premises give
  $\CtxTyRel{}{|t|_1}{|T|_{11} \to |T|_{12}}$ and
  $\CtxTyRel{}{|t|_2}{|T|_{11}}$
  (note that the context is empty, as |t| is a closed term).
By the induction hypothesis,
  each of $|t|_1$ and $|t|_2$ is a value or can take an evaluation step.
If either is not a value,
  we can apply \Rule{E-App1} or \Rule{E-App2} to take a step on |t|.

Suppose both are values.
Then,
  the type of $|t|_1$ is derived by either \Rule{T-Abs} or \Rule{T-TApp}
  (note that, since the context is empty, there is no chance of
   using \Rule{T-Var} here).
We can show that the type is derived by \Rule{T-Abs}
  followed by arbitrary number of interleaving \Rule{T-TApp} and \Rule{T-TAbs}
  by induction on the derivation,
  which indicates that $|t|_1$ is an abstraction.
If the very rule deriving the type is \Rule{T-Abs},
  then the conclusion follows immediately.
Suppose the last rule used is \Rule{T-TApp}.
Then, $|t|_1$ is a type abstraction,
  whose type $\forall|X.T|_{11}'$ is derived by \Rule{T-TAbs}.
The conclusion of \Rule{T-TAbs} gives the shape of $|t|_1$ as $\Lm|X. t|_1'$.
By the induction hypothesis,
  the typing relation $\CtxTyRel{X}{|t|_1'}{|T|_{11}'}$
  is derived by \Rule{T-Abs} followed by interleaving \Rule{T-TApp} and \Rule{T-TAbs},
  concluding the induction
  (note here again that \Rule{T-Var} does not appear in the sequence,
   since the context only consists of type variables and does not include
   any typing statement of variables).
Therefore, $|t|_1$ is an abstraction,
  and thus we can apply \Rule{E-AppAbs} to the term $|t| = |t|_1\ |t|_2$.

\Case\Rule{T-TAbs}: $|t| = \Lm|X. t|_2$ \\
Immediate, as a type abstraction is a value.

\Case\Rule{T-TApp}: $|t| = |t|_1\ |[T|_2|]|$ \\
The premise gives $\CtxTyRel{}{|t|_1}{\forall|X. T|_{12}}$.
By the induction hypothesis,
  it either is a value or can take a step.
If it can take a step as $|t|_1 \to |t|_1'$,
  then we can also take a step on |t| using \Rule{E-TApp}.
Suppose that $|t|_1$ is a value,
  i.e., either an abstraction or a type abstraction.
If it is an abstraction,
  then its type is derived by \Rule{T-Abs},
  whose conclusion gives that $\forall|X. T|_{12}$ is an arrow type,
  which cannot happen.
Therefore, $|t|_1$ is a type abstraction,
  with which we can apply \Rule{E-TappTabs} to the term |t|. \qed

\Ex{23.6.3}
{
\newcommand\Erase{\mathop{\It{erase}}}
\newcommand\Lml{\It{leftmost-leaf}}
\begin{enumerate}
  \item %%% 1
    By induction on typing derivations.
    Suppose $\CtxTyRel\Gamma{|t|}{|T|}$.
    
    If |t| is already exposed, we can just take $|s| = |t|$.

    If |t| is a type abstraction $\Lm|X. t|'$,
      its type is derived by \Rule{T-TAbs},
      which provides $\CtxTyRel{\Gamma, |X|}{|t|'}{|T|'}$.
    By the induction hypothesis,
      there is a well-typed exposed term |s| such that
      $\Erase(|s|) = \Erase(|t|') = \Erase(|t|)$.

    If |t| is a type application $|t|'\ |[S]|$,
      its type is derived by \Rule{T-TApp},
      which provides $\CtxTyRel\Gamma{|t|'}{\forall|X. T|'}$.
    By the induction hypothesis,
      there is a well-typed exposed term |s| such that
      $\Erase(|s|) = \Erase(|t|') = \Erase(|t|)$. \qed

  \item %%% 2
    By induction on typing derivations.

    If |t| is already exposed, we can take
      $\Cbar X = \bullet$, $\Cbar A = \bullet$, and $|u| = |t|$.

    If |t| is a type abstraction $\Lm|X. t|'$,
      its type is derived by \Rule{T-TAbs},
      whose promise provides $\CtxTyRel{\Gamma, |X|}{|t|'}{|T|'}$.
    By the induction hypothesis,
      there is a term $|s|' = \Lm\Cbar X|. (u [|\Cbar A|])|$
      where |u| is an exposed term, $\CtxTyRel{\Gamma, |X|}{|s|'}{|T|'}$,
      and $\Erase(|s|') = \Erase(|t|')$.
    Applying \Rule{T-TAbs} to this term yields
      $\CtxTyRel\Gamma{\Lm|X. s|'}{\forall|X. T|'}$.
    Therefore, $|s| = \Lm|X. s|'$ satisfies the conditions,
      as $\Erase(|s|) = \Erase(|s|') = \Erase(|t|') = \Erase(|t|)$.

    If |t| is a type application $|t|'\ |[S]|$,
      its type is derived by \Rule{T-TApp},
      whose promise provides $\CtxTyRel\Gamma{|t|'}{\forall|X. T|'}$.
    By the induction hypothesis,
      there is a term $|s|' = \Lm\Cbar X|. (u [|\Cbar A|])|$
      where |u| is an exposed term, $\CtxTyRel\Gamma{|s|'}{\forall|X. T|'}$,
      and $\Erase(|s|') = \Erase(|t|')$.
    Applying \Rule{T-TApp} to this term yields
      $\CtxTyRel\Gamma{|s|'\ |[S]|}{|T|}$.
    If $\Cbar X = \bullet$,
      then $|s| = |s|'\ |[S]|$ satisfies the conditions,
      as $\Erase(|s|) = \Erase(|s|') = \Erase(|t|') = \Erase(|t|)$.
    If $\Cbar X$ is not empty,
      decompose it as $\Cbar X = |X|, \Cbar X'$.
    Then,
      the term $|t| = \Lm|X. |\Lm\Cbar X'|. (u [|\Cbar A|]) [S]|$
      can be evaluated by \Rule{E-TappTabs} into
      $\Subst{|X| \mapsto |S|} \Lm\Cbar X'|. (u [|\Cbar A|])|$,
      which has the same type |T| as stated by the type preservation theorem.
    Therefore, we can take $|s| = \Lm\Cbar X'|. (u [|\Cbar A|])|$
      to satisfy the conditions. \qed

  \item %%% 3
    By the definition of the $\Erase$ function,
      when $|t|$ is an exposed term
      (i.e., only the first three cases of the definition of $\Erase$ function
       can be applied directly to $\Erase(|t|)$),
      the form $\Erase(|t|) = |m n|$ is only realized by
      $\Erase(|s u|) = \Erase(|s|)\ \Erase(|u|)$ case,
      thus $\Erase(|s|) = |m|$ and $\Erase(|u|) = |n|$.
    The type of |s u| is derived by \Rule{T-App},
      whose premises provide the typing relations for |s| and |u|. \qed

  \item %%% 4
    As we saw in 2,
      there is some term |t| of the form
      $\Lm\Cbar Y|. | \CParen{|s|\ \CBracket{\Cbar C}}$
      such that |s| is an exposed term,
      $\Erase(|t|) = |x x|$,
      and $\CtxTyRel\Gamma{|t|}{|U|}$.
    By backtracking the derivation of this typing relation,
      we obtain
      $\CtxTyRel{\Gamma, \Cbar Y}{|s|}{\forall\Cbar Y'|.S|}$
      where $\Subst{\Cbar Y' \mapsto \Cbar C} |S| = |U|$.
    Since |s| is exposed and $\Erase(|s|) = |x x|$,
      we can use 3 to obtain the form $|s| = |s|_1\ |s|_2$
      where $\CtxTyRel{\Gamma, \Cbar Y}{|s|_1}{|S|_1 \to \forall\Cbar Y'|.S|}$
      and $\CtxTyRel{\Gamma, \Cbar Y}{|s|_2}{|S|_1}$ for some type $|S|_1$,
      and $\Erase(|s|_1) = \Erase(|s|_2) = |x|$.
    By applying 2 again,
      we obtain exposed terms $|s|_1'$ and $|s|_2'$ both erased to |x|
      that satisfy typing relations of the form
      \begin{alignat*}{2}
        &\CtxTyRel{\Gamma, \Cbar Y, \Cbar Y_1}{|s|_1'}{\forall\Cbar Y_1'|.S|_1'}
        &\text{\ where\ }
        &\Subst{\Cbar Y_1' \mapsto \Cbar A} |S|_1' = |S|_1 \to \forall\Cbar Y'|.S|, \\
        &\CtxTyRel{\Gamma, \Cbar Y, \Cbar Y_2}{|s|_2'}{\forall\Cbar Y_2'|.S|_2'}
        &\text{\ where\ }
        &\Subst{\Cbar Y_2' \mapsto \Cbar B} |S|_2' = |S|_1.
      \end{alignat*}
    Since $|s|_1'$ and $|s|_2'$ are both exposed and erased to a variable |x|,
      we have $|s|_1' = |s|_2' = |x|$.
    Therefore, these typing relations are derived directly by \Rule{T-Var},
      which provides $|T| = \forall\Cbar Y_1'|.S|_1' = \forall \Cbar Y_2'|.S|_2'$
      and $\Cbar Y, \Cbar Y_1, \Cbar Y_2 = \bullet$.
    Since $\Subst{\Cbar Y_1' \mapsto \Cbar A} |S|_1'$, which is an arrow type,
      is not a universal type, neither is $|S|_1'$.
    Therefore, $|Y|_2'$ is a prefix of $\Cbar Y_1'$;
      i.e., we can write
      $\Cbar Y_1' = \Cbar X_1 \Cbar X_2$ and $\Cbar Y_2' = \Cbar X_1$.
    There are, then, two cases for the shape of $|S|_1'$.
    \begin{itemize}
      \item \Case Type variable $|S|_1' = |X|$:
          in this case, $|X| \in |X|_1|X|_2$.
        We can then write $|T| = \forall\Cbar X_1\Cbar X_2|.X|$,
          which corresponds to the case (a).
      \item \Case Arrow type $|S|_1' = |T|_1 \to |T|_2$:
          in this case, by inversion of typing,
          we have $\Subst{\Cbar X_1 \Cbar X_2 \mapsto \Cbar A} |T|_1 = |S|_1$,
          $\Subst{\Cbar X_1 \Cbar X_2 \mapsto \Cbar A} |T|_2 = \forall |Y|'|.S|$,
          and
          $\Subst{\Cbar X_1 \mapsto \Cbar B}(\forall\Cbar X_2|. T|_1 \to |T|_2)
            = |S|_1$.
        Combining the first and third equations,
          we obtain
          $\Subst{\Cbar X_1\Cbar X_2 \mapsto \Cbar A} |T|_1
            = \Subst{\Cbar X_1 \mapsto \Cbar B}(\forall\Cbar X_2|. T|_1 \to |T|_2)$.
        We can then write $|T| = \forall\Cbar X_1\Cbar X_2|.T|_1 \to |T|_2$,
          which corresponds to the case (b).
    \end{itemize}

  \item %%% 5
    Using 2,
      we can obtain a term |t| of the form
      $\Lm\Cbar X|. |\CParen{|u|\ \CBracket{\Cbar A}}$
      with an exposed term |u|
      where $\CtxTyRel\Gamma{|t|}{|S|}$ and $\Erase(|t|) = \Lm|x.m|$.
    Since $\Erase(|u|) = \Erase(|t|) = \Lm|x.m|$ and |u| is exposed,
      |u| is an abstraction term.
    It also indicates that $\Cbar A$ is empty,
      and therefore |t| has the form $\Lm\Cbar X|.|\Lm|x:S|_1|. u|'$.
    If this term is well-typed,
      the inner term $|u|'$ is typed as
      $\CtxTyRel{\Gamma, \Cbar X, |x:S|_1}{|u|'}{|S|_2}$
      for some type $|S|_2$,
      from which we obtain
      $\CtxTyRel\Gamma{\Lm\Cbar X|.|\Lm|x:S|_1|. u|'}{\forall\Cbar X|.S|_1 \to |S|_2}$.
    The conclusion follows by the uniqueness of typing.

  \item %%% 6
    By induction on the structure of $|T|_1$ with case analysis on its form.
    \begin{itemize}
      \item \Case $|T|_1 = |W|$:
        If |W| is not in $\Cbar X_1 \Cbar X_2$,
          the left hand side of the assumption equals to $\forall\Cbar Y|.W|$,
          which does not include any arrow while the other side of the equation
          has at least one arrow,
          leading to contradiction.
      \item \Case $|T|_1 = |S|_1 \to |S|_2$:
        By the inversion lemma,
          we have
          $\Subst{\Cbar X_1\Cbar X_2\mapsto\Cbar A} |S|_1
            = \Subst{\Cbar X_1\mapsto\Cbar B}(\forall\Cbar Y|.S|_1 \to |S|_2)$
          up to renaming free type variables.
        By the induction hypothesis,
          $\Lml(|S|_1) = |X|_i$ for some $|X|_i \in \Cbar X_1\Cbar X_2$.
        The conclusion follows by $\Lml(|T|_1) = \Lml(|S|_1)$.
      \item \Case $|T|_1 = \forall|X.S|$:
        By replacing $\Cbar Y$ with $(\Cbar Y, |X|)$,
          we can apply the induction hypothesis to obtain the conclusion.
    \end{itemize}

  \item %%% 7
    Assume that |omega| is well-typed.
    By 1 and 3, we can write
      \begin{alignat*}{2}
        &\CtxTyRel\Gamma{|t|_1}{|T| \to |U|},
        &\qquad
        \Erase(|t|_1) &= \Lm|x.x x|,
        \\
        &\CtxTyRel\Gamma{|t|_2}{|T|},
        &\qquad
        \Erase(|t|_2) &= \Lm|y.y y|
      \end{alignat*}
      for some context $\Gamma$, terms $|t|_1$, $|t|_2$, and types |T|, |U|.
    By applying 5 to $|t|_2$,
      |T| has the form $\forall\Cbar X|.T|_1 \to |T|_2$
      for some $\Cbar X$, $|T|_1$, and $|T|_2$.
    Applying 2 to $|t|_1$ and $|t|_2$ respectively yields the following forms
      \begin{alignat*}{2}
        &\CtxTyRel\Gamma{
          \Lm\Cbar X_1|.| \CParen{|t|_1'\ \CBracket{\Cbar A_1}}
        }{|T| \to |U|},
        &\qquad
        \Erase(|t|_1') &= \Lm|x.x x|,
        \\
        &\CtxTyRel\Gamma{\Lm\Cbar X_2|.| \CParen{|t|_2'\ \CBracket{\Cbar A_2}}}{|T|},
        &
        \Erase(|t|_2') &= \Lm|y.y y|
      \end{alignat*}
      for some exposed terms $|t|_1'$, $|t|_2'$,
      sequences of type variables $\Cbar X_1$, $\Cbar X_2$,
      and sequences of types $\Cbar A_1$, $\Cbar A_2$.
    Since $|t|_1'$ and $|t|'_2$ are exposed terms erased to abstractions,
      they are both abstractions themselves.
    Therefore, $\Cbar A_1$ and $\Cbar A_2$ are both empty.
    Moreover, the first typing relation tells us that
      $\Lm\Cbar X_1|.| \CParen{|t|_1'\ \CBracket{\Cbar A_1}}$
      has an arrow type,
      and therefore $\Cbar X_1$ is also empty.
    The relations are thus simplified to
      \[
        \CtxTyRel\Gamma{|t|_1'}{|T| \to |U|},
        \qquad
        \CtxTyRel\Gamma{\Lm\Cbar X_2|.t|_2'}{|T|}.
      \]
    Since $|t|_1'$ is an abstraction of type $|U| \to |T|$ under $\Gamma$,
      we can write $|t|_1' = \Lm|x:U.u|$,
      from which we can obtain the following relations using \Rule{T-Abs}:
      \[
        \CtxTyRel{\Gamma, |x:T|}{|u|}{|U|},
        \qquad
        \Erase(|u|) = |x x|.
      \]
    Since |T| has the form $\forall\Cbar X|.T|_1 \to |T|_2$,
      the case 4(b) holds for |u|.
    Therefore, by 6,
      $\Lml(|T|_1) = |X|_i$ for some $|X|_i \in \Cbar X$.
    Now, let us analyze $|t|_2'$.
    Substituting $|T| = \forall\Cbar X|.T|_1 \to |T|_2$
      to the typing relation of $\Lm\Cbar X_2|.t|_2'$ yields
      \[ \CtxTyRel\Gamma{\Lm\Cbar X_2|.t|_2'}{\forall\Cbar X|.T|_1 \to |T|_2}. \]
    As we saw, $|t|_2'$ is an abstraction term,
      and thus the derivation of the above typing relation provides us that
      $\Cbar X_2 = \Cbar X$ and we can write $|t|_2' = \Lm|y:T|_1|.s|$ where
      \[
        \CtxTyRel{\Gamma, \Cbar X, |y:T|_1}{|s|}{|T|_2},
        \qquad
        \Erase(|s|) = |y y|.
      \]
    By 4, we have two cases in the form of $|T|_1$.
    \begin{itemize}
      \item[(a)]
        $|T|_1 = \forall\Cbar X'|.X|_i'$ where $|X|_i' \in \Cbar X'$ \\
        In this case, we immediately obtain $\Lml(|T|_1) = |X|_i'$.
      \item[(b)]
        $|T|_1 = \forall\Cbar X_1'\Cbar X_2'|.T|_{11} \to |T|_{12}$
        where $
          \Subst{\Cbar X_1'\Cbar X_2' \mapsto \Cbar A} |T|_{11} =
          \Subst{\Cbar X_1' \mapsto \Cbar B}(\forall\Cbar Z|.T|_{11} \to |T|_{12})
        $ \\
        By 6, we obtain $\Lml(|T|_{11}) = |X|_i'$
          for some $|X|_i' \in \Cbar X_1'\Cbar X_2'$.
    \end{itemize}
    Either case contradicts with $\Lml(|T|_1) = |X|_i$,
      as both $\Cbar X'$ in the case (a) and $\Cbar X_1'\Cbar X_2'$ in the case (b)
      are bound at the different place from $\Cbar X$,
      whose members do not overlap.
\end{enumerate}
}

\Ex{23.7.1}
\begin{Code}
  let r = $\Lm$X. ref ($\Lm$x:X. x) in (
    (r [Nat] := $\Lm$x:Nat. succ x);
    (!(r [Bool])) true
  );
\end{Code}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 24.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Existential Types}

\Ex{24.1.1}
We can only extract values of type |X| from |p6| and |p7|,
  which is unknown by the user of the value,
  and thus cannot be used in any way.
The cases |p4| and |p5| are usable in this sense
  because we can extract a |Nat| value by applying the |f| field to the
  |a| field.
The case |p8| is not useful as the packaged type is fully visible,
  and the usage is not different from non-existential type
  $\Rcd{|a:Nat, f:Nat|\to|Nat|}$.

\Ex{24.2.1}
\begin{Code}
  numStackADT = {*List Nat, {
      new = nil [Nat],
      push = cons [Nat],
      top = head [Nat],
      pop = tail [Nat],
      isempty = isnil [Nat]
  }} as {$\exists$NumStack, {
      new: NumStack,
      push: Nat $\to$ NumStack $\to$ NumStack,
      top: NumStack $\to$ Nat,
      pop: NumStack $\to$ NumStack,
      isempty: NumStack $\to$ Bool
  }};

  let {NumStack, numStack} = numStackADT in
  numStack.top (numStack.push 1 (numStack.push 2 numStack.new));
\end{Code}

\Ex{24.2.2}
\begin{Code}
  mutCounterADT = {*Ref Nat, {
      new = $\Lm$_:Unit. ref 1,
      get = $\Lm$r:Ref Nat. !r,
      inc = $\Lm$r:Ref Nat. r := succ (!r)
  }} as {$\exists$MutCounter, {
      new: Unit $\to$ MutCounter,
      get: MutCounter $\to$ Nat,
      inc: MutCounter $\to$ Unit
  }};
\end{Code}

\Ex{24.2.5}
Since each object has its own representation type,
  two objects that we want to pass to the |union| object
  have different representation types unless they are the very same object.
It prevents us from calling the |union| method in a useful way.

\Ex{24.3.1}
\begin{Code}
  {$\exists$X, T} $\EqDef$ $\forall$Y. ($\forall$X. T$\to$Y)$\to$Y;
  let {*X, x} = s in t $\EqDef$ s [S] ($\Lm$X. $\Lm$x:T. t);
\end{Code}

\Ex{24.3.2}
Denote the encoding of terms, types, and typing contexts
  in System F with existential types using universal types as
  $f$, $F$, and $\cF$, respectively.

What we need to verify are
\begin{itemize}
  \item For any term |t|, type |T|, and typing context $\Gamma$
      in System F with existential types,
      $\CtxTyRel\Gamma{|t|}{|T|}$ implies $\CtxTyRel{\cF(\Gamma)}{f(|t|)}{F(|T|)}$.
  \item Suppose we have $\CtxTyRel{}{|t|}{|T|}$ for a closed term |t| and type |T|
      in System F with existential types.
    Let |v| be some value in this system.
    Then, $|t| \to^\star |v|$ implies $f(|t|) \to^\star f(|v|)$.
\end{itemize}

\Ex{24.3.3}
Omitted.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% section 25.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An ML Implementation of System F}

\Todo: Implement System F.

\Ex{25.2.1}
\begin{alignat*}{2}
  \DShift_c^d(|k|) &=
    \begin{cases}
      ~|k| & |k| < c \\
      ~|k| + d & |k| \ge c,
    \end{cases} &\qquad
  \DShift_c^d(|T|_1 \to |T|_2) &= \DShift_c^d(|T|_1) \to \DShift_c^d(|T|_2), \\
  \DShift_c^d(\forall|.T|) &= \forall|.| \DShift_{c+1}^d(|T|), &
  \DShift_c^d(\Rcd{\exists|,T|}) &= \Rcd{\exists|,| \DShift_{c+1}^d(|T|)}.
\end{alignat*}

\Ex{25.4.1}
Because another substitution is performed after the first substitution.
In other words,
  at the first substitution,
  the symbol substituted away is not of the zero-th index,
  which is used by the type variable.

\end{document}
